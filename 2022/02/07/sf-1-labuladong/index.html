<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="xxx," />










<meta name="description" content="简介：该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="labuladong算法秘籍阅读笔记">
<meta property="og:url" content="https://www.noteofzhao.xyz/2022/02/07/sf-1-labuladong/index.html">
<meta property="og:site_name" content="zhao-space">
<meta property="og:description" content="简介：该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-20.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-21.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-22.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-23.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-24.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-25.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-26.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-27.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-28.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-29.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-30.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-31.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-32.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-33.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-34.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-35.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-36.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-37.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-38.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-40.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-39.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-41.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-42.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-43.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-44.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-45.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-46.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-47.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-48.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-50.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-51.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-52.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-53.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-54.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-55.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-56.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-57.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-58.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-59.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-60.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-61.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-62.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-63.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-64.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-65.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-66.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-67.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-68.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-69.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-70.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-71.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-72.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-73.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-74.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-%2076.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-75.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-77.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-78.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-79.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-80.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-81.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-82.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-83.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-84.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-85.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-87.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-88.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-89.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-90.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-91.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-92.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-93.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-94.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-95.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-96.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-97.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-98.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-99.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-100.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-1.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-2.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-3.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-4.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-5.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-7.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-9.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-8.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-10.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-11.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-12.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-13.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-14.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-15.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-16.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-17.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-18.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-19.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-20.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-21.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-22.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-23.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-24.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-25.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-26.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-27.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-28.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-29.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-30.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-31.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-32.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-33.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-34.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-35.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-36.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-37.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-38.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-39.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-40.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-41.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-42.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-43.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-44.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-45.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-46.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-48.png">
<meta property="og:image" content="c:/Users/zhao/Desktop/sf-2-49.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-50.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-51.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-52.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-53.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-54.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-55.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-56.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-57.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-58.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-59.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-60.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-61.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-62.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-63.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-64.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-65.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-66.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-67.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-68.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-69.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-70.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-71.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-72.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-73.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-74.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-75.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-76.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-77.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-78.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-79.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-80.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-81.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-82.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-83.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-84.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-86.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-85.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-87.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-89.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-90.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-91.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-92.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-93.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-94.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-95.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-96.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-97.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-98.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-99.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-100.png">
<meta property="article:published_time" content="2022-02-07T02:17:16.000Z">
<meta property="article:modified_time" content="2022-05-16T05:28:28.943Z">
<meta property="article:author" content="George Zhao">
<meta property="article:tag" content="xxx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
      (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>



  <link rel="canonical" href="https://www.noteofzhao.xyz/2022/02/07/sf-1-labuladong/"/>







  <title>labuladong算法秘籍阅读笔记 | zhao-space</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zhao-space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">--keep moving</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.noteofzhao.xyz/2022/02/07/sf-1-labuladong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhao-space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">labuladong算法秘籍阅读笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-07T10:17:16+08:00">
                2022-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xxx/" itemprop="url" rel="index">
                    <span itemprop="name">xxx</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> View
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  60k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  272
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>简介：</strong>该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。</p>
<span id="more"></span>

<h1 id="一，刷题思维"><a href="#一，刷题思维" class="headerlink" title="一，刷题思维"></a>一，刷题思维</h1><h2 id="1，数据结构的存储方式"><a href="#1，数据结构的存储方式" class="headerlink" title="1，数据结构的存储方式"></a>1，数据结构的存储方式</h2><h3 id="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）"><a href="#（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）" class="headerlink" title="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）"></a>（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</h3><p>散列表、栈、队列、堆、树、图等等各种数据结构 ，都是基于数组和链表的</p>
<h3 id="（2）数组和链表的优缺点"><a href="#（2）数组和链表的优缺点" class="headerlink" title="（2）数组和链表的优缺点"></a>（2）数组和链表的优缺点</h3><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。<u>但正因为连</u><br><u>续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全</u><br><u>部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以</u><br><u>保持连续，时间复杂度 O(N)。</u>  </p>
<p><strong>链表</strong>因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素<br>的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。<u>但是正因为存储空间不连续，<br>你⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位<br>置的指针，会消耗相对更多的储存空间</u></p>
<h2 id="2，数据结构的基本操作"><a href="#2，数据结构的基本操作" class="headerlink" title="2，数据结构的基本操作"></a>2，数据结构的基本操作</h2><h3 id="（1）数据结构的终极目的"><a href="#（1）数据结构的终极目的" class="headerlink" title="（1）数据结构的终极目的"></a>（1）数据结构的终极目的</h3><p>在不同的应⽤场景，尽可能⾼效地增删查改。  </p>
<h3 id="（2）操作的类型"><a href="#（2）操作的类型" class="headerlink" title="（2）操作的类型"></a>（2）操作的类型</h3><p>如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。<br>线性就是 for&#x2F;while 迭代为代表，⾮线性就是递归为代表。再具体⼀步，⽆⾮以下⼏种框架  ：</p>
<p>A，数组遍历框架（典型的线性迭代结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        <span class="comment">//访问并操作arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，链表遍历框架，兼具迭代和递归结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != <span class="keyword">null</span>;p = p.next)&#123;</span><br><span class="line">        <span class="comment">//访问并操作p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，二叉树遍历框架，典型的非线性递归遍历结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D,二叉树框架扩展为N叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E，N叉树遍历扩展为图的遍历</p>
<p>与N叉树类似，但是要避免出现环型的遍历，所以要添加一个布尔类型的Visited来标记是否遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArcNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Boolean visited;<span class="comment">//这里图中的每个节点的visited初始值为false</span></span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历有好几种，深度优先，广度优先，以及非递归，这里类似于N叉树，写深度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ArcNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.visited == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//访问并操作root.val</span></span><br><span class="line">     	root.visited = <span class="keyword">true</span>;</span><br><span class="line">   	 	<span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        	traverse(child);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-算法刷题指南"><a href="#3-算法刷题指南" class="headerlink" title="3,算法刷题指南"></a>3,算法刷题指南</h2><p>首先，<strong>数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法</strong>  ，所以在刷算法之前，应该了解常用的数据结构以及它们的基本操作和优缺点（散列表、栈、队列、堆、树、图等等）</p>
<p>然后，<strong>先刷⼆叉树，</strong>因为二叉树是最容易帮助人建立起框架思维的，对于一道二叉树相关的题，可以分为几个阶段：1，认识出这是一个能通过二叉树解决的问题；2，能写出答题的总体步骤（前序，中序，还是后序？），之中的一些细节就算写错，也不会错到哪儿去；3，扩展到解决其他问题（动态规划，回溯算法等等）</p>
<p><strong>注：</strong>这里我的理解是，二叉树作为一个在整个算法系统中的中间位置，能够很高的起到锻炼的作用，熟悉了二叉树后，简单的题目中的思路可以从二叉树中提取，复杂的题目可以从二叉树中扩展。</p>
<h1 id="二，计算机算法的本质"><a href="#二，计算机算法的本质" class="headerlink" title="二，计算机算法的本质"></a>二，计算机算法的本质</h1><h2 id="1，核心"><a href="#1，核心" class="headerlink" title="1，核心"></a>1，核心</h2><p>算法的本质就是穷举。(当然，某些问题可以通过总结规律解决，某些问题可以通过数学算法解决，但是绝大多数问题都是穷举)</p>
<p>但是此处的穷举并不是指暴力破解那样的寻找，因为一个问题的答案往往有很多条路，所以“穷举”思维，是包含两个层次的含义，如何穷举<strong>和</strong>如何聪明的穷举**，每道题的难点是不一样的</p>
<h3 id="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"><a href="#（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。" class="headerlink" title="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"></a>（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</h3><blockquote>
<p>（P19）前⽂ 动态规划核⼼套路 阐述了动态规划系列问题的核⼼原理，⽆⾮就是先写出暴⼒穷举解法（状态转移⽅程），加个备忘录就成⾃顶向下的动态规划解法了，再改⼀改就成⾃底向上的迭代解法了，动态规划的降维打击 ⾥也讲过如何分析优化动态规划算法的空间复杂度  </p>
<p>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧⼀听就会<br>了。但很多读者留⾔说明⽩了这些原理，遇到动态规划题⽬还是不会做，因为第⼀步的暴⼒解法都写不出<br>来。</p>
<p>这很正常，因为动态规划类型的题⽬可以千奇百怪，找状态转移⽅程才是难点，所以才有了 动态规划设计⽅<br>法：最⻓递增⼦序列 这篇⽂章，告诉你递归穷举的核⼼是数学归纳法，明确函数的定义，然后利⽤这个定义<br>写递归函数，就可以穷举出所有可⾏解。  </p>
</blockquote>
<h3 id="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"><a href="#（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。" class="headerlink" title="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"></a>（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</h3><blockquote>
<p>（p19）⽐如前⽂ Union Find 并查集算法详解 告诉你⼀种⾼效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我⽤ DFS&#x2F;BFS 暴⼒搜索（穷举）肯定可以做到，但⼈家 Union Find 算法硬是⽤数组模拟树结构，给你把连通性相关的操作复杂度给⼲到 O(1) 了。这就属于聪明地穷举，你学过就会⽤，没学过恐怕很难想出这种思路。</p>
<p>再⽐如贪⼼算法技巧，前⽂ 当⽼司机学会贪⼼算法 就告诉你，所谓贪⼼算法就是在题⽬中发现⼀些规律（专业点叫贪⼼选择性质），使得你不⽤完整穷举所有解就可以得出答案。</p>
<p>⼈家动态规划好⽍是⽆冗余地穷举所有解，然后找⼀个最值，你贪⼼算法可好，都不⽤穷举所有解就可以找<br>到答案，所以前⽂ 贪⼼算法解决跳跃游戏 中贪⼼算法的效率⽐动态规划还⾼。</p>
<p>再⽐如⼤名鼎鼎的 KMP 算法，你写个字符串暴⼒匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复⽤⼀些信息，减少了冗余计算，前⽂ KMP 字符匹配算法 就是使⽤状态机的思路实现<br>的 KMP 算法。  </p>
</blockquote>
<h1 id="三，基础数据结构"><a href="#三，基础数据结构" class="headerlink" title="三，基础数据结构"></a>三，基础数据结构</h1><h2 id="1，数组-x2F-链表"><a href="#1，数组-x2F-链表" class="headerlink" title="1，数组&#x2F;链表"></a>1，数组&#x2F;链表</h2><h3 id="（1）前缀和数组"><a href="#（1）前缀和数组" class="headerlink" title="（1）前缀和数组"></a>（1）前缀和数组</h3><p>前缀和，指的是在在计算中，如果要频繁的读取一段区间内的值，那么设定一个基准点，将该基准点以及到各个索引之间的值先计算出来并记录，这样再进行新区间值的计算的时候，能够避免重复计算。</p>
<p><u><strong>力扣303题——区域和检索-数组不可变</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png" alt="sf-1-1"></p>
<p>如果是不考虑时间复杂度，那么每次计算两个索引范围之间的和，都会进行一次数组的遍历，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.nums = nums;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		res += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目要求降低时间复杂度，那么我们要尽量避免同样的操作，前缀和数组就能帮助我们解决这样的问题，主要思路是，建立一个新的数组preSum，然后对于原来的数组nums，以0位基准，将不同范围的nums数组和存储在preSum中，也就是preSum[1]-&gt;sum[0]，preSum[4]-&gt;sum[0] + sum[1]+sum[2] + preSum[3]，那么求索引1~3之间的和，即可用preSum[3+1] - preSum[1]即可。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前缀和数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">	<span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">			preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣304题——二维区域和检索-矩阵不可变</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png" alt="sf-1-2"></p>
<p>此题和上一题类似，还是需要先计算矩阵的前缀和，只是此处的前缀和和上题不同，那么在这里我们需要什么样的前缀和呢？基准点是哪个呢?我们先看一下下面的计算过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png" alt="sf-1-3"></p>
<p>​    要计算红框里的数组和（坐标：2,1,4,3），它的值就等于黄框（0,0,4,3）减去粉框（0,0,1,3）减去绿框（0,0,4,0）最后加上紫框（0,0,1,0），这样我们就将基准点设置好了，同时我们也知道，需要计算的前缀和为坐标为（0,0,x,y）的框的和（x，y为不同的坐标点），利用这些坐标和，就可以算出所有的小框里的数字和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] preSum;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">			preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i- <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ⽬标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">		<span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] +preSum[x1][y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣560——和为k的子数组</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png" alt="sf-1-4"></p>
<p>这道题基础的做法是采用穷举所有子数组的做法，并检查他们是否和为K。但是这种做法太简单了，我们可以尝试用前缀和，有了前缀和在穷举子数组，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// 构造前缀和</span></span><br><span class="line">	<span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 穷举所有⼦数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)	</span><br><span class="line">			<span class="comment">// ⼦数组 nums[j..i-1] 的元素和</span></span><br><span class="line">			<span class="keyword">if</span> (preSum[i] - preSum[j] == k)</span><br><span class="line">				res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这里的时间复杂度还是o(N^2)，空间复杂度是o(N)（空间复杂度都挺高了时间复杂度没降下来说不过去），那么我们需要进行进一步的改良，一个思路是，我们能不能在计算前缀和的同时，判断该前缀和是否存在一个对应的相差为K的前缀和，如果有则统计次数加1，如果没有则跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class="line">	HashMap&lt;Integer, Integer&gt;</span><br><span class="line">		preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// base case	</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum0_i += nums[i];</span><br><span class="line">		<span class="comment">// 这是我们想找的前缀和 nums[0..j]</span></span><br><span class="line">		<span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">		<span class="comment">// 如果前⾯有这个前缀和，则直接更新答案</span></span><br><span class="line">		<span class="keyword">if</span> (preSum.containsKey(sum0_j))</span><br><span class="line">			res += preSum.get(sum0_j);</span><br><span class="line">		<span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数</span></span><br><span class="line">		preSum.put(sum0_i,</span><br><span class="line">			preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）差分数组"><a href="#（2）差分数组" class="headerlink" title="（2）差分数组"></a>（2）差分数组</h3><p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和 。本节与前缀和数组类似，讲的是差分数组，指的是频繁对原始数组的某个区间的元素进⾏增减，最后的数组内容发生了改变。</p>
<p>**<u>引例</u>**：⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给…  最后的数组是什么样的呢？一般情况下，我们不断的循环遍历修改数组就行，但这样每次的时间复杂度都是O(n)，效率不高</p>
<p>所以我们需要使用<strong>差分数组</strong>，差分数组指的是构造一个新的数组diff[]，diff[i] &#x3D; nums[i] - nums[i - 1]（如图）,并且根据差分数组可以反推出原数组（设一个数组res[]，res[0] &#x3D; diff[0]，这样的话原数组res[i] &#x3D; res[i - 1] + diff[i]，其中i &gt;&#x3D; 1），</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png" alt="sf-1-5"></p>
<p>差分数组在频繁的修改某个区间的值中能够降低复杂度，比如要将区间 i ~ j 中的所有数都加3，那么可以将差分数组diff[i] +&#x3D; 3，diff[j] -&#x3D; 3，这样恢复为原数组的时候就可以实现这样的效果。原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -&#x3D; 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 。</p>
<p>差分数组的这些初始化操作，变化操作，以及恢复操作可以抽象为一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;<span class="comment">//assert对一个boolean表达式进行检查，一个正确运行的程序保证boolean值为true，若为false，则说明程序不正确，系统需要提供警告信息并且退出程序。</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] -nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处val可以是负数，另外如果j大于diff.length的话，就表明i之后的数组都要增加val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    	diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">        	diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣370——区间加法</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png" alt="sf-1-6"></p>
<p>这道题使用引例中实现的类即可。代码如下（省略了类的定义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length,<span class="keyword">int</span>[][] updates)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    Difference difference = <span class="keyword">new</span> Difference(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] update : updates)&#123;</span><br><span class="line">        difference.increment(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1109——航班预订统计</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png" alt="sf-1-7"></p>
<p>本体也就是差分数组的变体，写法与上题大致相同，但是这里注意，航班的编号是1 ~ n！，对应数组中的0 ~ n-1!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Different different = <span class="keyword">new</span> Different(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] booking : bookings)&#123;</span><br><span class="line">        different.increment(booking[<span class="number">0</span>] - <span class="number">1</span>,booking[<span class="number">1</span>] - <span class="number">1</span>,booking[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> different.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1094——拼车</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png" alt="sf-1-8"></p>
<p>本题同样是差分数组的扩展，对于这种明显的问题，我们需要明确的是我们在模板中的nums[]，[i，j，val]数组，以及res[]数组的含义。在本题中，明显能发现trip[a,b,c]这个三维数组对应的是变化的标记，那么nums[]数组就是每站车上的人数（初始为0），最后的res[]就是车开了一遍后每站都有多少人。<u>我们判断能否一次性把顾客运送完，就先假设容量无限大，计算出res[],最后遍历res[]看途中是否有不符合条件的情况即可。</u>本题中没有直接说有多少车站，但是说明了车站的范围在0~1000之间，那么可设nums[1001]（初试值为0），代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    Difference df = <span class="keyword">new</span> Difference(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] trip : trips)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = trip[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里注意，j站的时候已经下车啦</span></span><br><span class="line">        <span class="keyword">int</span> j = trip[<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = df.result();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h3><p><strong>引入：</strong>指的是一类问题，通过维护⼀个窗⼝，不断滑动，然后更新答案  。该算法时间复杂度为O（N），比字符串暴利算法高效很多。但是该思路存在很多细节问题：⽐如说如何向窗⼝中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果 …除此之外，出现了Bug调试也很困难。</p>
<p>所以根据labuladong笔记，其中总结了一个框架（包含了debug的输出提示），遇到相关类型，默写该框架，修改三个地方即可解决大部分滑动窗口题。(后面会有几道力扣的题进行使用展示)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need ,window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">//右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">        <span class="comment">//下面更新窗口数据</span></span><br><span class="line">        ...update...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面是debug输出的位置    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>,left,right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">           <span class="comment">//d 是将移出窗口的字符</span></span><br><span class="line">           <span class="keyword">char</span> d = s[left];</span><br><span class="line">           <span class="comment">//左移窗口</span></span><br><span class="line">           left++;</span><br><span class="line">           <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">           ...update...</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>滑动窗⼝很多时候都是在处理字符串相关的问题，Java 处理字符串不⽅便，所以本⽂代码为 C++ 实<br>现。不会⽤到什么编程⽅⾯的奇技淫巧，但是还是简单介绍⼀下⼀些⽤到的数据结构，以免有的读者因为语<br>⾔的细节问题阻碍对算法思想的理解：  </p>
<p>unordered_map 就是哈希表（字典），它的⼀个⽅法 count(key) 相当于 Java 的 containsKey(key)<br>可以判断键 key 是否存在。<br>        可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个<br>key，并把 map[key] 赋值为 0。<br>        所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) +1)。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingWindow</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组/字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量统计 子数组/子区间 是否有效</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量保存结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右指针遍历到数组尾</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">//增加当前右指针对应的数值</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">//当在该区间内 sum 超出定义范围</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                <span class="comment">//移动左指针并调整值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到 while 结束时，我们找到了一个符合题意要求的 子数组/子串，更新结果</span></span><br><span class="line">            res = </span><br><span class="line">            <span class="comment">//移动右指针，去探索下一个区间</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：ren-feiye</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subarray-product-less-than-k/solution/jian-dan-yi-dong-xiang-xi-zhu-jie-shuang-jvy3/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣76——最小覆盖子串</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png" alt="sf-1-9"></p>
<p>这道题我们将代码先贴在下面，然后结合图片观察滑动窗口实现的原理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,先更新start和len的值，然后左移窗口，取left处的字符d，然后自增1。更新操作：判断need中是否有字符d，存在的话（如果window中的d的次数和need中的一样，则valid自减1，）则window中的d的出现次数自减1。若字符d导致了valid自减1，start记录的位置是将其包含在内的。</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若跳出了上面的循环，则取s的子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，本题中的代码的运行流程应该是下面这样，读者可以自己手动过一遍，加强印象</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png" alt="sf-1-10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png" alt="sf-1-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png" alt="sf-1-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png" alt="sf-1-13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png" alt="sf-1-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png" alt="sf-1-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png" alt="sf-1-16"></p>
<blockquote>
<p>使⽤ Java 的读者要尤其警惕语⾔特性的陷阱。Java 的 Integer，String 等类型判定相等应该⽤<br>equals ⽅法⽽不能直接⽤等号 &#x3D;&#x3D;，这是 Java包装类的⼀个隐晦细节。所以在左移窗⼝更新数据的时<br>候，不能直接改写为 window.get(d) &#x3D;&#x3D; need.get(d)，⽽要⽤window.get(d).equals(need.get(d))，之后的题⽬代码同理。  </p>
</blockquote>
<p><strong><u>力扣567——字符串排列</u></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png" alt="sf-1-17" style="zoom:67%;" />

<p>说明：本题第目的就是给你⼀个 s1 和⼀个 s2，请问你 s2中是否存在⼀个⼦串，包含 s1 中所有字符且不包含其他字符？  这里注意，s1中可以包含相同的字符串。</p>
<p>这道题应用在框架中要注意几点：1）窗口在往右扩大时，是一样的，将对应的字母都要包含的窗口中。2）收缩窗口时便有所不同，首先窗口的关闭条件应该是，while（right - left &gt;&#x3D; t.size()），这样才能保证及时缩小窗口。3）在缩小的过程中，一旦valid &#x3D;&#x3D; need.size()  ，便表明找到了最后的答案。    具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,这里窗口收缩的条件不同，right和left限制了一个与目标字符串相同大小的窗口，并且本题不需要记录该字符串的位置，所以也不需要start和len</span></span><br><span class="line">        <span class="comment">// while(valid == need.size())</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">		   <span class="comment">//这里注意，valid值如果与need的值相同，则表明当前窗口下的size个字符都是我们需要的字符</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的循环没有返回true，那就一定是false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣438——找到字符串中所有字母异位词</strong></u></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png" alt="sf-1-18" style="zoom:67%;" />

<p>说明：本题扩大窗口没有特殊的地方，收缩窗口时注意记录子串的起始索引</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣3——最长不重复子串</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png" alt="sf-1-19"></p>
<p>说明：本题没有固定的字符串对应，所以不需要need数组，也不需要valid来记录情况，但是需要window数组来记录窗口中字符的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">char</span> d = s[left];</span><br><span class="line">             left++;</span><br><span class="line">			window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）二分搜索框架"><a href="#（4）二分搜索框架" class="headerlink" title="（4）二分搜索框架"></a>（4）二分搜索框架</h3><p><strong>引入</strong>：⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。⽽且，我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的⼆分查找算法  。下面是二分查找的框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">     	<span class="keyword">int</span> mid = left + (right - left)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚，读者理解后可⾃⾏简化。<br>    其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样的变化。<br>    另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) &#x2F; 2 就和 (left +right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。  </p>
<p>接下来说明几个二分搜索的应用场景：</p>
<p><strong><u>寻找一个数（基本的二分搜索）</u></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left =  mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该算法有几个注意的地方：    1）while判断条件是（left &lt;&#x3D; right），而不是（left &lt; right），我们使用的闭区间搜索（因为right赋值为nums.length - 1)，若此时left和right都是2的话，while(left &lt; right)这个判断语句就会错过2这个下标所代表的位置；      2）当判断过mid位置的数字后，left和right的更新就对应的+1和-1；      3）该算法无法处理有多个结果的情况，比如在数组nums &#x3D; [1,2,2,2,3]中搜索数字2，只能得到索引2，无法得到左侧的索引1和右侧的索引2.</p>
<p><strong><u>寻找左侧边界的二分搜索</u></strong></p>
<p>下面的算法是左右都是闭区间检查，那么rigth的初试值就是nums.length - 1，while的终止条件就是left &#x3D; right + 1。这里要注意，循环的退出条件既然变成了left &#x3D; right + 1，那么如果一个数组中的左右元素都比target小，left就会比right大，所以最后那里需要进行判读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_boud</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.lenght - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>寻找右侧边界的二分查找</u></strong></p>
<p>下面是两边闭区间的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; taeget)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是左侧还是右侧边界的搜索，其实可以抽象为一定范围内的找极值的行为，比如对于nums &#x3D; [1,2,3,3,3,5,7]，想搜索target &#x3D; 3，搜索左侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-20.png" alt="sf-1-20"></p>
<p>搜索右侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-21.png" alt="sf-1-21"></p>
<p>是不是有一种做函数题的感觉</p>
<h3 id="（5）二分搜索题型"><a href="#（5）二分搜索题型" class="headerlink" title="（5）二分搜索题型"></a>（5）二分搜索题型</h3><p>⽂总结的⼆分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够⽤到⼆分搜索 。所以接下来需要一套二分搜索算法应用的套路（思路）</p>
<p><strong>首先</strong>，什么样的题可以使用二分搜索的技巧呢？一般是符合以下条件的题：</p>
<p>可以从题目中抽象出一个自变量x，关于x的函数f(x)，以及一个目标值target，同时x，f(x)，target需要满足以下条件</p>
<p>1，f(x)必须是在x上的单调函数（单增单减都可以）</p>
<p>2，题目要求计算f(x) &#x3D;&#x3D; target时的x的值</p>
<p>对于上一节的例子（就是nums &#x3D; [1,2,3,3,3,5,7]，搜索左侧target &#x3D; 3），可以抽象为下面这样的形式（虽然没必要）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid, nums) == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || f(left, nums) != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，对于一个需要二分搜索解决的问题，我们的思考点应该是几个方面，具体见下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1,根据题意确定x的最小值是多少</span></span><br><span class="line">    <span class="keyword">int</span> left = ...;</span><br><span class="line">    <span class="comment">//2,根据题意确定x的最小值是多少（这个是闭区间写法）</span></span><br><span class="line">    <span class="keyword">int</span> right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= rigth)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//3,怎么让f(x)大一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//4,怎么让f(x)小一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//5,题目求的左边界还是右边界（注意是闭区间写法）</span></span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6,闭区间需要判断是都超出范围</span></span><br><span class="line">    <span class="keyword">if</span> ...;</span><br><span class="line">    <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，想用二分搜索来解决问题的话，主要有以下几步：</p>
<ul>
<li>确定 x, f(x), target 分别是什么，并写出函数 f 的代码  </li>
<li>找到 x 的取值范围作为⼆分搜索的搜索区间，初始化 left 和 right 变量。  </li>
<li>根据题⽬的要求，确定应该使⽤搜索左侧还是搜索右侧的⼆分搜索算法，写出解法代码</li>
</ul>
<p><strong>力扣875——爱吃香蕉的珂珂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</span><br><span class="line"></span><br><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        Tool tool  = <span class="keyword">new</span> Tool();</span><br><span class="line">        <span class="keyword">int</span>[] res = tool.getMaxandMin(piles);</span><br><span class="line">        <span class="keyword">int</span> min = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = res[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getTime(piles,mid) &lt; h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) == h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] getMaxandMin(<span class="keyword">int</span>[] piles)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &gt; max)&#123;</span><br><span class="line">                max = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &lt; min)&#123;</span><br><span class="line">                min = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = min;</span><br><span class="line">        res[<span class="number">1</span>] = max;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            res += (pile % speed == <span class="number">0</span>) ? (pile / speed) : (pile / speed + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1011——在D天内送达包裹的能力</u></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line">返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= days &lt;= weights.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= weights[i] &lt;= 500</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">5000000</span>;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights,mid) == -<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights, mid) &lt; days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights, mid) &gt; days)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights,mid) == days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">5000000</span>) <span class="keyword">return</span> <span class="number">5000000</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &gt; capacity)&#123;</span><br><span class="line">                loc = -<span class="number">1</span>;</span><br><span class="line">                day = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp + weights[i] &gt; capacity)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                loc = i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt; weights.length &amp;&amp; loc != -<span class="number">1</span>)&#123;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）优势洗牌"><a href="#（6）优势洗牌" class="headerlink" title="（6）优势洗牌"></a>（6）优势洗牌</h3><p>该点与双指针关联，这里暂时不添加</p>
<h3 id="（7）原地修改数组"><a href="#（7）原地修改数组" class="headerlink" title="（7）原地修改数组"></a>（7）原地修改数组</h3><p><u><strong>力扣26——删除排序数组中的重复项</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-22.png" alt="sf-1-22"></p>
<p><strong>说明</strong>：由于不能新建数组，所以只能通过指针去探测并记录，在此基础上更新。一个指针无法确定新的元素和应该插入的位置，所以这里需要使用双指针，一个记录插入的位置，一个进行探测，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">           slow ++;</span><br><span class="line">           nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣83——删除排序链表中的重复元素</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-23.png" alt="sf-1-23"></p>
<p><strong>说明</strong>：本题和上一题（力扣26）其实是一样的，只是把数据结构换成了链表，并且多了删除链表的操作，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.val != slow.val)&#123;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣27——移除元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-24.png" alt="sf-1-24"></p>
<p>说明：此题和前面是类似的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣283——移动零)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-25.png" alt="sf-1-25"></p>
<p><strong>说明</strong>：同样用快慢指针就可以了，两种方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,可以使用快慢指针，首先将low指针定位打0的位置出，然后移动fast指针寻找非0的元素进行调换即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] != <span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; nums.length &amp;&amp; nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                nums[fast] = <span class="number">0</span>;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2, 将问题转化，将所有非零元素往前移，然后再将后面多出的元素设为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = removeElement(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(; p &lt; nums.length; p++)&#123;</span><br><span class="line">        nums[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）单链表解题技巧总结"><a href="#（8）单链表解题技巧总结" class="headerlink" title="（8）单链表解题技巧总结"></a>（8）单链表解题技巧总结</h3><p>单链表中，比较常用的操作有：1）合并两个有序链表    2）合并 k 个有序链表    3）寻找单链表的倒数第 k 个节点    4）寻找单链表的中点    5）寻找单链表的中点    6）寻找单链表的中点 。这些解法都⽤到了双指针技巧  ，下面以具体的题来说明</p>
<p><strong>（力扣21——合并两个有序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-26.png" alt="sf-1-26"></p>
<p><strong>说明</strong>：本题可以实现只遍历一次（开辟新的空间），需要使用三个指针，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(list1 == null || list2 == null)&#123;</span></span><br><span class="line">        <span class="comment">//     if(list1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list1;</span></span><br><span class="line">        <span class="comment">//     &#125;else if(list2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list2;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ListNode p1 = list1;</span></span><br><span class="line">        <span class="comment">// ListNode p2 = list2;</span></span><br><span class="line">        <span class="comment">// ListNode head = null;</span></span><br><span class="line">        <span class="comment">// ListNode p = null;</span></span><br><span class="line">        <span class="comment">//if(p1.val &lt;= p2.val)&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p1;</span></span><br><span class="line">        <span class="comment">//    p1 = p1.next;</span></span><br><span class="line">        <span class="comment">//&#125;else&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p2;</span></span><br><span class="line">        <span class="comment">//    p2 = p2.next;</span></span><br><span class="line">        <span class="comment">//&#125;  </span></span><br><span class="line">	  ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">	  ListNode p1 = list1, p2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &lt;= p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣23——合并K个升序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-27.png" alt="sf-1-27"></p>
<p><strong>说明</strong>：本题和上题类似，关键是快速找到不同链表指针指向位置的最小值，我在自己做的时候，每次挑选最小的节点都要遍历一遍当前节点，如下，时间复杂度（on2）空间复杂度都很高，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        ListNode[] plist = <span class="keyword">new</span> ListNode[lists.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            plist[i] = lists[i];</span><br><span class="line">            <span class="keyword">if</span>(lists[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; plist.length - <span class="number">1</span>)&#123;</span><br><span class="line">            min = tool.getMin(plist);</span><br><span class="line">            p.next = plist[min];</span><br><span class="line">            p = p.next;</span><br><span class="line">            plist[min] = plist[min].next;</span><br><span class="line">            <span class="keyword">if</span>(plist[min] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode temp : plist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(ListNode[] comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; comp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( comp[i] != <span class="keyword">null</span> &amp;&amp; min == -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(comp[i] != <span class="keyword">null</span> &amp;&amp;  (comp[i].val &lt; comp[min].val) &amp;&amp; min != -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题解用了<strong>优先级队列（二叉堆）</strong>这种数据结构，时间复杂度仅有O(Nlogk)，其中 k 是链表的条数，N 是这些链表<br>的节点总数。代码如下：（这里使用了java的类，如果题目要求实现一个优先级队列，java有相关的实现类，原理的话<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">看这篇文章</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, lists)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1，设置虚拟头结点，统一操作</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">//2，使用了java的PriorityQueue（优先级队列），第二个参数是lamda表达式，表明现在是按升序排列</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, (a,b)-&gt;(a.val - b.val))</span><br><span class="line">    <span class="comment">//3，将K个链表的头结点加入pq这个最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//pq的poll()方法可以提取出堆头元素</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p指针推进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣19——删除链表的倒数第N个节点）</strong></p>
<p><strong>前言</strong>：链表不同于数组，可以快速定位到特定的位置。如果要定位某些特殊的位置（比如倒数第k个节点），最高效的方式也至少需要一次遍历中找到对应位置（采用双指针），一般思路如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回链表的倒数第K个节点</span></span><br><span class="line"><span class="function">ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">//p1先走k步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">//p1和p2同时走n - k步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p2现在指向第n - k个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>—————————————————————我是分割线————————————————————————</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-28.png" alt="sf-1-28"></p>
<p>说明：本题采用上面的思路进行啦，不过要删除倒数第N个节点，我们需要找到的是倒数第N+1个节点，那么就把前一个指针往前放一位就可以了（第6行中的p1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode p1 = dummy,p2 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣876——链表的中间节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-29.png" alt="sf-1-29"></p>
<p><strong>说明</strong>：其实这题和上一道题类似，都是用双指针，只是这道题比较含蓄，需要找中点，其实也就是两个指针，快的那个比慢的多走一倍即可，这样慢的那个就在中间的位置。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">//这里的思路挺有意思，你必须保证fast能走两步，你的slow才能走一步，fast走两步可以落在null上，但是不能第一步就在null上</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣141——相交链表）</strong><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-30.png" alt="sf-1-30"></p>
<p><strong>说明</strong>：<u>判断链表是否包含环</u>也是链表题型中的一个重要的课题，参考上面的代码，其实也可以用快慢指针来寻找，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，快慢指针初始化指向head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">//2，快指针走到末尾时停止（它也可能没末尾）</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3，走的步伐不一样</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">//4，两个指针相遇，那就说明有换</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这儿那就是没环了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣——剑指offer——链表中环的入口节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-31.png" alt="sf-1-31"></p>
<p><strong>说明</strong>：此题可以转化一下，类比于上面的一题的思路，我们让slow和fast两个速率不同的指针移动，如果fast指针最终指向了null，那么说明没有环；反之，如果存在环，两个指针进入环后，必定会在起点相遇</p>
<p>为什么不是在其他地方相遇呢？这个就很有意思了，类似于小学学的行程问题，这里我就不画图了，直接用labuladong公众号中的图说明，分为几个步骤：1)当两个指针在C点相遇时，假设走了slow指针走了k步，那么fast走了2k步，<strong>多走的k就是环长度的整数倍</strong>（考虑环只有一个元素的特殊情况便可理解）；2）将slow重新放到A点，那么slow走到B点需要k-m步，此时fast指针就和slow指针<strong>同样的速度</strong>走，就会在B点相遇。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-32.png" alt="sf-1-32"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Lpublic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head,fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>力扣160——两个链表是否相交</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-33.png" alt="sf-1-33"></p>
<p><strong>说明</strong>：本题多种思路，首先利用上一题的判断环入口可以实现，也就是将第一条链表的尾接在第二条链表的头上。</p>
<p>第二种思路，统计长度，然后将两个链表的指针放在相同的起始点上，进而进行比较。下面是这种思路的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;p2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)&#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（9）递归操作链表"><a href="#（9）递归操作链表" class="headerlink" title="（9）递归操作链表"></a>（9）递归操作链表</h3><p><strong>（力扣——206）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-34.png" alt="sf-1-34"></p>
<p><strong>说明</strong>：本题有两种做法，非递归和递归方法，先说比较简单但不是重点的非递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归解法，这里比较好理解就不多解释了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p1 = head, p2 = head.next, p3 = head.next.next;</span><br><span class="line">        p1.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            <span class="keyword">if</span>(p3 == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法，看下面的补充进行理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：整个reverse函数的目标是——输⼊⼀个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点，我们可以根据以下几个图来理解整个步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-35.png" alt="sf-1-35"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-36.png" alt="sf-1-36"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-37.png" alt="sf-1-37"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-38.png" alt="sf-1-38"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-40.png" alt="sf-1-40"></p>
<p><strong>（反转链表的前N个节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-39.png" alt="sf-1-39"></p>
<p>说明：这个似乎在力扣上没有对应的题，这里在上题的基础上，可以写出下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor = <span class="keyword">null</span>;<span class="comment">//这里设计一个后驱节点</span></span><br><span class="line"><span class="comment">//反转以head为起点的n个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseN</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//记录第n + 1个节点（也处理了一个节点的情况）</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以head.next为起点，需要反转前n - 1个节点</span></span><br><span class="line">    ListNode last = reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反转完过后，将节点指向互换，并将head指向后一个节点（就像图中的1指向4）</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣92——反转链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-41.png" alt="sf-1-41"></p>
<p><strong>说明</strong>：此题在使用前面函数的基础上，用递归的思想能够很快写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，如果left为1，其实就是上题的反转形式</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，我们要想办法把left变为1，那么也就是把head的位置往后移动，head每往后移动一个位置，其实反转的区间的相对位置就会减1.</span></span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，队列-x2F-栈（不知道为啥就跳到3了）"><a href="#3，队列-x2F-栈（不知道为啥就跳到3了）" class="headerlink" title="3，队列&#x2F;栈（不知道为啥就跳到3了）"></a>3，队列&#x2F;栈（不知道为啥就跳到3了）</h2><h3 id="（1）队列实现栈，以及栈实现队列"><a href="#（1）队列实现栈，以及栈实现队列" class="headerlink" title="（1）队列实现栈，以及栈实现队列"></a>（1）队列实现栈，以及栈实现队列</h3><p><strong>（力扣232——用栈实现队列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-42.png" alt="sf-1-42"></p>
<p><strong>说明</strong>：实现和这个代码，我们需要使用到java中的Stack类，这是一个Vector的子类，它的方法有：1）boolean empty()，判断栈是否为空，空返回true；2）Object peek()，返回栈顶元素，但不删除；3）Object pop(Object element)，返回栈顶元素，并删除；4）Object push(Object element)，将元素入栈并返回元素；5）int search(Object element)，寻找某元素并返回到栈顶的偏移量。了解了这个，那这道题就好办了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> Stack&lt;Integer&gt; s1, s2;</span><br><span class="line">    <span class="comment">//先在构造器中初始化两个栈，栈需要用泛型来制定存储的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入队列就直接进入s1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出队列，先调用peek将s1中的元素放到s2,s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶，那就需要先把s1的元素放到s2，s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty()) s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣225——用队列实现栈）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-43.png" alt="sf-1-43"></p>
<p><strong>说明</strong>：这里需要使用到java中的Queue这个类，它的方法有：1）offer()，从队尾压入元素，返回压入的那个元素；2）poll()，删除并返回对队头被删除的那个元素；3）peek()，获取并返回队头元素。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> top_elem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列中新添加的元素在队尾，其实就是栈顶元素，所以用top_elem记录一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.offer(x);</span><br><span class="line">        top_elem = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈顶元素直接返回top_elem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top_elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//想要出栈，直接把队尾之前的元素统统出队再入队，最后队头就是栈顶元素，但是我们出的时候不要一次性出完，还得     //更新一下top_elem的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        top_elem = q.peek();</span><br><span class="line">        q.offer(q.poll());</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接判断队是不是空就行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（2）括号匹配问题"><a href="#（2）括号匹配问题" class="headerlink" title="（2）括号匹配问题"></a>（2）括号匹配问题</h3><p><strong>（力扣20——有效的括号）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-44.png" alt="sf-1-44"></p>
<p><strong>说明</strong>：单纯的统计左括号和有括号的数量是否相同是不行滴，因为位置有可能对不上，既然出现了位置，那么就能使用栈的特性来进行括号的匹配，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意两点：1）java中Stack的泛型指定只能使用包装类，不过由于自动装箱和自动转换，这个倒是影响不大；2）Stack类的方法要记清楚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; left = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                left.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!left.empty() &amp;&amp; leftOf(c) == left.peek())&#123;</span><br><span class="line">                    left.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣921——使括号有效的最小添加）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-45.png" alt="sf-1-45"></p>
<p><strong>说明</strong>：原题还说了字符串中只包含’(‘和’)’两种字符。其实和上一题类似，只是这里要设置一个计数器，我们遇到左括号入栈，遇到有括号则检查是不是有对应的左括号（没有的话，计数器加一），最后当遍历完字符串后，计数器再加上栈剩余的元素即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,使用栈来解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) stack.push(c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2，不使用栈,以左括号为基准，通过维护对右括号的需求数 need，来计算最⼩的插⼊次数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) need++;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            	need--;</span><br><span class="line">                <span class="comment">//当need为-1的时候，意味着需要插入左括号了</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1541——平衡括号字符串的最好插入次数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-46.png" alt="sf-1-46"></p>
<p><strong>说明</strong>：如果按照上一题的维护res和need变量的话，要考虑几个特殊情况：1）一个左括号对应两个右括号，那么遇到左括号，need值应该+2；2）如果need值为-1的话，那么多了一个右括号，此时res应该+1，表明需要一个左括号，并且need重设为1；3）反观第1）步，如果对有括号的需求为奇数，那么只需要插入一个右括号，所以这里需要进行判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                need += <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//res其实对应了右括号的插入，这里need为奇数，表明前面需要一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                need--;</span><br><span class="line">                <span class="comment">//这里res表明了需要一个左括号的插入，同时需要多对应一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）单调栈"><a href="#（3）单调栈" class="headerlink" title="（3）单调栈"></a>（3）单调栈</h3><p><strong>引入</strong>：单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈后，栈内的元素都保持有序（单调<br>递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型的问题，叫做 Next Greater Element。本⽂⽤讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略  </p>
<p><strong>模板</strong>：给你⼀个数组 nums，请你返回⼀个等⻓的结果数组，结果数组中对应索引存储着下⼀个更⼤元素，如果没有<br>更⼤的元素，就存 -1  。（比如输入nums &#x3D; [2,1,2,4,3]，返回[4,2,4,-1,-1]，也就是第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1 ）</p>
<p>其实没那么复杂，把这一串数字的每一个从后往前放到栈中，然后新的数字来了以后，看栈中的数字大小怎么样，如果比当前的数字小就出栈，否则，你就是它要找的那个数字呀！（这里注意栈空就是表明应该是-1）</p>
<p>倒着⼊栈，其实是正着出栈。while 循环是把两个「个⼦⾼」元素之间的元素排除，因为他们的存在没有意义，前⾯挡着个「更⾼」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">find</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek())&#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">           stack.push(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣739——每日温度)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-47.png" alt="sf-1-47"></p>
<p>这里我们把栈里记录的信息改为下标，就可以实现算出气温高的天数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temperatures.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt;= temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = stack.isEmpty() ? <span class="number">0</span> : stack.peek() - i;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣503——处理环形数组）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-48.png" alt="sf-1-48"></p>
<p><strong>说明</strong>：这题在之前的基础上又麻烦了，两个思路：一个是将数组翻倍，这样的话可以直接套用上面的模板；另一个思路是通过%运算符来实现环形效果。两种方式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，扩展数组的写法，这个还比较简单好理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] numsEx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            numsEx[i] = nums[i];</span><br><span class="line">            numsEx[i + nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numsEx.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; numsEx[i] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(numsEx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2，使用循环数组模拟扩展的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % n] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i % n] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）单调队列解决滑动窗口"><a href="#（4）单调队列解决滑动窗口" class="headerlink" title="（4）单调队列解决滑动窗口"></a>（4）单调队列解决滑动窗口</h3><p><strong>引入</strong>：这里只讲一道题，<strong>力扣239——滑动窗口最大值</strong>，这道题需要使用单调队列来解决，单调队列指的是：一个队列，其中的元素全都是单调递增（或递减）的。</p>
<p><strong>题目</strong>：给你输⼊⼀个数组 nums 和⼀个正整数 k，有⼀个⼤⼩为 k 的窗⼝在 nums 上从左⾄右滑动，请你输出每次<br>窗⼝中 k 个元素的最⼤值。  示例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-50.png" alt="sf-1-50"></p>
<p><strong>步骤</strong>：</p>
<p><u>A，搭建解题框架</u></p>
<p>本题的难点在于如何在 O(1) 时间算出每个「窗⼝」中的最⼤值，使得整个算法在线性时间完成。这种问题的⼀个特殊点在于，「窗⼝」是不断滑动的，也就是你得动态地计算窗⼝中的最⼤值。</p>
<p>假设我们已经有一个单调队列 MonotonicQueue类，有添加元素（push），返回当前最大元素（max），删除元素（pop）方法，并且时间复杂度都是O(1)，使用这个类可以搭出框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;<span class="comment">//两个参数，一个是数组，一个是我们要扫描的窗口</span></span><br><span class="line">    MonotonicQueue window = <span class="keyword">new</span> MononicQueue();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先在窗口中预备好k - 1个元素</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//进入了这个分支就意味着要开始滑动了，先进入一个</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            <span class="comment">//然后找到当前窗口最大值</span></span><br><span class="line">            res.add(window.max());</span><br><span class="line">            <span class="comment">//最后退出一个（注意这里是退出指定的元素哦）</span></span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            arr[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-51.png" alt="sf-1-51" style="zoom:67%;" />

<p><u>B，实现单调队列数据结构</u></p>
<p>「单调队列」的核⼼思路和「单调栈」类似：1）push ()⽅法依然在队尾添加元素，但是要把前⾯⽐⾃⼰⼩的元素<br>都删掉，这样这窗口中的元素入队后，队头始终是最大的按个元素（如果队头和新来新来的元素一样大，那可就千万别动了）；2）max()方法的话，就直接取队头咯；3）pop()方法的话，先判断一下队头元素是不是和之前插入的元素一样，一样再出队，不然可能早就没了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.getLast() &lt; n)&#123;</span><br><span class="line">            q.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        a.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == q.getFirst())&#123;</span><br><span class="line">            q.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，实现 MonotonicQueue 时，我们使⽤了 Java 的 LinkedList，因为链表结构⽀持在头部和尾部快速增删元素；⽽在解法代码中的 res 则使⽤的 ArrayList 结构，因为后续会按照索引取元素，所以数组结构更合适</p>
<h3 id="（5）数组去重"><a href="#（5）数组去重" class="headerlink" title="（5）数组去重"></a>（5）数组去重</h3><p>数组去重其实前面已经练习过，这里是两道增强的题，加上前面的题，应该可以解决大部分问题</p>
<p><strong>（力扣316——去除重复字母）</strong></p>
<p>本题与力扣1081题解法相同</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-52.png" alt="sf-1-52" style="zoom:80%;" />

<p><strong>说明</strong>：本题有两个难点：1）去重字符串中的字符串顺序不能打乱s中字符出现的相对顺序；2）在符合上一条的去重字符串中，字典序最小的为输出（比如示例1，bca和abc都是去重的，但是abc的字典序更小）</p>
<p>这里最好自己手动分析一下，值得注意的是，如果没有1,4，步骤，那么s &#x3D; “bcac”的结果就是ac</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">//1,新建一个数组来统计字符串中不同字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] instack = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//2，每个字符串在进行判断时，都需要将次数-1，这样剩下的数字才能准确反映还有多少，如果这个字母已经在instack数组中了，那么就不用检查了</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span>(instack[c]) <span class="keyword">continue</span>;</span><br><span class="line">		   <span class="comment">//3,要保证字典序，那么入栈的时候，尽量要将小的放底下</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; stk.peek() &gt; c)&#123;</span><br><span class="line">                <span class="comment">//4，对于栈中更大的元素，如果以后还有这个元素，则可以出栈，但是如果没有就别出了，这里也不是continue嗷，因为这个元素是确实需要的去重的一份子</span></span><br><span class="line">                <span class="keyword">if</span>(count[stk.peek()] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//5，出栈了就变为false</span></span><br><span class="line">                instack[stk.pop()] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            instack[c] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6，最终栈中的元素出栈，顺序是反的，还得翻转一下</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，数据结构设计"><a href="#4，数据结构设计" class="headerlink" title="4，数据结构设计"></a>4，数据结构设计</h2><p>数据结构设计题主要就是给你提需求，让你实现 API，⽽且要求这些 API 的复杂度尽可能低 ，一般来说设计题中哈希表的出现频率很⾼，⼀般都是各类其他数据结构和哈希表组合，从⽽改善这些基本数据结构的特性。</p>
<h3 id="（1）实现LRU算法（最近最少使用算法）"><a href="#（1）实现LRU算法（最近最少使用算法）" class="headerlink" title="（1）实现LRU算法（最近最少使用算法）"></a>（1）实现LRU算法（<strong>最近最少使用算法</strong>）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-53.png" alt="sf-1-53"></p>
<p><strong>思路</strong>：</p>
<p>题目要求：1）put和get方法的时间复杂度为O(1)；2）该catch中的元素必须有时序；3）catch中需要快速找到某个key是否已经存在并得到对应的val；4）每次访问catch中的某个key，这个元素的时序要改为最近使用，也就是快速把这个元素抽出来换位置。为了实现这个目标，我们需要使用<strong>哈希链表（双向链表+哈希表）</strong>，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-54.png" alt="sf-1-54" style="zoom:50%;" />

<p>上面的数据结构中，如何满足上面的条件？1）默认从链表尾部添加元素的话，那么越靠近尾部是越近使用的（已经存在的可以先拆下来放到尾部去）；2）对于某个key，可以通过hash表快速定位到链表中对应的节点，免去遍历链表的时间；3）双向链表支持任意位置的插入和删除。</p>
<p>下面我们看看分步骤的代码实现：</p>
<p>A，构建双链表节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = k;</span><br><span class="line">         <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，使用Node构建双链表（该结构要有 表尾添加，删除，表头删除，返回长度等API），双链表可以不用记录前驱结点实现操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，需要有头结点来统一操作</span></span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="comment">//2，链表的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3，链表初始化</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，在链尾加入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.pre = x; </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，删除元素，注意这里能使用该方法表明一定要有x这个节点，判断不在这里判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.pre;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6，删除链头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7，返回链表大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，与哈希表进行结合（这里先是使用上面的数据结构把LRUCatch的数据结构搭建）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，上一步的get和put方法，如果直接写会很容易出现问题，我们应该先抽象几个要使用的方法出来，从而是的get和put不直接操作map和catch，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//4个要使用的方法</span></span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，综合C和D中的内容，写出get和put方法，put方法有点复杂，先画一个运行流程图</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-55.png" alt="sf-1-55" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//2，Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//3，最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，get 和 put方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.contiansKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            deleteKey(key);</span><br><span class="line">            addRecently(key, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        addRecently(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，几个抽象出来的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：1）分析需要使用的数据结构；2）实现基本数据结构和方法；3）实现目标数据结构和方法</p>
<h3 id="（2）实现LFU算法（最不经常使用）"><a href="#（2）实现LFU算法（最不经常使用）" class="headerlink" title="（2）实现LFU算法（最不经常使用）"></a>（2）实现LFU算法（最不经常使用）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-56.png" alt="sf-1-56"></p>
<p><strong>说明</strong>：从实现难度上来说，LFU 算法的难度⼤于 LRU 算法，LFU 算法相当于是把数据按照访问频次进⾏排序，这个需求恐怕没有那么简单，⽽且还有⼀种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插⼊的那个数据。也就是说 <strong>LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据</strong>。  </p>
<p>可以看到LFU 算法是要复杂很多的，⽽且经常出现在⾯试中，因为 LFU 缓存淘汰算法在⼯程实践中经常使⽤，<br>也有可能是应该 LRU 算法太简单了。不过话说回来，<strong><strong>这种著名的算法的套路都是固定的，关键是由于逻辑较</strong><br>复杂，不容易写出漂亮且没有 bug 的代码。</strong>  </p>
<p><strong>思路</strong>：</p>
<p><u>首先</u>，有几点我们需要注意：1）调⽤ get(key) ⽅法时，要返回该 key 对应的 val  ；2）只要⽤ get 或者 put ⽅法访问⼀次某个 key，该 key 的 freq 就要加⼀ ；3）如果在容量满了的时候进⾏插⼊，则需要将 freq 最⼩的 key 删除，如果最⼩的 freq 对应多个 key，则删除其中最旧的那⼀个。  </p>
<p><u>接着</u>，我们的目标是在O(1)的时间复杂度完成这些需求，我们可以使用下面的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,使⽤⼀个 HashMap 存储 key 到 val 的映射，就可以快速计算 get(key)。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、使⽤⼀个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure>

<p><u>接着</u>，有一个核心需求，我们来看看步骤：</p>
<p>1）我们需要 freq 到 key 的映射，⽤来找到 freq 最⼩的 key；</p>
<p>2）将 freq 最⼩的 key 删除，那你就得快速得到当前所有 key 最⼩的 freq 是多少。想要时间复杂度O(1) 的话，肯定不能遍历⼀遍去找，那就⽤⼀个变量 minFreq 来记录当前最⼩的 freq 吧；</p>
<p>3）可能有多个 key 拥有相同的 freq，所以 freq 对 key 是<strong>⼀对多</strong>的关系，即⼀个 freq 对应⼀个 key 的列表；</p>
<p>4）希望 freq 对应的 key 的列表是<strong>存在时序的</strong>，便于快速查找并删除最旧的 key；</p>
<p>5）希望能够快速删除 key 列表中的任何⼀个 key，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 freq+1，就应该从 freq 对应的 key 列表中删除，加到 freq+1 对应的 key 的列表中。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashSet，它满⾜我们 3.3，3.4，3.5 这⼏个要求。你会发现普通的链表LinkedList 能够满⾜ 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某⼀个节点，所以⽆法满⾜ 3.5 的要求。</span></span><br><span class="line"><span class="comment">//LinkedHashSet 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插⼊元素具有时序；哈希集合中的元素⽆序，但是可以对元素进⾏快速的访问和删除。</span></span><br><span class="line"><span class="comment">//那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，⼜可以保持插⼊的时序，⾼效实现 3.5 这个需求。</span></span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="keyword">int</span> minFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>最后，LFU算法的基本数据结构就浮现出来啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line">    <span class="comment">//key到val的映射，简称KV表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">//key到freq的映射，简称KF表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFre;</span><br><span class="line">    <span class="comment">//freq到key的映射，简称FK表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">//记录当前的最小频次数量</span></span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="comment">//记录LFU缓存的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyToFre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码框架</strong>：</p>
<p>A，指导思想</p>
<p><strong>1、</strong>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。<strong>2、</strong>搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。<strong>3、</strong>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p>
<p>B，get方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!keyToVal.containsKey(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加key对应的val</span></span><br><span class="line">    increaseFreq(key);<span class="comment">//这是一个核心方法，抽象为函数看起来比较简介</span></span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，put方法</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-57.png" alt="sf-1-57" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//若key已经存在，则修改对应的val值</span></span><br><span class="line">    <span class="keyword">if</span>(keyToVal.containsKey(key))&#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若key不存在，则需要插入，首先判断容量是不是满了，满了就淘汰一个Freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= keyToVal.size())&#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入key和val，手相放到KV表里去</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">//插入KF表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//插入FK表</span></span><br><span class="line">    freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">//freq更新为最小，就是1</span></span><br><span class="line">    <span class="keyword">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，两个核心函数</p>
<p>可以从上面看出，最核心的两个函数就是removeMinFreqKey()和increaseFreq()函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除某个键key肯定是要同时修改三个映射表的，借助minFreq参数可以从FK表中找到freq最小的keyList，根据时序，其中第一个元素就是要被淘汰的deletedKey，操作三个映射表删除这个key即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里有个问题，如果keyList中只有一个元素，那么删除之后minFreq对应的key列表就为空了，也就是minFreq变量需要被更新。如何计算当前的minFreq是多少呢？（其实只能遍历更新），我们这里不考虑这个情况，因为该方法只有put方法中插入新key时可能调用。而你回头看put的代码，插入新key时一定会把minFreq更新成 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="keyword">this</span>.minFreq);</span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="keyword">int</span> deletedKey = keyList.iterator().next();</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    keyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="keyword">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和之前类似，当FK表中freq对应的列表被删空后，需要删除FK表中freq这个映射。如果这个freq恰好是minFreq，说明minFreq变量需要更新。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能不能快速找到当前的minFreq呢？这里是可以的，因为我们刚才把key的freq加了 1 嘛，所以minFreq也加 1 就行了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = keyToFreq.get(key);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="keyword">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）常数时间查找-x2F-删除数组中任意元素"><a href="#（3）常数时间查找-x2F-删除数组中任意元素" class="headerlink" title="（3）常数时间查找&#x2F;删除数组中任意元素"></a>（3）常数时间查找&#x2F;删除数组中任意元素</h3><p><strong>（力扣380——常数时间插入，删除和获取随机元素）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-58.png" alt="sf-1-58" style="zoom: 67%;" />

<p><strong>思路</strong>：</p>
<p>本题的难点有两个：1）插入，删除，获取随机元素这三个操作的时间复杂度必须为o(1)；2）getRadom方法必须以等概率返回元素。</p>
<p>对于第一个要求，我们熟悉的数据结构中，想到了HashSet，哈希集合的底层原理就是⼀个⼤数组，我们把元素通过哈希函数映射到⼀个索引上；如果⽤拉链法解决哈希冲突，那么这个索引可能连着⼀个链表或者红⿊树。  它能满足常数时间插入，删除。然而问题是，元素是被哈希函数「分散」到整个数组⾥⾯的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素  </p>
<p>那么哈希链表 LinkedHashSet呢？，我们前⽂讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中 ，然而这依然⽆法按要求实现我们的 getRandom 函数，因为底层⽤链表结构存储元素的话，是⽆法在 O(1) 的时间内访问某⼀个元素的。  </p>
<p>所以我们必须用数组，数组最困难的要实现插入和删除的时间复杂度是O(1)，我们只能在尾部进行插入和删除。删除数组中的某⼀个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。交换两个元素必须通过索引进⾏交换对吧，那么我们需要⼀个哈希表 valToIndex 来记录每个元素值对应的索引。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; dict;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list.size(),val);<span class="comment">//这里ArrayList.put(index,val)表示在index位置放入val</span></span><br><span class="line">        dict.put(val, list.size() - <span class="number">1</span>);<span class="comment">//val作为key，这样好查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//</span></span><br><span class="line">        <span class="comment">//将最后一个元素覆盖到val的位置，表示val已经去除，然后就在list和dict删除多余的元素即可</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> last = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lastIdx = dict.get(val);</span><br><span class="line">        list.set(lastIdx, last);</span><br><span class="line">        dict.put(last,lastIdx);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        dict.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣710——黑名单中的随机数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-59.png" alt="sf-1-59"></p>
<p><strong>思路</strong>：我们不能简单的不断去random直到获得一个不是黑名单的数字，那样调用次数非常多。我们发现，题中数组的数字范围和数组大小相同，那么我们是不是可以把黑名单数字全部移到最后，然后把后面的合法数字移到前面来。</p>
<p>当然，移动数字的话是一种思路，我们下面是将黑名单数字映射到合法数字，比如长度为6的数组，遇到了3是一个黑名单数，它的下标是2，如果下标为5的数字6不是黑名单数，那么我们就用map存储&lt;2,6&gt;，表示2这个下标对应的是6，不是黑名单数3啦。之后再随机取的话就好办了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        mapping = <span class="keyword">new</span> HashMap();</span><br><span class="line">        sz = n - blacklist.length;</span><br><span class="line">        <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : blacklist)&#123;</span><br><span class="line">            mapping.put(a,<span class="number">9527</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1，我们的目标是将黑名单的数映射到一个正确的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : blacklist)&#123;</span><br><span class="line">            <span class="comment">//2,如果temp本身就在这个区间里面，就别设置它了</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= sz) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3,如果last指向的位置已经在map中，那么这个last不行</span></span><br><span class="line">            <span class="keyword">while</span>(mapping.containsKey(last))&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping.put(temp,last);</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = rand.nextInt(sz);</span><br><span class="line">        <span class="keyword">if</span>(mapping.containsKey(k)) <span class="keyword">return</span> mapping.get(k);</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）中位数"><a href="#（4）中位数" class="headerlink" title="（4）中位数"></a>（4）中位数</h3><p><strong>（力扣295——数据流的中位数）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-60.png" alt="sf-1-60" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>首先，我们需要回顾一下以往的手段，以及它们的是否能使用：1）普通数组，查找很快，但是插入不行，log（n）的时间复杂度；2）普通链表，也不行，查找慢；3）java的TreeSet，是一种平衡二叉树的实现，底层是红黑树，但是它是一个set不能输入重复元素，其次它并没有实现一个通过排名快速计算元素的 API。假设我想找到<code>TreeSet</code>中第 5 大的元素，并没有一个现成可用的方法实现这个需求；4）优先级队列（二叉堆），也不太行，它是一种受限的数据结构，只能从堆顶添加&#x2F;删除元素，我们的<code>addNum</code>方法可以从堆顶插入元素，但是<code>findMedian</code>函数需要从数据中间取，这个功能优先级队列是没办法提供的。</p>
<p>我们必须要使用有序数据结构，本题核心是，使用两个优先级队列，优先级队列前面用过，能够使插入的元素按顺序排列，看看下面这个图，我们就知道原理了</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-61.png" alt="sf-1-61"  />

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这个优先级队列默认从小到大排列，所以small使用lamda表达式调整对从大到小</span></span><br><span class="line">        large = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small.size() &gt;= large.size())&#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四，进阶数据结构"><a href="#四，进阶数据结构" class="headerlink" title="四，进阶数据结构"></a>四，进阶数据结构</h1><h2 id="1，二叉树"><a href="#1，二叉树" class="headerlink" title="1，二叉树"></a>1，二叉树</h2><p><strong>二叉树非常重要，</strong>这是因为二叉树的思想在很多算法题中都有出现，何以见得？看看快速排序和归并排序。</p>
<p>快速排序其实就是一个前序遍历的思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">	<span class="comment">/************************/</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lo;</span><br><span class="line">    <span class="keyword">int</span> index = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[p])&#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, p, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序则是一个后序遍历的思想（先对左右子数组排序，再进行合并）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">	sort(nums, lo, mid);</span><br><span class="line">	<span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">	sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">	<span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">	<span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">	merge(nums, lo, mid, hi);</span><br><span class="line">	<span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树中的递归算法</strong>，</p>
<p>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节。  </p>
<p>⽐如说让你计算⼀棵⼆叉树共有⼏个节点：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ⾃⼰加上⼦树的节点数就是整棵树的节点数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个问题⾮常简单，⼤家应该都会写这段代码，root 本身就是⼀个节点，加上左右⼦树的节点数就是以</span><br><span class="line">root 为根的树的节点总数。</span><br><span class="line">左右⼦树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，</span><br><span class="line">递归调⽤ count 函数即可算出来</span><br></pre></td></tr></table></figure>

<p>简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调⽤⼦节点，递归调⽤会让孩⼦节点做相同的事情。  </p>
<h3 id="（1）二叉树——1"><a href="#（1）二叉树——1" class="headerlink" title="（1）二叉树——1"></a>（1）二叉树——1</h3><p><strong>（力扣226——翻转二叉树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-62.png" alt="sf-1-62" style="zoom:67%;" />

<p><strong>思路</strong>：本题代码简单，但是要想清楚，到底用哪种遍历呢？其实前序和后序都可以，但是中序不行，中序遍历换节点 根据左根右的遍历顺序 相当于左侧节点交换了两次 右侧节点没换  因为遍历根的时候交换了左右节点 遍历右侧的时候还是之前那个左节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode left = root.left, right = root.right;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        invertTree(left);</span><br><span class="line">        invertTree(right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣116——填充每个节点的下一个右侧节点指针）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-63.png" alt="sf-1-63" style="zoom: 80%;" />

<p><strong>思路</strong>：这里需要高度抽象，别想太多，对于一个节点的左子树和右子树，应该先递归连接它们的孩子，然后把左子树的右指针，连到右子树的左指针。还是看代码吧（一看就会，一作就废）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        connectTwoNode(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键就是这里，我们要同时递归操作两个节点（或者是两个子树），所以需要这个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node node1, Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        connectTwoNode(node1.left, node1.right);</span><br><span class="line">        connectTwoNode(node2.left, node2.right);</span><br><span class="line">        <span class="comment">//这里就是将两个分开的字数连在一起的操作，别去想为什么</span></span><br><span class="line">        connectTwoNode(node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣114——将二叉树展开为链表)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-64.png" alt="sf-1-64"></p>
<p><strong>说明</strong>：左子树和右子树操作完应该按照链来处理，不再是树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==  <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">		<span class="comment">//经过上面的递归，左子树和右子树都变为链，此时进行连接操作。</span></span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line"></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;   </span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉树——2"><a href="#（2）二叉树——2" class="headerlink" title="（2）二叉树——2"></a>（2）二叉树——2</h3><p><strong>（力扣654——最大二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-65.png" alt="sf-1-65"></p>
<p><strong>思路</strong>：这道题就是，找到最大值作为根节点，然后构建左子树，构建右子树，然后根节点接上左子树和右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CreateTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>,maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">        root.left = CreateTree(nums, begin, maxIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = CreateTree(nums, maxIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣105——通过前序和中序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-66.png" alt="sf-1-66"></p>
<p><strong>思路</strong>：这是经典问题了，关键是每次都要传入两个数组，并且限定好两个数组的范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span> <span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize = index - inStart; </span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftsize,</span><br><span class="line">            inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, preStart + leftsize + <span class="number">1</span>, preEnd,</span><br><span class="line">            inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣106——利用中序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-67.png" alt="sf-1-67"></p>
<p><strong>思路</strong>：类似于上一题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postStart &gt; postEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSize = rootIndex - inStart;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        root.left = build(inorder, inStart, rootIndex - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, rootIndex + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣889——根据前序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-68.png" alt="sf-1-68"></p>
<p><strong>思路</strong>：这里是无法确一颗二叉树的，只需要返回一种可能的情况就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//！！！这里其实对应的是特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="keyword">int</span> nextRIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postStart; i &lt;= postEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] == preorder[preStart + <span class="number">1</span>])&#123;</span><br><span class="line">                nextRIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = nextRIdx - postStart;</span><br><span class="line">		<span class="comment">//!!!这里的nextRIdx不要换成leftsize</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize + <span class="number">1</span>, postorder, postStart, nextRIdx);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">2</span>, preEnd, postorder, nextRIdx + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉树——3"><a href="#（3）二叉树——3" class="headerlink" title="（3）二叉树——3"></a>（3）二叉树——3</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-69.png" alt="sf-1-69" style="zoom:80%;" />

<p><strong>思路</strong>：这题在判断子树的结构时，需要将子树序列化成一个String，这样方便比较，然后再把子树的String进行存储和比较，具体看代码比较清晰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; subTree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String left = traverse(root.left);</span><br><span class="line">        String right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        String sub = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time = subTree.getOrDefault(sub, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>) res.add(root);</span><br><span class="line">        subTree.put(sub, time + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）二叉树序列化，多种框架"><a href="#（4）二叉树序列化，多种框架" class="headerlink" title="（4）二叉树序列化，多种框架"></a>（4）二叉树序列化，多种框架</h3><p><strong>（力扣297——二叉树序列化和反序列化）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-70.png" alt="sf-1-70"  />

<p><strong>思路</strong>：本题可以用前序遍历，后序遍历，中序遍历，层次遍历解决，这里按顺序来展示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 前序遍历 将二叉树转换为字符串，比如例子会转换为[1,2,#,#,3,4,#,#,5,#,#]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于上面的字符串中有空指针信息，那么便可以根据前序遍历结构，前序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果字符是#表示空指针，返回空指针</span></span><br><span class="line">        String first = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(first.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(first));</span><br><span class="line"></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 后序遍历 将二叉树转换为字符串，比如例子会转换为[2,#,#,4,#,#,5,#,#,3,1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以[2,#,#,4,#,#,5,#,#,3,1]为基础后序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String last = nodes.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(last.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(last));</span><br><span class="line">        <span class="comment">//从后往前在 nodes 列表中取元素，一定要先构造 root.right 子树，后构造 root.left 子树</span></span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历实现不了</span></span><br><span class="line">想实现反序列方法，首先要构造 root 节点。前序遍历得到的 nodes 列表中，第一个元素是 root 节点的值；后序遍历得到的 nodes 列表中，最后一个元素是 root 节点的值。</span><br><span class="line"></span><br><span class="line">你看上面这段中序遍历的代码，root 的值被夹在两棵子树的中间，也就是在 nodes 列表的中间，我们不知道确切的索引位置，所以无法找到 root 节点，也就无法进行反序列化。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">//1,标准的层次遍历框架（重要）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1，初始化队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,实现序列化实现，题中的序列化结果为[1,2,3,#,#,4,5,#,#,#,#]</span></span><br><span class="line">String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val).append(spe);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，这里并不会判断是不是NULL，因为就算是，也需要加入到String的信息中去</span></span><br><span class="line">        q.offer(cur.left);</span><br><span class="line">        q.offer(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,实现反序列化,将[1,2,3,#,#,4,5,#,#,#,#]变为数，可以看到，1对应2和3,2对应#和#，3对应4和5，以此类推</span></span><br><span class="line"><span class="comment">//下面代码中的结构和层次遍历的逻辑非常相似，都是将节点存入队列，然后左孩子进队列，右孩子进队列</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] nodes = data.split(spe);</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)&#123;</span><br><span class="line">        TreeNode parent = q.poll;</span><br><span class="line">        </span><br><span class="line">        String left = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!left.equals(NULL))&#123;</span><br><span class="line">            parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">            q.offer(parent.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String right = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!right.equals(NULL))&#123;</span><br><span class="line">            parent = right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">            q.offer(parent.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）后序遍历"><a href="#（5）后序遍历" class="headerlink" title="（5）后序遍历"></a>（5）后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-71.png" alt="sf-1-71"></p>
<p><strong>思路</strong>：</p>
<p>不管是什么遍历，最关键的就是梳理思路，明确要记录的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-72.png" alt="sf-1-72"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] traverse(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">		<span class="comment">//res[0]代表这个子树是不是二叉搜索树,res[1]树的最大值,res[2]树的最小值 ,res[3]整个树的和</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>])&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><h2 id="2，二叉搜索树"><a href="#2，二叉搜索树" class="headerlink" title="2，二叉搜索树"></a>2，二叉搜索树</h2><h3 id="（1）二叉搜索树——1"><a href="#（1）二叉搜索树——1" class="headerlink" title="（1）二叉搜索树——1"></a>（1）二叉搜索树——1</h3><p><strong>(力扣230——二叉搜索树中第K小的元素)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-73.png" alt="sf-1-73" style="zoom: 80%;" />

<p><strong>思路</strong>：二叉搜索树的中序遍历就是从小到大排序的，所以这里进行一个简单的中序遍历就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,简单的遍历方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       preTraverse(root,k);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            res =  root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2，如果说TreeNode中，每个节点包含自己的排序信息，那么这里的时间复杂度可以降低到O(logN),</span></span><br><span class="line"><span class="comment">//如果节点中有以自己为根的子树的节点数信息，那么排名 = root.val - root.left.val</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么中序遍历的算法中,就可以直接计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val - root.left.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣538——把二叉搜索树转化为累加树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-74.png" alt="sf-1-74"></p>
<p><strong>思路</strong>：原本的二叉搜索树，中序遍历是按照从左往右，升序打印。如果这里我们能从右往左，降序打印，便可解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉搜索树——2-检查，搜索，插入，删除"><a href="#（2）二叉搜索树——2-检查，搜索，插入，删除" class="headerlink" title="（2）二叉搜索树——2   (检查，搜索，插入，删除)"></a>（2）二叉搜索树——2   (检查，搜索，插入，删除)</h3><p><strong>（判断搜索二叉树的合法性）</strong></p>
<p><strong>思路</strong>：给了你一个二叉树，如何判断是不是搜索二叉树？可以尝试在前序遍历的时候，对于一个节点，它&gt;左孩子的值并且&lt;右孩子的值，如果有不满足这个条件的，那不是二叉搜索树。</p>
<p>但是上面的方法并不能完全满足（比如10,5,15,#,#,6,20），因为规则有漏洞，对于一个节点，我们应该比较它与左子树的最大值，和右子树的最小值，以此来判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//相等也是不行的</span></span><br><span class="line">    <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; root.val &gt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; root.val &lt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValid(root.left, min, root) &amp;&amp; isValid(root.right, root, max);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣700——二叉搜索树中搜索）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-%2076.png" alt="sf-1- 76" style="zoom:80%;" />

<p><strong>思路</strong>：这个简单，但是还是时间复杂度的问题，我们可以采取剪枝的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        preTraverse(root, val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            preTraverse(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            preTraverse(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（在BST中插入一个数）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        return insertBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode insertBST(TreeNode root, int val)&#123;</span><br><span class="line">        if(root == null) return new TreeNode(val);</span><br><span class="line"></span><br><span class="line">        if(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertBST(root.left, val);</span><br><span class="line">        &#125;else if(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣450——删除二叉搜索树中的节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-75.png" alt="sf-1-75"></p>
<p><strong>思路</strong>：整体上的思路是，前序遍历，如果该节点需要删除，则删除，如果不是的话，那么该节点链接删除了的左子树，链接删除了的右子树。也就是上面这个框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，简单框架</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，加入删除操作，删除节点有三种情况，每种的解决方式不一样</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//这里包含了root节点没有左右孩子，or有左无右，or有右无左的三种情况</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">//最麻烦的是root节点左右孩子都有的情况，此时只能将右子树接在左子树最大的节点，或者将左子树接在右子树最小的节点来进行处理，这里我们采用第二种</span></span><br><span class="line">        TreeNode midNode = getMin(root.right);</span><br><span class="line">        root.right = deleteNode(root.right, midNode.val);</span><br><span class="line">        minNode.left = root.left;</span><br><span class="line">        minNode.right = root.right;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// BST 最左边的就是最⼩的</span></span><br><span class="line">	<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉搜索树——3"><a href="#（3）二叉搜索树——3" class="headerlink" title="（3）二叉搜索树——3"></a>（3）二叉搜索树——3</h3><p><strong>（力扣96——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-77.png" alt="sf-1-77"></p>
<p><strong>思路</strong>：对于一个数字N，由于二叉搜索树的性质是进行中序遍历后是一个有序的数组，那么假设遍历后为一个大小为N的数组[1,2,3….,N]，对于中间的某个数字x，它所构成的树的形状应该是：（左边1<del>x-1个节点树的形状数）* （右边x+ 1</del>n个节点树的形状数），当左右两边的树的数量为0和1的时候，应该返回1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,下面这种方式时间复杂度非常高，为什么呢？假设我们已经计算出了数量为区间1~3的树的结构数量，我们不应该再计算类似于区间2~4，但是下面的算法会不断计算。所以我们应该将已经计算的存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++分割线+++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,那么我们加入一个memo去记录某个数量能形成的不同子树就行啦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res[end - start + <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> res[end - start + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        res[end - start + <span class="number">1</span>] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣95——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-78.png" alt="sf-1-78"></p>
<p><strong>思路</strong>：此题总体上的思路和上一题类似，但是注意，这里要存储树的结构，我们需要在获得左子树和右子树的情况后，遍历所有的情况并接在根节点上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> getTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">getTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>); </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = getTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = getTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftNode : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightNode : right)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = leftNode;</span><br><span class="line">                    root.right = rightNode;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="3，图论"><a href="#3，图论" class="headerlink" title="3，图论"></a>3，图论</h2><blockquote>
<p>图论在实际笔试中考的不多，但它的经典算法⽐较多，⽐如什么最⼩⽣成树，最短路径，拓扑排序，⼆分图<br>判定之类的。<br>        所以本章围绕图论的经典算法展开，太难的图论算法我觉得咱是没多⼤必要掌握的。  </p>
</blockquote>
<h3 id="（1）图论基础"><a href="#（1）图论基础" class="headerlink" title="（1）图论基础"></a>（1）图论基础</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-79.png" alt="sf-1-79" style="zoom:50%;" />

<p><strong>(图的逻辑结构)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图结点的逻辑结构，存储值id，以及连接的节点存在neighbors中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（图的常用存储方式）</strong></p>
<p>在实际应用中，我们很少用上面的节点的方式来对图进行操作，我们更常用的是邻接表和邻接矩阵</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-80.png" alt="sf-1-80" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="comment">//graph[x]存储x的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="comment">//matrix[x][y]记录x是否有一条指向y的边</span></span><br><span class="line"><span class="keyword">boolean</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">邻接表：</span><br><span class="line">    优势：占用空间少</span><br><span class="line">    劣势：⽆法快速判断两个节点是否相邻，需要遍历该节点连接的所有节点才能判断</span><br><span class="line">邻接矩阵：</span><br><span class="line">    优势：占用空间多</span><br><span class="line">    劣势：能快速判断，比如<span class="number">3</span>和<span class="number">1</span>是否相连，我们只需判断[<span class="number">3</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>(度的概念)</strong></p>
<p>在无向图中，一个节点的度就是该节点的相连的边的数量。</p>
<p>在有向图中，一个节点的度分为出度（该节点指向别的节点）和入度（别的节点指向该节点）。</p>
<p>在此基础上，还有权值的概念。</p>
<p><strong>（图的遍历）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图遍历框架,采用的是邻接表的遍历框架</span></span><br><span class="line"><span class="comment">//注意visited和onPath的功能是不一样的，visited用来防止重复遍历，onPath是在当前遍历是否在目前这个路径中</span></span><br><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">boolean</span>[] onPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graphTraverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//前序遍历位置，这里将s标记为已读，并将s加入路径中</span></span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : gragh.neighbors(s))&#123;</span><br><span class="line">        traverse(gragh, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历代码位置，退出路径</span></span><br><span class="line">    onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣797——所有可能的路径）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-81.png" alt="sf-1-81" style="zoom:80%;" />

<p><strong>思路</strong>：使用深度遍历该图时，如果当前的点为n-1，则要在结果中添加当前的path，然后递归遍历每个相邻节点，在递归后要移除加入的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS深度遍历解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在路径中添加该节点值，添加到最后</span></span><br><span class="line">        path.addLast(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">if</span>(s == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果已经到了最后一个节点，那么此时path中已经存在一个从0到n-1的路径，复制并存储到res中去</span></span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[s])&#123;</span><br><span class="line">            traverse(graph, v, path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS广度搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//存结果</span></span><br><span class="line">        <span class="keyword">int</span> n=graph.length;</span><br><span class="line">        Queue&lt;List&lt;Integer&gt;&gt; myque=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//广度优先搜索队列</span></span><br><span class="line"></span><br><span class="line">        myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        myque.peek().add(<span class="number">0</span>);<span class="comment">//队列中的第一个路径添加起始节点</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp;<span class="comment">//在bfs过程中接收临时路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为是有向无环图所以不需要记录是否已经访问过当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(myque.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=myque.remove();<span class="comment">//取出队头元素</span></span><br><span class="line">            Integer temp_int=temp.get(temp.size()-<span class="number">1</span>);<span class="comment">//拿到当前路径的最后一站</span></span><br><span class="line">            <span class="keyword">if</span>(temp_int==n-<span class="number">1</span>)</span><br><span class="line">            &#123;<span class="comment">//是否到达指定终点，到达终点则将当前路径加入ret</span></span><br><span class="line">                ret.add(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Integer i:graph[temp_int])</span><br><span class="line">            &#123;<span class="comment">//从当前路径向后走，因为是有向无环图，所以不用担心重复访问，不用担心走不到终点。</span></span><br><span class="line">                temp.add(i);</span><br><span class="line">                myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));<span class="comment">//一定是深拷贝</span></span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯一下</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：huann-jun</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/all-paths-from-source-to-target/solution/bfs10mssi-lu-qing-xi-xie-zhu-shi-de-du-s-hfdc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h3 id="（2）拓扑排序"><a href="#（2）拓扑排序" class="headerlink" title="（2）拓扑排序"></a>（2）拓扑排序</h3><p><strong>（力扣207——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-82.png" alt="sf-1-82"></p>
<p><strong>思路</strong>：首先我们要建立一个有向图，这里采用邻接表的方式，然后我们可以用深度优先算法来遍历，并想办法判断是否是成环的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,构建邻接表，我们注意返回的是数组，数组的索引对应了元素的值，数组中存储了一个list，表示元素指向的元素</span></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//这里用有向图表示完成from才能进行to</span></span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//2，主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">		<span class="comment">//要遍历所有的课程，保证每个课程完成都没有环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !hasCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3，遍历函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这个onPath加深了我们对路径的理解，它之所以和isVisited不一样，是应为它表示了当前节点是不是在当前路径中，退出了这个路径就会设置为false，而isVisited只是表示当前节点遍历过没有，设置为true就变不回来</span></span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是满足任一条件就要退出来</span></span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣210——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-83.png" alt="sf-1-83"></p>
<p><strong>思路</strong>：</p>
<p>首先，这个题就是需要找出拓扑排序，拓扑排序的顺序就是本题的答案。拓扑排序构造方式是：1）从有向图中选择一个没有前驱（即入度为0）的顶点并且输出它；2）从图中删去该顶点，并且删去从该顶点发出的所有边；3）重复上述步骤1）和2），直到当前有向图中不存在没有前驱结点的顶点为止，或者当前有向图中的所有结点均已输出为止。</p>
<p>其次，拓扑排序的前提是没有环，有换无法形成拓扑结果，所以，我们应该先判断这个里面有没有环。</p>
<p>最后，本题如何得到拓扑排序？本题就是将后序遍历的结果进行反转（当然也可以不反转，但是我们这里构建图的时候，和题中的顺序是不一样的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">    List&lt;Integer&gt; postOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(postOrder);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            res[i] = postOrder.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder.add(s);</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（BFS算法解答）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS算法判断是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment">//BFS算法判断是否能输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer(indgree[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录拓扑排序结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">   <span class="keyword">if</span>(count == numCourses)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二分图判定"><a href="#（3）二分图判定" class="headerlink" title="（3）二分图判定"></a>（3）二分图判定</h3><p><strong>（二分图简介）</strong></p>
<p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且两个⼦集内的顶点不相邻。  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-84.png" alt="sf-1-84" style="zoom: 50%;" />

<p><strong>例子：</strong>其实就是一个图的双色问题，给你⼀幅「图」，请你⽤两种颜⾊将图中的所有顶点着⾊，且使得任意⼀条边的两个端点的颜⾊都不相同，你能做到吗？  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-85.png" alt="sf-1-85" style="zoom:50%;" />

<p><strong>框架：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//遍历节点v的所有相邻节点neighbor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.neighbors(v))&#123;</span><br><span class="line">        <span class="comment">//这里把判断是否visited的逻辑放到了这里，和之前的框架有些许不同，但是我们只要保证没被访问过再进行访问就行</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor])&#123;</span><br><span class="line">            <span class="comment">//相邻节点neighbor没有被访问过</span></span><br><span class="line">            <span class="comment">//那么应该给节点neighbor和v涂上不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果相邻节点neighbor已经被访问过了</span></span><br><span class="line">            <span class="comment">//那么应该比较neighbor和节点v的颜色</span></span><br><span class="line">            <span class="comment">//若相同，则不是二分图</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣785——判断二分图）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-86.png" alt="sf-1-86"></p>
<p><strong>思路</strong>：按照上面的思路就行，但是这里注意，题中说了这可能不是一个连通图，那么在13行那里，我们要判断当前节点是不是新的图的开头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一维数组paint，paint[0]= 0表示0还未着色，paint[0] = -1表示0黑，paint[0] = 1表示0白</span></span><br><span class="line">    <span class="comment">//初试化visited数组</span></span><br><span class="line">    <span class="keyword">int</span>[] paint;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        paint[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.length; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = <span class="number">1</span>;</span><br><span class="line">                canDivide(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">canDivide</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k : graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[k] != <span class="number">1</span>)&#123;</span><br><span class="line">                paint[k] = -paint[v];</span><br><span class="line">                canDivide(graph, k);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[k] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[k] == paint[v])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上面的canDivide方法，我们也可以采用BFS的方式来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Gragh[][] graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	visited[start] = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; !flag)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = q.poll();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v ; graph[k])&#123;</span><br><span class="line">        	<span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = -paint[k];</span><br><span class="line">                visited[v] == <span class="number">1</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag == <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣886——可能的二分法)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-87.png" alt="sf-1-87"></p>
<p><strong>思路</strong>：dislikes就是一个图的数组，但是这里还没有建好图，需要先自己建图，然后进行遍历和判断，如果可以的话，输出数组，否则输出false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;[] graph;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] paint; </span><br><span class="line">    <span class="keyword">boolean</span>[] visited; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1注意，这里没有节点0，所以初始化和赋值都别加</span></span><br><span class="line">        graph = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dislike : dislikes)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = dislike[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = dislike[<span class="number">1</span>];</span><br><span class="line">            graph[from].add(to);</span><br><span class="line">            graph[to].add(from);</span><br><span class="line">        &#125;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2不是联通图的情况还是要判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] graph, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[k] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[k])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                paint[v] = !paint[k];</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）并查集算法详解"><a href="#（4）并查集算法详解" class="headerlink" title="（4）并查集算法详解"></a>（4）并查集算法详解</h3><p><strong>（认识Union-Find算法——并查集算法）</strong></p>
<p><strong>简介</strong>：所谓的Union-Find算法，目标是将节点进行连接，并且能判断当前的连通分量的情况，以及两个节点是否连通，API如下，可以看出，该算法需要提高union 和 connected 函数的效率。⽤什么模型来表示这幅图的连通状态呢？⽤什么数据结构来实现代码呢 ？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里的连通有三个需要注意的点：1）自反性：节点p和q是连通的；2）对称性：如果p和q是连通的，q和p也是连通的；3）传递性：如果p和q连通，q和r连通，则p和r是连通的。</span></span><br><span class="line"><span class="comment">//对于一个图（1,2,3,4,5,6,7,8,9,10），调用union(1,2),则变为（1&lt;-&gt;2,3,4,5,6,7,8,9,10）,连通分量为9个</span></span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：我们使⽤森林（若⼲棵树）来表示图的动态连通性，⽤数组来具体实现这个森林。  具体见下面代码</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-88.png" alt="sf-1-88" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的⾼度。我们可能习惯性地认为树的⾼度就是 logN，但这并不⼀定。logN 的⾼度只存在于平衡⼆叉树，对于⼀般的树可能出现极端不平衡的情况，使得「树」⼏乎退化成「链表」，树的⾼度最坏情况下可能变成 N。  </p>
<p>具体是在哪一步当中出现了树往坏的方向发展呢？答案是在Union当中，将p 所在的树接到 q 所在的树的根节点下⾯，那么这⾥就可能出现「头重脚轻」的不平衡状况，⽐如下⾯这种局⾯：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-89.png" alt="sf-1-89" style="zoom:67%;" />

<p>在之前的操作中，树可能⽣⻓得很不平衡。我们其实是希望，⼩⼀些的树接到⼤⼀些的树下⾯，这样就能避免头重脚轻，更平衡⼀些。解决⽅法是额外使⽤⼀个 size 数组，记录每棵树包含的节点数，也可以称之为树的「重量」  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//小树接到大树下面，会比较平衡一些</span></span><br><span class="line">    <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">    count--;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径压缩</strong>：我们能不能进⼀步压缩每棵树的⾼度，使树⾼始终保持为常数 ？可以，在find方法中顺便将路径进行压缩就可以了.调⽤ find 函数每次向树根遍历的同时，顺⼿将树⾼缩短了，最终所有树⾼都不会超过 3（union 的时候树⾼可能达到 3），树⾼为常数，那么所有⽅法的复杂度也就都是 O(1)。</p>
<p>如果树非常高，最终的树高不就超过3了吗？不是的，只要是正常建树，在建树的过程中就会不断压缩，不会超过3。用了路径压缩的方法，也就不用记录size了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">	<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		parent[x] = parent[parent[x]]</span><br><span class="line">            x = parent[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终的常用的UF类如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]]</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣323——无向连通图中连通分量的数目）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-90.png" alt="sf-1-90" style="zoom:80%;" />

<p><strong>思路</strong>：直接使用UF类即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">	UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">	<span class="comment">// 将每个节点进⾏连通</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">		uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回连通分量的个数</span></span><br><span class="line">	<span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣130——被围绕的区域)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-91.png" alt="sf-1-91"></p>
<p><strong>思路</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//1，对于一个二维节点，我们映射到x * n + y一维坐标(m为行,n为列)，m*n留着给dummy节点</span></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//2，这里使用了d这个方向数组，对(i,j)的上下左右进行了遍历和判断，如果也是O的话，则进行连接</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                            uf.connect(i * n + j, x * n + y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果说某个O是与dummy相连接的话，肯定不是被围起来的，反之就是，需要修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!uf.connected(i * n + j, dummy))&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣990——等式方程的可满足性）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-92.png" alt="sf-1-92" style="zoom:80%;" />

<p><strong>思路</strong>：本题思路还是比较清晰的，对于两个是等式的字母，我们将其链接在一个树上，遇到不等式，我们判断他们在并查集中是不是有同一个根，如果是则返回false，遍历完后，返回true；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; letterToN = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            letterToN.put((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(letterToN.get(c1),letterToN.get(c2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uf.isConnected(letterToN.get(c1), letterToN.get(c2)))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootQ == rootP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（5）Kruskal最小生成树算法"><a href="#（5）Kruskal最小生成树算法" class="headerlink" title="（5）Kruskal最小生成树算法"></a>（5）Kruskal最小生成树算法</h3><p><strong>（介绍）</strong>：最小生成树就是一个图中所有可能的⽣成树中，权重和最⼩的那棵⽣成树就叫「最⼩⽣成树」  PS：<u>⼀般来说，我们都是在⽆向加权图中计算最⼩⽣成树的，所以使⽤最⼩⽣成树算法的现实场景中，图的边权重⼀般代表成本、距离这样的标量。</u>  </p>
<p><strong>（加入size的并查集算法）</strong></p>
<p>为了保证在生成最小生成树的过程中没有生成环，我们需要UF算法的协助</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法引入：力扣261——以图判树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-93.png" alt="sf-1-93" style="zoom:67%;" />

<p><strong>思路</strong>：本题的判断逻辑只有一个，对于一个边的两个顶点，如果它俩在一个连通分量里面，就表明有环了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化有n个节点</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="comment">//遍历每一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//如果这条边的两条节点已经在同一个连通分量中，这条边就会导致产生环</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnect(u,v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这条边不会产生环，可能是树的一部分，也可能是一个单独的连通分量</span></span><br><span class="line">        uf.connect(u,v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有最后连通分量为1，才表明生成了一棵树</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//same as before   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法实现）</strong></p>
<p>一个图的最小生成树，必须满足：1）包含图中的所有节点；2）形成的结构是树结构；3）权重和最小</p>
<p>如何保证这个树的权重是最小的呢？我们需要用到贪心思路：<em>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和<code>mst</code>中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入<code>mst</code>集合；否则，这条边不是最小生成树的一部分，不要把它加入<code>mst</code>集合</em></p>
<p>具体实现看两道题：</p>
<p><strong>（力扣1135——最低成本连通所有城市）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-94.png" alt="sf-1-94" style="zoom:67%;" />

<p><strong>思路</strong>：类似于上一道题，只是这里需要先将路径值进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mininumCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span></span>&#123;</span><br><span class="line">    <span class="comment">//nodes range form 1 ~ n,so we need put n+1 in UF&#x27;s constructor</span></span><br><span class="line">    Uf uf = <span class="keyword">new</span> UF(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对connections数组进行升序排序</span></span><br><span class="line">    Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//用mst进行路径值的记录</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : connections)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//添加了这条边就会出现环，所以跳过操作</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnected(u, v))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.connect(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里用2是因为0这个连通分量一定是单独的。</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//same as before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣1584——连接所有点的最小费用）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-95.png" alt="sf-1-95" style="zoom:80%;" />

<p><strong>思路</strong>：这里需要注意，点与点的关系要转换出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points.length;</span><br><span class="line">    <span class="comment">// 生成所有边及权重</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xi = points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> xj = points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用坐标点在 points 中的索引表示坐标点</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Collections.sort(edges, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行 Kruskal 算法</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)&#123;</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];            </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（算法复杂度）</strong>：</p>
<p>最后说下 Kruskal 算法的复杂度分析：</p>
<p>假设一幅图的节点个数为<code>V</code>，边的条数为<code>E</code>，首先需要<code>O(E)</code>的空间装所有边，而且 Union-Find 算法也需要<code>O(V)</code>的空间，所以 Kruskal 算法总的空间复杂度就是<code>O(V + E)</code>。</p>
<p>时间复杂度主要耗费在排序，需要<code>O(ElogE)</code>的时间，Union-Find 算法所有操作的复杂度都是<code>O(1)</code>，套一个 for 循环也不过是<code>O(E)</code>，所以总的时间复杂度为<code>O(ElogE)</code>。</p>
<h3 id="（6）Dijistra算法"><a href="#（6）Dijistra算法" class="headerlink" title="（6）Dijistra算法"></a>（6）Dijistra算法</h3><p><strong>（所需API）</strong></p>
<p>一般情况下，我们使用邻接表来实现算法，接着对于图的问题，我们需要能一个能够找到相邻节点的API，最后我们还需要一个能够获取两个节点之间权重的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,使用邻接表存储图</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,获取某个节点的相邻节点</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> graph[s];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3,获取权重，具体的方式应该根据题意来获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>（图的BFS算法）</strong></p>
<p>从二叉树，到多叉树，到图的BFS算法大体上是一样的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，二叉树BFS遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,多叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">			<span class="keyword">for</span>(TreeNode child : children)&#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,图的BFS（广度优先搜索）框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用q来存储遍历的对象，用visited来判断是否遍历了</span></span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="comment">//记录搜索的步数（在无权图中，就是1，在有权图中，则为边的权值）</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    	<span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//和之前类似，但是要记录是否被遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">		   <span class="keyword">for</span>(Node x : cur.adj)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!visited.contains(x))&#123;</span><br><span class="line">                   q.offer(x);</span><br><span class="line">                   visited.add(x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在上面的代码中，我们发现这些都是对无权图的遍历操作，无权图意味着每条路径的权值都可以是1，那么start到cur的最短路径就是step的数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到了有权图，最短路径可不是这简单了，在有权图中，start节点到cur的最短路径并是不是简单的step的值，而是要考虑权值。我们的目标是基于上面的算法，计算加权图中的最短路径。此时step步数并不是一个有意义的值了，路径的权重和才有意义，那么for循环中的遍历，我们便不再需要，可以去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//怎么去掉呢？这里先以二叉树为例，去掉for循环，但是还想知道depth的值，我们可以新建一个结构体，其中保存depth的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> State(root, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        State cur = q.poll();</span><br><span class="line">        TreeNode cur_node = cur.node;</span><br><span class="line">        <span class="keyword">int</span> cur_depth = cur.depth;</span><br><span class="line">        System.out.print(cur_node.val + <span class="string">&quot;节点在第&quot;</span> + cur_depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur_node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(Sijkstra算法框架)</strong></p>
<p>迪杰斯特拉算法对于一个输入的图和起点start，能够返回start到其他所有节点的最短距离。根据 BFS 的逻辑和⽆权图的特点，第⼀次遇到某个节点所⾛的步数就是最短距离，所以⽤⼀个 visited 数组防⽌⾛回头路，每个节点只会经过⼀次。<br>        加权图中的 Dijkstra 算法和⽆权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第⼀次经过某个节点时的路径权重，不⻅得就是最⼩的，所以对于同⼀个节点，我们可能会经过多次，⽽且每次的 distFromStart可能都不⼀样，⽐如下图：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-96.png" alt="sf-1-96" style="zoom:67%;" />

<p>下面是该算法的伪代码框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，记录节点数据的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="comment">//用来记录节点的id</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//从Start节点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2，获取两个节点权重的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>;</span><br><span class="line"><span class="comment">//3，获取某个节点相邻节点的方法</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> start, List&lt;Integer&gt;[] graph)&#123;</span><br><span class="line">    <span class="comment">//图中节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> V = graph.length;</span><br><span class="line">    <span class="comment">//起点到每个节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="comment">//先把distTo数组全部赋上最大值</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">//其实节点到自己的距离是1</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//4，用优先级队列来存移入的节点，其实用普通队列也可以，只是这里能保证取出来的节点就是当前最小的那个路径</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列初试化</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> State(start, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//5，担心这个while循环无法结束？放入节点的条件很苛刻啦，队列中没有元素的时候，就是值已经赋完的时候</span></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        State curState = pd.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">        <span class="keyword">int</span> curDistFromStart = curState.distFromStart;</span><br><span class="line">        <span class="comment">//注：要求开始节点到某一个节点的最小值，则只需要在函数参数中加一个end，然后加入下面的判断语句就行</span></span><br><span class="line">        <span class="comment">//if(curNodeId == end)&#123;</span></span><br><span class="line">        <span class="comment">//	return curDistFromStart;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(curDistFromeStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于相邻节点，更新开始节点到自己的最小值，并把自己放进队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nextNodeId : adj(curNodeId))&#123;</span><br><span class="line">            <span class="keyword">int</span> distToNextNode = distTo[curNodeId] + weight(curNodeId, nextNodeId);</span><br><span class="line">            <span class="keyword">if</span>(distTo[nextNodeId] &gt; distToNextNode)&#123;</span><br><span class="line">                distTo[nextNodeId] = distToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> State(nextNodeId, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该算法的时间复杂度是O(Elogv),E是边数，V是节点个数</span></span><br></pre></td></tr></table></figure>

<p><strong>（力扣743——网络延迟时间）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-97.png" alt="sf-1-97" style="zoom: 67%;" />

<p><strong>思路</strong>：如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，节点是从1开始的，所以我们构建的图也从1开始</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt;[] gragh = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : times)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">            gragh[from].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;to, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,开始使用迪杰斯特拉算法进行最短路径计算</span></span><br><span class="line">        <span class="keyword">int</span>[] distTo = Dijkstra(k, gragh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distTo.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distTo[i] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="comment">//3,有节点连接不上，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, distTo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] Dijkstra(<span class="keyword">int</span> start, List&lt;<span class="keyword">int</span>[]&gt;[] gragh)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = gragh.length;</span><br><span class="line">        <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">        Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">        distTo[start] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State cur = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = cur.id;</span><br><span class="line">            <span class="keyword">int</span> curDistFromStart = cur.distFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curDistFromStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : gragh[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> disToNextNode = distTo[curNodeId] + neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( distTo[nextNodeId] &gt; disToNextNode)&#123;</span><br><span class="line">                    distTo[nextNodeId] = disToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, disToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distTo;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1631——最小体力消耗路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-98.png" alt="sf-1-98"></p>
<p><strong>思路</strong>：具体都是套框架，但是这里有一点比较重要，在44~49行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; adj(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; neighbor = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span> &amp;&amp; k &lt; m &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n)&#123;</span><br><span class="line">                neighbor.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;k, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] effortTo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m; i++)&#123;</span><br><span class="line">            Arrays.fill(effortTo[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effortTo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a.effortFromStart - b.effortFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curNode = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curx = curNode.x;</span><br><span class="line">            <span class="keyword">int</span> cury = curNode.y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curx == m - <span class="number">1</span> &amp;&amp; cury == n - <span class="number">1</span>) <span class="keyword">return</span> curNode.effortFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNode.effortFromStart &gt; effortTo[curx][cury])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : adj(curx, cury, heights))&#123;</span><br><span class="line">                <span class="keyword">int</span> nextx = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nexty = neighbor[<span class="number">1</span>];</span><br><span class="line">			   <span class="comment">//下一个node的effort，应该是当前遇到的最大值，才能反映出来这条路径的消耗</span></span><br><span class="line">                <span class="keyword">int</span> effortToNextNode = Math.max(effortTo[curx][cury], Math.abs(heights[curx][cury] - heights[nextx][nexty]));</span><br><span class="line">                <span class="comment">//但是要添加到efforTo数组中的话，就需要这条路径的最大值都比目前就记录的小，才能添加</span></span><br><span class="line">                <span class="keyword">if</span>(effortToNextNode &lt; effortTo[nextx][nexty])&#123;</span><br><span class="line">                    effortTo[nextx][nexty] = effortToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextx, nexty, effortToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> x, y;</span><br><span class="line">     <span class="keyword">int</span> effortFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> effortFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.effortFromStart = effortFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1514——概率最大的路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-99.png" alt="sf-1-99"></p>
<p><strong>思路</strong>：本题与之前的题明显有两个不同点：1）图是无向图；2）这里需要计算的不是最短路径，而是最大值。我们解决的办法也是两个点：1）无向图就是双向图，在建图的时候要添加边；2）dijkstra算法计算的是最优值，那么最大值也是可以的，只是需要进行一点小的变化。</p>
<p>最后说一下，标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？因为 Dijkstra 计算最短路径的正确性依赖⼀个前提：路径中每增加⼀条边，路径的总权重就会增加（或减少）。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">double</span>[] succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">double</span>[]&gt;[] graph = <span class="keyword">new</span> LinkedList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> weight = succProb[i];</span><br><span class="line">            <span class="comment">//1,建图的时候，注意统一为double，并且这里是无向图，按照双向图来建图</span></span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) to, weight&#125;);</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) from, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dijkstra(start, end, graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;<span class="keyword">double</span>[]&gt;[] graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] probTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.length];</span><br><span class="line">        Arrays.fill(probTo, - <span class="number">1</span>);</span><br><span class="line">        probTo[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2,此处我们调整为probFromStart值较大的在前面</span></span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(b.probFromStart, a.probFromStart);</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curState = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">            <span class="keyword">double</span> curProbFromStart = curState.probFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNodeId == end) <span class="keyword">return</span> curProbFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curProbFromStart &lt; probTo[curNodeId]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">double</span>[] neighbor : graph[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = (<span class="keyword">int</span>)neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">double</span> probToNextNode = probTo[curNodeId] * neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(probTo[nextNodeId] &lt; probToNextNode)&#123;</span><br><span class="line">                    probTo[nextNodeId] = probToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, probToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">double</span> probFromStart;</span><br><span class="line">    State(<span class="keyword">int</span> id, <span class="keyword">double</span> probFromStart)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.probFromStart = probFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）名流问题"><a href="#（7）名流问题" class="headerlink" title="（7）名流问题"></a>（7）名流问题</h3><p><strong>（引入）</strong>：</p>
<p>名流问题，指的是给你n个人的社交关系（你知道两个人之间是否认识），尝试寻找其中的名人，名人必须满足条件：1）所有其他人都认识名人；2）名人不认识其他任何人。</p>
<p>该问题其实就是一个图结构的问题，抽象为图我们可以这么理解，对于一个有向图(有n个节点)，若a-&gt;b，则表明a认识b（如果是邻接矩阵就是，若graph[i][j] &#x3D; 1，则表明第i个人认识第j个人），那么一个节点如果是名人，则该节点没有出度，且入度为n-1。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-100.png" alt="sf-1-100" style="zoom:80%;" />

<p><strong>（力扣227——搜寻名人）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-1.png" alt="sf-2-1" style="zoom:80%;" />

<p><strong>思路</strong>：本题由浅入深，可以探讨3种不同的思路，对于逻辑很有帮助</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，暴利解决（由于knows底层是访问邻接矩阵，所以该算法时间复杂度高达O(n^2)）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cand = <span class="number">0</span>; cand &lt; n; cand++)&#123;</span><br><span class="line">        <span class="keyword">int</span> other;</span><br><span class="line">        <span class="keyword">for</span>(other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cand == other) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果名人候选人cand认识其他人，或者其他人不认识名人，那么该cand无法继续下去</span></span><br><span class="line">            <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(other == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> cand;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,优化，由于名人不认识其他人，其他人都认识名人，那么就决定了n中至多只有一个名人。</span></span><br><span class="line"><span class="comment">//那么对于两个候选人，我一定能排除一个不是名人的人选项，因为两个人的关系只有四种</span></span><br><span class="line"><span class="comment">//（1），cand认识other，cand肯定不是名人，排除cand</span></span><br><span class="line"><span class="comment">//（2），other认识cand，other肯定不是名人，排除other</span></span><br><span class="line"><span class="comment">//（3），两人互相认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"><span class="comment">//（4），两人互相不认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度为O(n),但空间复杂度变为了O(n).PS：LinkedList 的作⽤只是充当⼀个容器把候选⼈装起来，每次找出两个进⾏⽐较和淘汰，但⾄于具体找出哪两个，都是⽆所谓的，也就是说候选⼈归队的顺序⽆所谓，我们⽤的是 addFirst 只是⽅便后续的优化，你完全可以⽤ addLast，结果都是⼀样的。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//放入候选队列中</span></span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q.addLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">int</span> other = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">            <span class="comment">//cand肯定不是候选人，other还有可能</span></span><br><span class="line">            q.addFirst(other);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other肯定不是候选人，cand还有可能</span></span><br><span class="line">            q.addFirst(cand);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只剩一个了，看它是不是名副其实</span></span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3,其实不需要额外的空间，解法时间复杂度为 O(N)，空间复杂度为 O(1)。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设cand为0</span></span><br><span class="line">    <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">1</span>; other &lt; n; other++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!knows(other, cand) || knows(cand, other))&#123;</span><br><span class="line">            <span class="comment">//other有可能是候选者</span></span><br><span class="line">            cand = other;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other不会是名人，直接进入下一次循环</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在确认一下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五，暴力搜索算法"><a href="#五，暴力搜索算法" class="headerlink" title="五，暴力搜索算法"></a>五，暴力搜索算法</h1><h2 id="1，DFS算法-x2F-回溯算法"><a href="#1，DFS算法-x2F-回溯算法" class="headerlink" title="1，DFS算法&#x2F;回溯算法"></a>1，DFS算法&#x2F;回溯算法</h2><p>回溯算法总体框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">	<span class="keyword">if</span> 满⾜结束条件:</span><br><span class="line">		result.add(路径)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">		做选择</span><br><span class="line">		backtrack(路径, 选择列表)</span><br><span class="line">		撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="（1）回溯算法框架"><a href="#（1）回溯算法框架" class="headerlink" title="（1）回溯算法框架"></a>（1）回溯算法框架</h3><p><strong>（引入）</strong>：</p>
<p>解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。你只需要思考3 个问题：<br>            1、路径：也就是已经做出的选择。<br>            2、选择列表：也就是你当前可以做的选择。<br>            3、结束条件：也就是到达决策树底层，⽆法再做选择的条件。  </p>
<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-2.png" alt="sf-2-2" style="zoom:80%;" />

<p><strong>思路</strong>：对于这样一个全排列问题，我们可以得到下面这样一棵树，也就是在遍历的过程中，我们需要在某个节点进行路径和选择列表的更新操作，比如下图的最右边的蓝色节点，我们的路径中添加了[3]，选择列表值变为[1,2]。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-3.png" alt="sf-2-3" style="zoom:67%;" />

<p>之前算法框架中的backtrack()函数就像是一个指针，指向某个节点，在这个节点之前和之后要进行相关操作，正如树的前序和后序遍历一样。所以回溯算法的核心就是，在进入backtrack()函数之前做出正确的操作，进入之后进行操作</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-4.png" alt="sf-2-4" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，在选择列表里面做选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//4，做出选择</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            backtrack(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5，撤销选择</span></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣51——N皇后）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-5.png" alt="sf-2-5" style="zoom: 80%;" />

<p><strong>思路</strong>：皇后所在的位置，要保证上下左右线，对角线没有其他的皇后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c : board)&#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res.add(charToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            BackTrace(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">charToList</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] c : board) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）集合划分问题"><a href="#（2）集合划分问题" class="headerlink" title="（2）集合划分问题"></a>（2）集合划分问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-7.png" alt="sf-2-7" style="zoom:80%;" />

<p><strong>思路</strong>：本题很符合回溯的思想，需要多种结果，我们也需要进行暴利的遍历尝试来找到答案。但是使用回溯算法的每一道题都有自己的特点，比如这道题，我们在套用框架的过程中，也需要先找到规律。</p>
<p>题中是一个经典的排列组合问题，对于排列组合都可以抽象为球盒模型，本题中我们可以有两种视角：1）对于nums[]中的数字以及最终要放进k个桶，每个数字需要去选择自己应该进哪个桶，最终把每个桶都装满；2）确定要用k个桶去装nums[]数组的数字，由桶来选择要的数字；下面看看代码，注意带数字的注释，带星号的注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,以数字视角</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v :nums) sum += v;</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化，将大的数字放到前面去，这样更容易进入*所标记的剪枝语句中去</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>; i &lt; j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//K个桶（集合），记录每个桶装的数字之和</span></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">//理论上每个桶（集合）中的数字和</span></span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        <span class="comment">//穷举，看nums是否能分为k个和为target的数组</span></span><br><span class="line">        <span class="keyword">return</span> backtrace(nums, <span class="number">0</span>, bucket, target);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归穷举nums中的每个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span>[] bucket, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="comment">//1，如果index==nums的长度，表明每个数字似乎都找到了去处，要检查一下是不是合理的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucket[i] != target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于nums[index]，我们要看看他能装进哪个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">            <span class="comment">//*放不进去这个桶</span></span><br><span class="line">            <span class="keyword">if</span>(bucket[i] + nums[index] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放进i这个桶去试一下</span></span><br><span class="line">            bucket[i] += nums[index];</span><br><span class="line">            <span class="comment">//如果说已经满足所有条件了，返回</span></span><br><span class="line">            <span class="keyword">if</span>(backtrace(nums, index + <span class="number">1</span>, bucket, target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">//放进i去是不行的，回溯</span></span><br><span class="line">            bucket[i] -= nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,以桶的视角，k桶在测试nums[start]这个数字是否装进去，k桶目前的装的容量为bucket，如果装了used就要标记，target是每个桶应该装的大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 排除⼀些基本情况</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : nums) sum += v;</span><br><span class="line">	<span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//使用位图技巧来记录使用过得数字</span></span><br><span class="line">	<span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> target = sum / k;</span><br><span class="line">	<span class="comment">// k 号桶初始什么都没装，从 nums[0] 开始做选择</span></span><br><span class="line">	<span class="keyword">return</span> backtrake(k, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1，创建一个备忘录，对于桶中添加数据的组合是有记录的，其实就是used中的数据的出现情况，当某个情况不满足后，新的情况桶选择数字的情况很可能和之前一样。比如[1,1,1,1,0,0]失败和[1,1,1,1,0,0]失败，可能这四个1添加的时机不同，但他们都会失败。</span></span><br><span class="line">HashMap&lt;Integer, Boolean&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">backtrake</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bucket, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> used, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在这个used非常长，就需要使用String来转换处理</span></span><br><span class="line">    <span class="comment">//String state = Arrays.toString(used);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bucket == target)&#123;</span><br><span class="line">        <span class="comment">//装满了当前桶，递归穷举下一个桶的选择，从nums[0]开始</span></span><br><span class="line">        <span class="keyword">boolean</span> res = backtrake(k - <span class="number">1</span>, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">        <span class="comment">//缓存目前的结果</span></span><br><span class="line">        memo.put(used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(used))&#123;</span><br><span class="line">        <span class="comment">//避免重复计算</span></span><br><span class="line">        <span class="keyword">return</span> memo.get(used);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i位是不是1，是的话表明nums[i]已经装到了别的桶里面去了，就不要判断这数字了</span></span><br><span class="line">        <span class="keyword">if</span>(((used &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] + bucket &gt; target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择当前的数字，并记录</span></span><br><span class="line">        used |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket += nums[i];</span><br><span class="line">        <span class="comment">//递归穷举下一个数字是不是可以被加入</span></span><br><span class="line">        <span class="keyword">if</span>(backtrake(k, bucket, nums, i + <span class="number">1</span>, used, target))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）排列-x2F-组合-x2F-子集问题"><a href="#（3）排列-x2F-组合-x2F-子集问题" class="headerlink" title="（3）排列&#x2F;组合&#x2F;子集问题"></a>（3）排列&#x2F;组合&#x2F;子集问题</h3><p><strong>（引入）</strong></p>
<p>这个部分主要有三种基本形式：</p>
<p>形式⼀、元素⽆重不可复选，即 nums 中的元素都是唯⼀的，每个元素最多只能被使⽤⼀次，这也是最基本<br>的形式。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该只有 [7]。<br>        形式⼆、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使⽤⼀次。以组合为例，如果输⼊ nums &#x3D; [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。<br>        形式三、元素⽆重可复选，即 nums 中的元素都是唯⼀的，每个元素可以被使⽤若⼲次。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]  <strong>（元素可重复可复选，其实就是元素去重的可复选）</strong></p>
<p>上⾯⽤组合问题举的例⼦，但排列、组合、⼦集问题都可以有这三种基本形式，所以共有 9 种变化。除此之外，题⽬也可以再添加各种限制条件，⽐如让你求和为 target 且元素个数为 k 的组合，那这么⼀来⼜可以衍⽣出⼀堆变体，怪不得⾯试笔试中经常考到排列组合这种基本题型。  </p>
<p>但⽆论形式怎么变化，其本质就是穷举所有解，⽽这些解呈现树形结构，所以合理使⽤回溯算法框架，稍改代码框架即可把这些问题⼀⽹打尽  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-9.png" alt="sf-2-9" style="zoom:67%;" />

<p><strong>（力扣78——子集）元素无重复不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-8.png" alt="sf-2-8" style="zoom: 80%;" />

<p>​    <strong>思路</strong>：对于这道题，我们采用树的形式来表示的话，可以得到下面这样的树结构</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-10.png" alt="sf-2-10" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		traceback(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="comment">//由于start会与nums.length比较，所以这里不用再添加额外的return条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(res));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;  nums.length; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line">            </span><br><span class="line">            traceback(nunms, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣77——组合）元素无重不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-11.png" alt="sf-2-11" style="zoom: 80%;" />

<p><strong>思路</strong>：与上一题类似，不过这里我们发现，res只需要添加trace的大小为k的时候的情况</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-12.png" alt="sf-2-12" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        traceback(n,<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line"></span><br><span class="line">            traceback(n, i + <span class="number">1</span>, k);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-13.png" alt="sf-2-13" style="zoom:80%;" />

<p><strong>思路</strong>：这里的选择列表不像上一题，所以这里的选择是考used来做出的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            backtrace(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣90——子集2)元素可重不可复选</strong>  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-14.png" alt="sf-2-14" style="zoom:80%;" />

<p><strong>思路</strong>：这道题的剪枝策略，就是避免进入到同一层中的相同元素</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-15.png" alt="sf-2-15" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrace(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(nums[i]);</span><br><span class="line">            backtrace(nums, i + <span class="number">1</span>);</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(力扣40——组合总和)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-16.png" alt="sf-2-16"></p>
<p><strong>思路</strong>：本题和上一题类似，都有重复元素，但是这里需要计算一下总和值与target的关系，并且多了一个剪枝操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrace(candidates, target, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start,<span class="keyword">int</span> tracksum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracksum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tracksum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(candidates[i]);</span><br><span class="line">            tracksum += candidates[i];</span><br><span class="line">            backtrace(candidates, target, i + <span class="number">1</span>,tracksum);</span><br><span class="line">            tracksum -= candidates[i];</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣39——组合总和）元素无重复可复选</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-17.png" alt="sf-2-17"></p>
<p><strong>思路</strong>：这道题不是找组合，而是找子集，并且这道题可以复选，那么我们在进行下一个元素选择的时候，范围就不能增加了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        trackback(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackback</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> tracesum,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracesum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tracesum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tracesum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(candidates[i]);</span><br><span class="line">            tracesum += candidates[i];</span><br><span class="line">            <span class="comment">//这里我们不能输入i+1，而是输入i</span></span><br><span class="line">            trackback(candidates, target, tracesum,i);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            tracesum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元素无重复可复选的排列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-18.png" alt="sf-2-18"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteRepeat(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	backtrack(nums);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回溯算法核⼼函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case，到达叶⼦节点</span></span><br><span class="line">	<span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">		<span class="comment">// 收集叶⼦节点上的值</span></span><br><span class="line">		res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 回溯算法标准框架</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 做选择</span></span><br><span class="line">		track.add(nums[i]);</span><br><span class="line">		<span class="comment">// 进⼊下⼀层回溯树</span></span><br><span class="line">		backtrack(nums);</span><br><span class="line">		<span class="comment">// 取消选择</span></span><br><span class="line">		track.removeLast();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）岛屿问题"><a href="#（4）岛屿问题" class="headerlink" title="（4）岛屿问题"></a>（4）岛屿问题</h3><p>岛屿系列题⽬的核⼼考点就是⽤ DFS&#x2F;BFS 算法遍历⼆维数组。这里主要讲使用DFS解决岛屿问题。岛屿问题一般是用二维矩阵来解决，矩阵中的每个位置可以看做一个节点，其上下左右位置就是相邻节点，整个矩阵就可以以此抽象为图结构</p>
<p>岛屿问题的框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.rigth);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//二维矩阵遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="comment">//超出索引啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visited[i][j])&#123;</span><br><span class="line">        <span class="comment">//已经遍历过啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入节点i，j（这里也可以使用方向数组的技巧，都一样）</span></span><br><span class="line">    visited[i][j];</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, visited);<span class="comment">//上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, visited);<span class="comment">//下</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, visited);<span class="comment">//左</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, visited);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣200——岛屿数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-19.png" alt="sf-2-19" style="zoom:80%;" />

<p><strong>思路</strong>：我们遍历这个grid，如果发现了陆地，那么计数器加一，并且使用DFS算法把这块地以及相邻的陆地都变成海水</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    DFS(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用DFS将传进来的索引的相连接的陆地，都变成海水</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        DFS(grid, i - <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i + <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        DFS(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1254——统计封闭岛屿的数目）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-20.png" alt="sf-2-20"></p>
<p><strong>思路</strong>：如果一个岛屿靠边，那肯定是不封闭岛屿，所以可以用DFS将靠边的岛屿先淹了。那剩下的部分，和上题是一样的吗？当然是，因为靠边的部分已经变成了海水，那中间只要有陆地，如果上下左右没有相连，那至少是一个陆地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计边淹不靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1020——飞地的数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-21.png" alt="sf-2-21" style="zoom:80%;" />

<p><strong>思路</strong>：和上一题类似，只是统计res的时候不一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣695——岛屿的最大面积）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-22.png" alt="sf-2-22" style="zoom:80%;" />

<p><strong>思路</strong>：还是遇到岛屿要淹没，但是要记录此次淹没的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.max(res, dfs(grid, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dfs(grid, i + <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>) + </span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1905——统计子岛屿）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-23.png" alt="sf-2-23"></p>
<p><strong>思路</strong>：如果grid2中的陆地，对应了grid1中的海洋，那grid2中该陆地所在的岛屿肯定都不是子岛。grid2中剩下的岛屿，必然是对应了grid1中的陆地（也就是grid1中的岛屿）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="keyword">int</span>[][] grid1, <span class="keyword">int</span>[][] grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid1.length, n = grid1[<span class="number">0</span>].length;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid1[i][j] == <span class="number">0</span> &amp;&amp; grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣694——不同岛屿的数量)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-24.png" alt="sf-2-24" style="zoom:67%;" />

<p><strong>思路</strong>：为了判别形状，需要将形状转换成一个序列，然后判断序列的相似性。对于同一个起点进行的遍历，我们最后这个能得到的遍历顺序肯定是相同的，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-25.png" alt="sf-2-25" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="comment">// 记录所有岛屿的序列化结果</span></span><br><span class="line">	HashSet&lt;String&gt; islands = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 淹掉这个岛屿，同时存储岛屿的序列化结果</span></span><br><span class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">			<span class="comment">// 初始的⽅向可以随便写，不影响正确性</span></span><br><span class="line">			dfs(grid, i, j, sb, <span class="number">666</span>);</span><br><span class="line">			islands.add(sb.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不相同的岛屿数量</span></span><br><span class="line">	<span class="keyword">return</span> islands.size();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, StringBuilder sb, <span class="keyword">int</span> dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    sb.append(dir).apped(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, sb, <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, sb, <span class="number">2</span>);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, sb, <span class="number">3</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, sb, <span class="number">4</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="2，BFS算法"><a href="#2，BFS算法" class="headerlink" title="2，BFS算法"></a>2，BFS算法</h2><p>BFS 算法使用队列来实现，常⻅于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达⽬标时的代价是最⼩的。  </p>
<h3 id="（1）BFS算法框架"><a href="#（1）BFS算法框架" class="headerlink" title="（1）BFS算法框架"></a>（1）BFS算法框架</h3><p><strong>（两个点之间的最近距离——框架引入）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start, Node end)</span></span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//这里存储了一层的node</span></span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            <span class="keyword">for</span>(Node node : cur.adj())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node not in cur)&#123;</span><br><span class="line">                    q.offer(node);</span><br><span class="line">                    visited.add(node);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一层为一个step</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。以处理⼆叉树问题的例⼦（下一题），假设给你的这个⼆叉树是满⼆叉树，节点数为 N，对于 DFS 算法来说，空间复杂度⽆⾮就是递归堆栈，最坏情况下顶多就是树的⾼度，也就是 O(logN)。但是你想想 BFS 算法，队列中每次都会储存着⼆叉树⼀层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，⽤ Big O 表示的话也就是 O(N)。由此观之，BFS 还是有代价的，⼀般来说在找最短路径的时候使⽤ BFS，其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣111——二叉树的最小深度）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-26.png" alt="sf-2-26" style="zoom:67%;" />

<p><strong>思路</strong>：套用上面的模板，在某一层的节点中，如果发现某个节点是叶节点，则返回step即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣752——打开轮盘锁）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-27.png" alt="sf-2-27"></p>
<p><strong>思路</strong>：这个题分的思路分为三个阶段：1）使用图的思想进行穷举所有密码；2）在穷举所有密码的基础上，对当前情况进行判断；3）双向BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,如何用BFS的思想对密码进行穷举呢？对于一个初试密码0000，每一个位置都可以up和down，也就是每个位置有2中情况，4个位置就是8种情况，其实也就是0000这个节点有8个子节点</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	ch[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        in sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">//这里进行判断</span></span><br><span class="line">           	System.out.println(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里增加步数 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,1中的代码中我们已经可以列举出所有的密码组合，接下来我们就需要结合题意来进行目标的寻找。我们需要明确三个点：1）target就是我们需要找的目标；2）0000的一个子节点为1000，但1000中又会把0000加进去，造成了死循环；3）遇到死亡代码时，我们的不对其进行操作，因为我们尝试不遇到这种情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(target))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，使用双向BFS来进行优化，也就是同时设置两个起点，当然使用这个必须知道当前情况中的起点和终点，像二叉树找最短深度就用不了。但是在这道题中，我们发现起点就是&quot;0000&quot;，终点就是target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    q1.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String cur : q1)&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q2.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    temp.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）BFS解决智力题"><a href="#（2）BFS解决智力题" class="headerlink" title="（2）BFS解决智力题"></a>（2）BFS解决智力题</h3><p><strong>(力扣773——滑动谜题)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-28.png" alt="sf-2-28"></p>
<p><strong>思路</strong>：对于0来说，它可以走上下左右等位置，进而基于一个情况，可以衍生出子情况，这样就转化成了图的问题。但是本题的关键在于，如何去获取某种情况的子情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//1，目标字符串</span></span><br><span class="line">        String target = <span class="string">&quot;123450&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，获取初始的start</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                sb.append(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String start = sb.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3，这个数组能够获取某个位置相邻的位置，我们将2x3的数组抽象为长度为6的一维数组，那么下标为0的位置在原来的二位数组中对应下标为1，和3的元素</span></span><br><span class="line">        <span class="keyword">int</span>[][] neighbor = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">2</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4，BFS的核心逻辑</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz =q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                String cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(target.equals(cur)) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">//5，找到当前0所在的位置</span></span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(; cur.charAt(idx) != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">                <span class="comment">//将0和周围的元素进行交换，获得新的字符串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> adj : neighbor[idx])&#123;</span><br><span class="line">                    String new_board = swap(cur.toCharArray(), adj, idx);</span><br><span class="line">                    <span class="comment">//避免走回头路</span></span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(new_board))&#123;</span><br><span class="line">                        q.offer(new_board);</span><br><span class="line">                        visited.add(new_board);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">        chars[i] = chars[j];</span><br><span class="line">        chars[j] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六，动态规划"><a href="#六，动态规划" class="headerlink" title="六，动态规划"></a>六，动态规划</h1><h2 id="1，动态规划核心原理"><a href="#1，动态规划核心原理" class="headerlink" title="1，动态规划核心原理"></a>1，动态规划核心原理</h2><h3 id="（1）动态规划解题核心框架"><a href="#（1）动态规划解题核心框架" class="headerlink" title="（1）动态规划解题核心框架"></a>（1）动态规划解题核心框架</h3><p>动态规划问题的一般形式就是求最值，它其实是运筹学的⼀种最优化⽅法，只不过在计算机问题上应⽤⽐较多，⽐如说让你求最⻓递增⼦序列呀，最⼩编辑距离等等。</p>
<p>求最值的核心一般就是穷举，但是动态规划中，存在<strong>“重叠子问题”</strong>这种特殊情况，所以需要<strong>“备忘录”</strong>或“DP table”来优化穷举过程，避免不必要的计算。此外，动态规划问题中一定具备<strong>“最优子结构”</strong>，这样才能通过子问题的最值得到原问题的最值。寻找最优子结构，就需要在穷举的过程中，获取正确的<strong>“状态转移方程”</strong>。</p>
<p>这几个步骤中，最难的就是找状态转移方程，一般我们遵循以下步骤来寻找状态转移方程：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组&#x2F;函数的含义</strong> 。照此可以得到下面的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初试化base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base;</span><br><span class="line"><span class="comment">//对不同的状态state，进行状态的转移</span></span><br><span class="line"><span class="keyword">for</span>  state1 in state1All:</span><br><span class="line">	<span class="keyword">for</span> state2 in state2All:</span><br><span class="line">		<span class="keyword">for</span>...</span><br><span class="line">            dp[state1][state2][...] = getMaxOrMin(choice1, choice2,...)</span><br></pre></td></tr></table></figure>

<p><strong>（力扣509——斐波那契数列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-29.png" alt="sf-2-29"></p>
<p><strong>思路</strong>：</p>
<p>a，这是一道认识动态规划的入门题。该算法可以使用传统的递归方法，但是其中存在大量的重复操作，效率比较低。这里我们直接看讲义中的分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-30.png" alt="sf-2-30"> </p>
<p>b，想要对上面的递归过程进行效率上的提升，我们可以引入「备忘录」，每次算出某个⼦问题的答案后别急着返回，先记到「备忘录」⾥再返回；每次遇到⼀个⼦问题先去「备忘录」⾥查⼀查，如果发现之前已经解决过这个问题了，直接把答案拿出来⽤，不要再耗时去计算了。  </p>
<p>备忘录其实协助进行了一个剪枝操作，下面这两张图就能看出其中的原理，左边表明了剪枝的情况，右边则说明了递归是自顶向下进行的。此时算法的时间复杂度是 O(n)，⽐起上面的暴⼒算法，是降维打击  。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-31.png" alt="sf-2-31" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-32.png" alt="sf-2-32" style="zoom:67%;" /> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">//设定备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里是base case</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">//如果备忘录中已经有值，就别再计算啦</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    </span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>c，DP数组迭代（递推）解法</p>
<p>这里我们可以把这个「备忘录」独⽴出来成为⼀张表，通常叫做 DP table，在这张表上完成「⾃底向上」的推算 （左图）；这⾥，引出「状态转移⽅程」这个名词，实际上就是描述问题结构的数学形式（右图）；</p>
<p>f(n) 的函数参数会不断变化，所以你把参数 n 想做⼀个状态，这个状态 n 是由状态 n - 1 和状态 n - 2转移（相加）⽽来，这就叫状态转移，仅此⽽已。你会发现，上⾯的⼏种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] &#x3D; dp[i -1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个⽅程式的不同表现形式。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-33.png" alt="sf-2-33" style="zoom: 50%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-34.png" alt="sf-2-34" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据斐波那契数列的状态转移⽅程，当前状态只和之前的两个状态有关，其实并不需要那么⻓的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就⾏了.</span></span><br><span class="line"><span class="comment">//这⼀般是动态规划问题的最后⼀步优化，如果我们发现每次状态转移只需要 DP table 中的⼀部分，那么可以尝试缩⼩ DP table 的⼤⼩，只记录必要的数据，从⽽降低空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分别代表 dp[i - 1] 和 dp[i - 2]</span></span><br><span class="line">	<span class="keyword">int</span> dp_i_1 = <span class="number">1</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">// dp[i] = dp[i - 1] + dp[i - 2];</span></span><br><span class="line">		<span class="keyword">int</span> dp_i = dp_i_1 + dp_i_2;</span><br><span class="line">		<span class="comment">// 滚动更新</span></span><br><span class="line">		dp_i_2 = dp_i_1;</span><br><span class="line">		dp_i_1 = dp_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣322——零钱兑换)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-35.png" alt="sf-2-35" style="zoom:80%;" />

<p><strong>思路</strong>：首先明确，该问题具有<strong>最优子结构</strong>（也就是硬币用的数量之间不能有互相的影响，而是每个面额都可以随便用），具体来看就是<strong>原问题</strong>为amount &#x3D; 11时的最小子硬币数，<strong>子问题</strong>为amount &#x3D; 10时的最小子硬币数，那么原问题 &#x3D; 子问题 + 1个硬币即可。确定了最优子结构以后，我们按照三个步骤来完成本题：</p>
<p>A，<u>明确dp数组的含义</u>：当目标金额为i时，至少要dp[i]个硬币才能凑出来</p>
<p>B，<u>状态转移方程</u>：dp[i] &#x3D; dp[i - coin] + 1，由于是要找最小且coin的情况有三种，所以这里应该是min{dp[i] &#x3D; dp[i - coin] + 1, dp[i]}</p>
<p>C,<u>确定初始值</u>：dp[0] &#x3D; 0;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - coin &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）base-case和备忘录的初试值怎么定"><a href="#（2）base-case和备忘录的初试值怎么定" class="headerlink" title="（2）base case和备忘录的初试值怎么定"></a>（2）base case和备忘录的初试值怎么定</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-36.png" alt="sf-2-36"></p>
<p><strong>思路</strong>：</p>
<p><u>A，首先是定义DP数组的含义</u>：int dp(int[][] matrix, int i, int j);  这里其实是个一个特殊的dp数组，表示从第一行的任意位置落下，到i和j位置所需要的最小路径。</p>
<p><u>B，明确状态转移方程</u>；对于matrix[i][j]，它的值的状态是由matrix[i-1][j]，matrix[i-1][j-1]，matrix[i-1][j+1]这三个值来确定的，也就是其中的最小值+matrix[i][j]本身的值。</p>
<p><u>C，确定初始值</u>：第一个行的每个值都是其本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，下面是没有进行剪枝的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(res, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//进行某个点的计算</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i，j位置的值有三个状态确定</span></span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,可以加上备忘录来减少运算</span></span><br><span class="line"><span class="keyword">int</span> memo[][];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        Arrays.fill(memo[j], <span class="number">66666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(matrix, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != <span class="number">66666</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line">本题中的base <span class="keyword">case</span>比较隐蔽，但是只要抓住题中描述，第一行到最后一行的最小值，我们就可以发现，如果只有第一行，那就是当前位置的值，所以base <span class="keyword">case</span>就是<span class="number">0</span>行时的情况</span><br><span class="line">对于备忘录，我们设置了<span class="number">66666</span>的特殊值，这个只要比题意中要求的最大路径还要大就行，那样就不影响结果啦</span><br></pre></td></tr></table></figure>



<h3 id="（3）最优子结构和dp数组的遍历方向怎么定"><a href="#（3）最优子结构和dp数组的遍历方向怎么定" class="headerlink" title="（3）最优子结构和dp数组的遍历方向怎么定"></a>（3）最优子结构和dp数组的遍历方向怎么定</h3><p><strong>最优子结构</strong>：动态规划基于最优子结构，最优子结构意味着题目中的情况有重复子问题。（没有重复子问题不就是递归吗？），在重复子问题的基础上，要求一个最值！（其实有动态子结构就可以写暴力解，然后能优化重复子问题再优化，就是动态规划的一般形式了）</p>
<p>越是困难的动态规划题，最优子结构往往越是隐蔽，这里很好理解，如果一个学校有十个班，每个班的最高分我们可以计算，那么要求全校的最高分我们也能够通过每个班的最高分这个子问题来计算；但是，如果知道每个班的最大分差（最高分 - 最低分），我们并不一定能够知晓全校的最大分差。</p>
<p>那怎么办呢？只能<strong>改造问题</strong>，比如假设最低分基数为0，这样就知道了每个班最高分是多少，然后就可以把问题转换为求最高分。</p>
<p><strong>重叠子问题</strong>：最简单的方式就是把递归树画出来看有没有重叠的子问题（前面的斐波那契数列已经讲过了）</p>
<p>另外就是对于递归部分的代码进行检查，观察从一个状态到另一个状态到底有几种可能，如果有多种可能，那就说明有重复子问题，比如上一节中的matrix[i][j]的转移情况</p>
<p><strong>数组的遍历方向</strong>：有时数组从上往下遍历，有时从下往上，甚至斜着遍历，把握两点，1）遍历的过程中，所需的状态必须是已经计算出来的 ；2）遍历结束后，存储结果的那个位置必须已经被计算出来 </p>
<h3 id="（4）提高刷题幸福感的小技巧"><a href="#（4）提高刷题幸福感的小技巧" class="headerlink" title="（4）提高刷题幸福感的小技巧"></a>（4）提高刷题幸福感的小技巧</h3><h2 id="2，经典动态规划"><a href="#2，经典动态规划" class="headerlink" title="2，经典动态规划"></a>2，经典动态规划</h2><h3 id="（1）最长递增子序列问题"><a href="#（1）最长递增子序列问题" class="headerlink" title="（1）最长递增子序列问题"></a>（1）最长递增子序列问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-37.png" alt="sf-2-37"></p>
<p><strong>思路</strong>：</p>
<p>第一种：数学归纳法</p>
<p><u>A，DP数组的定义</u>：dp[i] 表示以 nums[i] 这个数结尾的最⻓递增⼦序列的⻓度。  （最终的结果就是dp数组中的最大值）</p>
<p><u>B，确定初试值</u>：dp[i]最开始是1，因为子序列肯定有一个自己</p>
<p><u>C，状态转移方程</u>：如果我知道了dp[0~4]的值，我如何计算dp[5]的值？？？</p>
<p>比如下图，我们nums[5]的值为3，那么我们需要找到前⾯那些结尾⽐ 3 ⼩的⼦序列，然后把 3 接到最后，就可以形成⼀个新的递增⼦序列，⽽且这个新的⼦序列⻓度加⼀。  </p>
<p>当然，可能形成很多种新的⼦序列，但是我们只选择最⻓的那⼀个，把最⻓⼦序列的⻓度作为 dp[5] 的值即可。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-38.png" alt="sf-2-38" style="zoom: 33%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-39.png" alt="sf-2-39" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//时间复杂度为O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）最大子数组和问题"><a href="#（2）最大子数组和问题" class="headerlink" title="（2）最大子数组和问题"></a>（2）最大子数组和问题</h3><p><strong>（力扣53——最大子数组和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-40.png" alt="sf-2-40"></p>
<p><strong>思路</strong>：此题无法使用滑动窗口，因为有负数，窗口中值的变化不利于判断窗口如何改变</p>
<p>A，<u>明确dp数组的含义</u>：以 nums[i] 为结尾的「最⼤⼦数组和」为 dp[i]。</p>
<p>B，<u>确定初始值</u>：dp[i] &#x3D; nums[i]</p>
<p>C，<u>确定状态转移方程</u>：假设已经算出了 dp[i-1]，那么dp[i]有两种选择，dp[i-1] + nums[i]或者就是dp[i - 1]，看谁打就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）最长公共子序列问题"><a href="#（3）最长公共子序列问题" class="headerlink" title="（3）最长公共子序列问题"></a>（3）最长公共子序列问题</h3><p><strong>（力扣1143——最长公共子序列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-41.png" alt="sf-2-41"></p>
<p><strong>思路</strong>：两种思路，一种是自顶向下（递归），一种所以自底向上（迭代），下面是按顺序来说明</p>
<p>A，<u>明确dp函数</u>：dp(s1,i,s2,j)计算<code>s1[i..]</code>和<code>s2[j..]</code>的最长公共子序列长度。那么最后的答案就是i和j为0的时候</p>
<p>B，<u>初始状态</u>：也即是i为s1的长度，j为s2的长度，此时计算的是两个空串的公共子序列长度，那此时dp的值就是0</p>
<p>C，<u>转移方程</u>：如果s1[i]与s2[j]是相等的，那么这两个字符一定在LCS当中（左图）；<code>s1[i] != s2[j]</code>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中（右图），此时需要把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度（这里还有一个优化，情况3中的结果肯定比情况1和2短，所以可以不算，一定程度上就是被包含了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-42.png" alt="sf-2-42" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-43.png" alt="sf-2-43" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(text1, <span class="number">0</span>, text2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length() || j == s2.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] =  Math.max(dp(s1, i + <span class="number">1</span>, s2, j), dp(s1, i, s2, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[i][j]表示s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度，我们的目标是求dp[m][n]的lcs的值</p>
<p>B，<u>确定初始状态</u>：dp[0][0]的值为0</p>
<p>C，确定状态转移方程：这里直接看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣583——两个字符串的删除操作）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-44.png" alt="sf-2-44" style="zoom:80%;" />

<p><strong>思路</strong>：计算出最长子序列即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//借助上一题的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣712——两个字符串的最小ASCII删除和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-45.png" alt="sf-2-45" style="zoom:80%;" />

<p><strong>思路</strong>：采用自顶向下的方式（递归）</p>
<p>A，<u>定义dp函数</u>：dp(s1, i, s2, j)表示将串删除为s1[i…]和s2[j…]这样时所需要的最小ASCII和。我们的目标是得到dp(s1,0,s2,0)</p>
<p>B，<u>确定初始值</u>：如果i的值为s1.length(),那么结果中是删除s2剩下元素的总和，反之亦然。</p>
<p>C，<u>确定状态转移方程</u>：如果i和j位置的字符相同，那么从当前状态来看，就不要删除。如果不同，则需要从其他的状态中找最小的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] mm : memo)&#123;</span><br><span class="line">            Arrays.fill(mm, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; s2.length(); j++)&#123;</span><br><span class="line">                res += s2.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == s2.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; s1.length(); i++)&#123;</span><br><span class="line">                res += s1.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">                memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j +<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这里的意思是，继续去找s1.i和s2.j+1对比 以及 s1.i+1和s2.j对比所需要的删除的最小值。所以其实不存在示例2中出错的情况</span></span><br><span class="line">                memo[i][j] = Math.min(dp(s1, i, s2, j +<span class="number">1</span>) + s2.charAt(j), dp(s1, i + <span class="number">1</span>, s2, j) + s1.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代，base case需要设置好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case，</span></span><br><span class="line">        <span class="comment">//如果s2为空，那么s1对应每个位置的需要删除的值就是自己字符串中的值相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + s1.charAt(i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + s2.charAt(j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>), dp[i - <span class="number">1</span>][j] + s1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）编辑距离问题"><a href="#（4）编辑距离问题" class="headerlink" title="（4）编辑距离问题"></a>（4）编辑距离问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-46.png" alt="sf-2-46" style="zoom:80%;" />

<p><strong>思路</strong>：还是分为递归和迭代</p>
<p>A，<u>定义DP函数</u>：对于两个字符串，我们可以从字符串尾开始，如下图，尝试将是b变为s2，我们发现对于i和j指针所指向的字符，包含了三种操作：插入，删除，替换（图中的流程是上帝视角），在这个位置我们到底选择哪种操作，其实是不知道的，必须去找其中最小的那个值；还有一个操作，就是相同的时候啥也别做，减少操作次数。   所以我们可以定义一个DP(s1, i, s2, j)，该函数返回 s1[0..i] 和 s2[0..j] 的最⼩编辑距离 。当i或j为0的时候，就返回另一个字符剩下的长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.gif" alt="sf-2-47" style="zoom: 50%;" />  <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.png" alt="sf-2-47" style="zoom:50%;" /></p>
<p>B，<u>明确初始值</u>：DP函数中的Base，当任意一个字符创到结尾时，返回另一个字符串剩下的长度即可。</p>
<p>C，<u>状态转移方程</u>：DP(s1, i, s2, j) 的值取决于i和j位置处的字符是不是相等的，如果不相等，那就是看插入，删除，还是替换哪种值最小，min(DP(s1, i, s2, j - 1) + 1, DP(s1, i - 1, s2, j) + 1, DP(s1, i - 1 , s2, j - 1) + 1)这三种情况是根据图中以s2位基础修改s1得来的；如果相等，则DP(s1, i, s2, j) &#x3D; DP(s1, i - 1, s2, j - 1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP(word1, m - <span class="number">1</span>, word2, n - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(String s1, <span class="keyword">int</span> m, String s2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[m][n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(m) == s2.charAt(n))&#123;</span><br><span class="line">            memo[m][n] = DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[m][n] = Math.min(DP(s1, m, s2, n - <span class="number">1</span>) + <span class="number">1</span>, Math.min(DP(s1, m - <span class="number">1</span>, s2, n) + <span class="number">1</span>,DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>明确dp含义</u>：s1[0..i] 和 s2[0..j] 的最⼩编辑距离是 dp[i-1][j-1]  </p>
<p>B，<u>明确初始值</u>：DP[i][0] &#x3D; i ,DP[0][j] &#x3D; j  </p>
<p>C，<u>状态转移方程</u>：如果说i - 1和j - 1处的字符相同，那么DP[i][j] &#x3D; DP[i - 1][j - 1]。如果不同，则也是分三种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] DP = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) DP[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) DP[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    DP[i][j] = DP[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    DP[i][j] = Math.min(DP[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(DP[i][j - <span class="number">1</span>] +<span class="number">1</span>, DP[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>：</p>
<p>A，字符创比较类问题都可以抽象为下面的图，并且可以看到只有三个状态可以降低空间复杂度</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-48.png" alt="sf-2-48" style="zoom:67%;" /> 

<img src="C:\Users\zhao\Desktop\sf-2-49.png" alt="sf-2-49" style="zoom: 80%;" />

<p>B，可以输出路径</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-50.png" alt="sf-2-50" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-51.png" alt="sf-2-51" style="zoom:80%;" />

<h3 id="（5）正则表达式问题"><a href="#（5）正则表达式问题" class="headerlink" title="（5）正则表达式问题"></a>（5）正则表达式问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-52.png" alt="sf-2-52"></p>
<p><strong>思路</strong>：这个匹配的过程要想清楚，我们用两个指针来指向s和p字符串，如果字符串中没有*号的话，那么对于两个指针指向的字符，只要相同或者p中一个 . 我们就认为匹配。比如abbbc和a…c是匹配的</p>
<p>加入了*号后，稍微有点复杂，p中的某个字符是* ,那么p之前的那个字符，到底匹配了几次呢？或者说，它能够消耗s中的字符吗？消耗1次？n次？还是0次？</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-53.png" alt="sf-2-53" style="zoom:67%;" />

<p>所以本题中的状态就是i和j中指针的位置，选择就是p[j]选择匹配几个字符</p>
<p>A，<u>定义的dp函数</u>：bool dp(String s, int i, String p, int j)，该函数返回<code>s[i..]</code>是否可以匹配<code>p[j..]</code>，我们的目标就是找到i和j为0的结果</p>
<p>B，<u>确定初始值</u>：一个 base case 是<code>j == p.size()</code>时，按照<code>dp</code>函数的定义，这意味着模式串<code>p</code>已经被匹配完了，那么应该看看文本串<code>s</code>匹配到哪里了，如果<code>s</code>也恰好被匹配完，则说明匹配成功：另一个比较特殊，下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-54.png" alt="sf-2-54" style="zoom:67%;" />

<p>C，<u>状态转移</u>：其实就是上面的情况中的翻译，先看代码再看解释</p>
<p><strong>TNND做了三四个小时了，受不了了，就是跑不对</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j == p.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>((p.length() - j) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; p.length(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j + <span class="number">1</span>)  != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">            memo[i][j] = Math.max(dp(s, i, p, j + <span class="number">2</span>) ,dp(s, i + <span class="number">1</span>, p, j));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            memo[i][j] = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>妥协了，cv大法好</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-55.png" alt="sf-2-55" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//&quot;&quot; 和p的匹配关系初始化，a*a*a*a*a*这种能够匹配空串，其他的是都是false。</span></span><br><span class="line">        <span class="comment">//  奇数位不管什么字符都是false，偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i+= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> sc = s.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> pc = p.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sc == pc || pc == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j - <span class="number">2</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3，背包问题"><a href="#3，背包问题" class="headerlink" title="3，背包问题"></a>3，背包问题</h2><p>背包问题本质上还是动态规划问题，接下来是一些应用于该问题的标准套路和规则</p>
<p>首先，问题中的状态和选择，状态有两个，就是「背包的容量」和「可选择的物品」。  对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」  </p>
<p>接着，dp数组的含义，由于状态有两个，那么dp数组也是二维的。dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最⼤价值是 dp[i][w]。  如果 dp[3][5] &#x3D; 6，其含义为：对于给定的⼀系列物品中，若只对前 3 个物品进⾏选择，当背包<br>容量为 5 时，最多可以装下的价值为 6。  (base case 就是 dp[0][..] &#x3D; dp[..][0] &#x3D; 0，因为没有物品或者背包没有空间的时候，能装的最⼤价值就是 0 )</p>
<p>最后，就是根据选择来进行状态转移</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-56.png" alt="sf-2-56" style="zoom:67%;" /> 

<p>代码框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] wt, <span class="keyword">int</span>[] val)</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(itn w = <span class="number">1</span>; w &lt;= W; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w - wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//第i个物品的重量是wt[i - 1]，这里发现，放不进去啦，就和前面一样就行</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//第i个物品的价值是val[i - 1],占用的空间是wt[i - 1],所以试着装进去看一下</span></span><br><span class="line">                <span class="comment">//dp[i - 1][w - wt[i - 1]]表示的是，前i - 1个物品，容量预留了w - wt[i - 1]，此时的最大价值，这样才能将i个物品放进去咯</span></span><br><span class="line">                dp[i][w] = Math.max(dp[i - <span class="number">1</span>][w - wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（1）0-1背包问题"><a href="#（1）0-1背包问题" class="headerlink" title="（1）0-1背包问题"></a>（1）0-1背包问题</h3><p>同上</p>
<h3 id="（2）完全背包问题"><a href="#（2）完全背包问题" class="headerlink" title="（2）完全背包问题"></a>（2）完全背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-57.png" alt="sf-2-57" style="zoom: 80%;" /> 

<p><strong>思路</strong>：有⼀个背包，最⼤容量为 amount，有⼀系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量<br>⽆限。请问有多少种⽅法，能够把背包恰好装满  （要装满就是完全背包问题）</p>
<p>A，<u>明确状态和选择</u>：状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」</p>
<p>B，<u>明确dp数组的定义</u>：dp[i][j]表示使用前i个硬币，凑出总额为j的情况，有多少种凑法，这里不同于0-1背包</p>
<p>C，<u>明确初始值</u>：dp[0][..] &#x3D; 0， dp[..][0] &#x3D; 1  </p>
<p>D，<u>状态转移（怎么做选择？）</u>：如果你不把这第 i 个物品装⼊背包，也就是说你不使⽤ coins[i] 这个⾯值的硬币，那么凑出⾯额 j 的⽅法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。  如果你把这第 i 个物品装⼊了背包，也就是说你使⽤ coins[i] 这个⾯值的硬币，那么 dp[i][j] 应该等于dp[i][j-coins[i-1]] <strong>(这里很离谱，似乎是表现了只能放一个coins[i]硬币，但是嗷，很快嗷，很离谱嗷，这里第一个下标是i，根据定义来说，这个下标已经包含了使用coins[i]的其他情况)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - coins[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以压缩状态，进⼀步降低算法的空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> = coins.length;</span><br><span class="line">    <span class="comment">//dp数组表示在使用i个硬币的情况下，j金额需要多少硬币才能凑成</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0表示金额0，不管几枚硬币都是一种情况</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - coins[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//这里的状态转移就是包含了第i个硬币加进来，和没加进来的情况</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）子集背包问题"><a href="#（3）子集背包问题" class="headerlink" title="（3）子集背包问题"></a>（3）子集背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-58.png" alt="sf-2-58" style="zoom:80%;" />

<p><strong>思路</strong>：转化一下，给⼀个可装载重量为 sum &#x2F; 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在⼀种装法，能够恰好将背包装满？  </p>
<p>A，<u>dp[][]数组的定义</u>：dp[i][j] &#x3D; x 表示，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明有一种组合可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满 。如果 dp[4][9] &#x3D; true，其含义为：对于容量为 9 的背包，若只是⽤前 4 个物品，可以有⼀种⽅法把背包恰好装满 （也就是对于sum为9，前4个数字中有一种组合可以得到sum为9）</p>
<p>B，<u>确定初始值</u>：想求的最终答案就是 dp[N][sum&#x2F;2]，base case 就是 dp[..][0] &#x3D; true 和 dp[0][..] &#x3D; false，因为背包没有空间的时候，就相当于装满了，⽽当没有物品可选择的时候，肯定没办法装满背包 。</p>
<p>C，<u>状态转移</u>：如果不把 nums[i] 算⼊⼦集，或者说你不把这第 i 个物品装⼊背包，那么是否能够恰好装满背包，取决于上⼀个状态 dp[i-1][j]，继承之前的结果。如果把 nums[i] 算⼊⼦集，或者说你把这第 i 个物品装⼊了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4，用动态规划解决游戏类问题"><a href="#4，用动态规划解决游戏类问题" class="headerlink" title="4，用动态规划解决游戏类问题"></a>4，用动态规划解决游戏类问题</h2><h3 id="（1）股票买卖类问题"><a href="#（1）股票买卖类问题" class="headerlink" title="（1）股票买卖类问题"></a>（1）股票买卖类问题</h3><p><strong>(力扣118——买卖股票的最佳时机4)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-59.png" alt="sf-2-59"></p>
<p><strong>思路</strong>：首先明确状态和选择，本题中的<strong>选择</strong>有三个：买⼊、卖出、⽆操作，我们⽤ buy, sell, rest 表示这三种选<br>择 ，但是不是每天可以任意选择，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，⼀种是 buy 之后的 rest（持有了股票），⼀种是 sell 之后的rest（没有持有股票）。⽽且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。  <strong>状态</strong>有三个，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨⽤ 1 表示持有，0 表示没有持有）。然后我们⽤⼀个三维数组就可以装下这⼏种状态的全部组合 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n - <span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，⼤ K 为交易数的上限，<span class="number">0</span> 和 <span class="number">1</span> 代表是否持有股票。</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">			<span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">				dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。再⽐如 dp[2][3][0] 的含义：今天是第⼆天，我现在⼿上没有持有股票，⾄今最多进⾏ 3 次交易 。\\\我们的目标是求dp[n - 1][K][0]，即最后⼀天，最多允许 K 次交易，最多获得多少利润 (注意最后为0肯定比最后为1获得的利润多)</p>
<p>B，<u>状态转移</u>：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-60.png" alt="sf-2-60" style="zoom: 33%;" />    

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 sell )</span><br><span class="line"><span class="comment">//解释：今天我没有持有股票，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就没有持有，且截⾄昨天最⼤交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最⼤交易次数限制依然为 k。</span></span><br><span class="line"><span class="comment">//2、我昨天持有股票，且截⾄昨天最⼤交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最⼤交易次数限制依然为 k。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 buy )</span><br><span class="line"><span class="comment">//解释：今天我持有着股票，最⼤交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就持有着股票，且截⾄昨天最⼤交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最⼤交易次数限制依然为 k  </span></span><br><span class="line"><span class="comment">//2、我昨天本没有持有，且截⾄昨天最⼤交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最⼤交易次数限制为 k。(今天我要买股票了，消耗一次交易次数，所以昨天最大次数限制为k-1，今天我才能买股票)</span></span><br></pre></td></tr></table></figure>

<p>C，<u>明确初始值</u>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：还没开始的时候，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：不允许交易的情况下，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值</span></span><br></pre></td></tr></table></figure>

<p>总体上的框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：<span class="comment">//这还有-1，当然实际做题的时候会有应对</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移⽅程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p><strong>（力扣121——买卖股票的最佳时机）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-61.png" alt="sf-2-61"></p>
<p><strong>思路</strong>：根据前面定定义的情况套就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">            = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -price[i])<span class="comment">//这里我们发现dp[i - 1][0][0] = 0</span></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">         = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + -price[i]);</span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> = -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 空间复杂度优化版本</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = prices.length;</span><br><span class="line">		<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">			dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">			dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp_i_0;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣309——股票买卖最佳时机含冷冻期)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-62.png" alt="sf-2-62" style="zoom:80%;" />

<p><strong>思路</strong>：交易次数是无线的；包含冷冻期，在购买股票的时候状态转移的位置要注意</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);<span class="comment">//这里i天购买股票，应该是i-2的参照</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间复杂度优化版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">		dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">		dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">		dp_pre_0 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣714——买卖股票的最佳时机含手续费)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-63.png" alt="sf-2-63" style="zoom:80%;" />

<p><strong>思路</strong>：k还是无限的，每次买的把手续费减了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i] - fee;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣123——买卖股票的最佳时机交易次数为2）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-64.png" alt="sf-2-64" style="zoom:80%;" />

<p><strong>思路</strong>：这里注意，根据框架来说，这里的k初始值为2，我们在进行状态选择的时候，要将k加进去遍历，k的初试值为2，最小值为1，是递减的情况，和i是反着来的，这是一种符合语义的方式（递增也可以得到正确答案），因为递减表示交易的机会在减少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣188——买卖股票的最佳时机4）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-65.png" alt="sf-2-65" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>如果直接是将上一题的2换成输入的值，是通不过不了的哦，因为测试用例k会故意给你一个很大的值，这样new数组的时候就超出内存限制了。</p>
<p>但是我们可以发现，如果k的值超过了n&#x2F;2，那就是交易次数没有限制的情况啦。</p>
<p>反之就是要限制的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_inf(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_k(prices, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_k</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = max;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算k为0的时候的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）打家劫舍类问题"><a href="#（2）打家劫舍类问题" class="headerlink" title="（2）打家劫舍类问题"></a>（2）打家劫舍类问题</h3><p><strong>（力扣198——打家劫舍）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-66.png" alt="sf-2-66" style="zoom:80%;" />

<p><strong>思路</strong>：明确状态和选择，对于一排房子，<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p>
<p>A，<u>明确dp函数的含义</u>：dp(int[] nums, int start)，表示从start位置抢，能获得的最大值</p>
<p>B，<u>明确初始值</u>：这里就是函数中的base case，当start为nums的长度的时候，dp函数应该返回0</p>
<p>C，<u>状态转移过程</u>：对于一个房子nums[i]，可以选择不抢（不抢就光顾下一家nums[i + 1]），也可以选择抢（那下一家就只能是nums[i + 2]，因为要隔着抢），从这两个里面选最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>), nums[start] + dp(nums, start + <span class="number">2</span>));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//1，dp[i]表示抢劫第i家房屋的时候，最大收益</span></span><br><span class="line">        <span class="comment">//2,base case就是抢劫第n + 1家房屋的时候，收益是0，没得抢了已经</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//3，对于第i个房屋的最大收益，取决于前一个状况的收益，和目前抢了这家，前两个情况的收益</span></span><br><span class="line">            dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣213——打家劫舍2）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-67.png" alt="sf-2-67"></p>
<p><strong>思路</strong>：这里再多加一个判断就行了，因为收尾两个位置不能同时选，所以演化出了下面的三种情况，也就是数组的长度被限制住了。这里显然，情况2和情况3比情况1要更好。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-68.png" alt="sf-2-68" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = dp(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res2 = dp(nums, <span class="number">1</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>, end), nums[start] + dp(nums, start + <span class="number">2</span>, end));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>), robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣337——打家劫舍3）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-69.png" alt="sf-2-69" style="zoom:67%;" />

<p><strong>思路</strong>：父节点处的值，应该和两个子节点有关，也就是在状态转移的时候，应该看当前节点的左右子节点的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> do_it = root.val  + </span><br><span class="line">            (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">            + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="keyword">int</span> not_do = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="keyword">int</span> res = Math.max(do_it, not_do);</span><br><span class="line"></span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）博弈问题"><a href="#（3）博弈问题" class="headerlink" title="（3）博弈问题"></a>（3）博弈问题</h3><p><strong>（力扣877——石子游戏）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-70.png" alt="sf-2-70"></p>
<p><strong>思路</strong>：先手必胜，因为可以控制自己选基数堆还是偶数堆，这里我们尝试用动态规划来解决</p>
<p>A，<u>定义DP数组</u></p>
<p>dp[i][j].fir &#x3D; x 表示，对于 piles[i…j] 这部分⽯头堆，先⼿能获得的最⾼分数为 x。<br>       dp[i][j].sec &#x3D; y 表示，对于 piles[i…j] 这部分⽯头堆，后⼿能获得的最⾼分数为 y。  </p>
<p>举例理解⼀下，假设 piles &#x3D; [2, 8, 3, 5]，索引从 0 开始，那么：<br>        dp[0][1].fir &#x3D; 8 意味着：⾯对⽯头堆 [2, 8]，先⼿最多能够获得 8 分；dp[1][3].sec &#x3D; 5 意味着：⾯对⽯头堆 [8, 3, 5]，后⼿最多能够获得 5 分。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-71.png" alt="sf-2-71" style="zoom:50%;" />

<p>我们想求的答案是先⼿和后⼿最终分数之差，按照这个定义也就是 dp[0][n-1].fir - dp[0][n- 1].sec，即⾯对整个 piles，先⼿的最优得分和后⼿的最优得分之差。  </p>
<p>B,<u>明确初试值</u></p>
<p>就是对角线的值，dp[i][i].fir &#x3D; piles[i],  dp[i][i].sec&#x3D; 0。因为只有一堆的时候，当然是先手大</p>
<p>C，<u>状态转移</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，状态：状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的⼈。</span></span><br><span class="line">dp[i][j][fir or sec]</span><br><span class="line">其中：</span><br><span class="line"><span class="number">0</span> &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，选择：选择有两个：选择最左边的那堆⽯头，或者选择最右边的那堆⽯头</span></span><br><span class="line">n = piles.length</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">	<span class="keyword">for</span> j &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> who in &#123;fir, sec&#125;:</span><br><span class="line">			dp[i][j][who] = max(left, right)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，状态转移方程</span></span><br><span class="line">dp[i][j].fir = max(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j-<span class="number">1</span>].sec)</span><br><span class="line">dp[i][j].fir = max( 选择最左边的⽯头堆 , 选择最右边的⽯头堆 )</span><br><span class="line"># 解释：我作为先⼿，⾯对 piles[i...j] 时，有两种选择：</span><br><span class="line"># 要么我选择最左边的那⼀堆⽯头，然后⾯对 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿；</span><br><span class="line"># 要么我选择最右边的那⼀堆⽯头，然后⾯对 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿。</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">if</span> 先⼿选择左边:</span><br><span class="line">dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir</span><br><span class="line"><span class="keyword">if</span> 先⼿选择右边:</span><br><span class="line">dp[i][j].sec = dp[i][j-<span class="number">1</span>].fir</span><br><span class="line"># 解释：我作为后⼿，要等先⼿先选择，有两种情况：</span><br><span class="line"># 如果先⼿选择了最左边那堆，给我剩下了 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 此时轮到我，我变成了先⼿；</span><br><span class="line"># 如果先⼿选择了最右边那堆，给我剩下了 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 此时轮到我，我变成了先⼿。</span><br><span class="line"></span><br><span class="line"><span class="comment">//4，base case</span></span><br><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-72.png" alt="sf-2-72" style="zoom:67%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.length;</span><br><span class="line">        Pair[][] dp = <span class="keyword">new</span> Pair[n][n];</span><br><span class="line">        <span class="comment">//1,先进行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,设置base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">            dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历的顺序是根据上图来的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = piles[i] + dp[i + <span class="number">1</span>][j].sec;</span><br><span class="line">                <span class="keyword">int</span> right = piles[j] + dp[i][j - <span class="number">1</span>].sec;</span><br><span class="line">                <span class="comment">//4,fir先进行选择，选完之后sec的状态也随之修改</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i + <span class="number">1</span>][j].fir;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j - <span class="number">1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Pair res = dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res.fir - res.sec &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个类中存放了先手和后手的最大值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fir, sec;</span><br><span class="line">    Pair(<span class="keyword">int</span> fir, <span class="keyword">int</span> sec) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fir = fir;</span><br><span class="line">        <span class="keyword">this</span>.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）最小路径和"><a href="#（4）最小路径和" class="headerlink" title="（4）最小路径和"></a>（4）最小路径和</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-73.png" alt="sf-2-73" style="zoom:67%;" />

<p><strong>思路</strong>：</p>
<p>A，<u>定义dp函数</u>：dp(int[][] grid, int i, int j)表示从(0, 0)到(i, j)需要的最小路径值</p>
<p>B，<u>明确初始值</u>：起点本身到自己的值就是0</p>
<p>C，<u>状态转移</u>：由于只能向右或向下，grid[i][j]取决于dp(grid,  i - 1,j)和dp(grid, i , int j - 1)中的小的那个加上自己</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(grid, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">        memo[i][j] = Math.min(dp(grid, i - <span class="number">1</span>, j), dp(grid, i, j -<span class="number">1</span>)) + grid[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.length;</span><br><span class="line">	<span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">	<span class="comment">/**** base case ****/</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">	<span class="comment">/*******************/</span></span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）高楼扔鸡蛋"><a href="#（5）高楼扔鸡蛋" class="headerlink" title="（5）高楼扔鸡蛋"></a>（5）高楼扔鸡蛋</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-74.png" alt="sf-2-74"></p>
<p><strong>思路</strong>：状态就是当前拥有的鸡蛋数量和需要测试的楼层N，选择就是选择那层去扔鸡蛋</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少实验的次数</span></span><br><span class="line">        <span class="comment">// 注意：</span></span><br><span class="line">        <span class="comment">// 1、i 表示的是楼层的大小，不是第几层的意思，例如楼层区间 [8, 9, 10] 的大小为 3，这一点是在状态转移的过程中调整的定义</span></span><br><span class="line">        <span class="comment">// 2、j 表示可以使用的鸡蛋的个数，它是约束条件，我个人习惯放在后面的维度，表示消除后效性的意思</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 个楼层和 0 个鸡蛋的情况都需要算上去，虽然没有实际的意义，但是作为递推的起点，被其它状态值所参考</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于求的是最小值，因此初始化的时候赋值为一个较大的数，9999 或者 i 都可以</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：填写下标为 0、1 的行和下标为 0、1 的列</span></span><br><span class="line">        <span class="comment">// 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="comment">// 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度（想想复杂度的定义）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 行，第 2 列开始填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1</span></span><br><span class="line">                    <span class="comment">// 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少</span></span><br><span class="line">                    <span class="comment">// 两种情况都做了一次尝试，所以加 1</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（6）魔塔"><a href="#（6）魔塔" class="headerlink" title="（6）魔塔"></a>（6）魔塔</h3><p>困难</p>
<h3 id="（7）辐射"><a href="#（7）辐射" class="headerlink" title="（7）辐射"></a>（7）辐射</h3><p>困难</p>
<h3 id="（8）加权最短路径"><a href="#（8）加权最短路径" class="headerlink" title="（8）加权最短路径"></a>（8）加权最短路径</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-75.png" alt="sf-2-75"></p>
<p><strong>思路</strong>：对于无权图，可以用BFS来获得最短路径；有权图，可以用Dijkstra来获取最短路径，这里用动态规划</p>
<p>A，<u>定义dp函数</u>：int dp(int s, int k)，这个函数指的是，从起点src出发，k步之内到节点s的最小花费</p>
<p>B，<u>明确base case</u>：如果s &#x3D;&#x3D; src，那么返回0；如果k &#x3D;&#x3D; 0，那么就无解啦，返回-1</p>
<p>C，<u>状态转移</u>：对于重点o，我只需要知道和它相连的节点和权重a（weight 1），b（weight 2）……，这样就可以算出到o的最小花费,，算法是min(dp(a, k - 1) + weight1,  dp(b, k - 1) + weight2)，这里注意需要是k - 1步，留一步到o</p>
<p>注：这样进行状态转移，我们就得知道指向某个节点的全部节点，以及权重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,用来存储到某个节点的入度</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; indegree;</span><br><span class="line">    <span class="keyword">int</span> src,dst;</span><br><span class="line">    <span class="keyword">int</span> memo[][];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        indegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.dst = dst;</span><br><span class="line">        <span class="comment">//k表示节点数，步数应该+1</span></span><br><span class="line">        k++;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">888</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] flight : flights)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = flight[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> from = flight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> cost = flight[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//保存某个节点的入度</span></span><br><span class="line">            indegree.putIfAbsent(to, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            indegree.get(to).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;from, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(dst, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(s == src) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[s][k] != -<span class="number">888</span>) <span class="keyword">return</span> memo[s][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(indegree.containsKey(s))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] v : indegree.get(s))&#123;</span><br><span class="line">                <span class="keyword">int</span> from = v[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> cost = v[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//看看相邻的节点的花费怎么样</span></span><br><span class="line">                <span class="keyword">int</span> subProblem = dp(from, k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(subProblem != -<span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.min(res, subProblem + cost);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">            memo[s][k] = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[s][k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[s][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七，其他经典算法"><a href="#七，其他经典算法" class="headerlink" title="七，其他经典算法"></a>七，其他经典算法</h1><h2 id="1，数学算法"><a href="#1，数学算法" class="headerlink" title="1，数学算法"></a>1，数学算法</h2><h3 id="（1）如何高效寻找素数"><a href="#（1）如何高效寻找素数" class="headerlink" title="（1）如何高效寻找素数"></a>（1）如何高效寻找素数</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-76.png" alt="sf-2-76" style="zoom: 80%;" />

<p><strong>思路</strong>：普通做法当然是遍历啦，判断范围内每个数到底是不是素数。再进阶一点就是对于每个数，判断2~sqrt（这个数）这个范围就行。但是还不够高效</p>
<p>A，<u>反着来</u>：从2开始，我们知道2是素数，那么2的倍数肯定不是素数；3是素数，3的倍数肯定不是素数。这个方法也叫筛选法。</p>
<p>那么对于一个范围内的数，可以先假设都是素数，然后把它们的倍数都设置为非素数，漏下来的就都是素数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1,这里只需要遍历到sqrt(n)就行了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//避免重复标记</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; n; j += i)&#123;</span><br><span class="line">                    isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）两道常考的阶乘算法题"><a href="#（2）两道常考的阶乘算法题" class="headerlink" title="（2）两道常考的阶乘算法题"></a>（2）两道常考的阶乘算法题</h3><p><strong>（力扣172——阶乘后的零）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-77.png" alt="sf-2-77"></p>
<p><strong>思路</strong>：第一种思路就是统计每个数中5的个数，但是要遍历一遍；第二种思路就是统计特殊值的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span>(temp % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp = temp / <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣793——阶乘后k个零）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-78.png" alt="sf-2-78" style="zoom: 80%;" />

<p><strong>思路</strong>：转换一下，就是求有多少个x 满⾜ trailingZeroes(x) &#x3D;&#x3D; k，那么我们可以求满⾜条件的 x 最⼩是多少，最⼤是多少，最⼤值和最⼩值⼀减就是满足的个数。</p>
<p>上面就是一个二分法的思路，下边界是0（也就是0个满足），上边界呢？题目中给出的限制是x &lt;&#x3D; 10^9,Integer.MAX_VALUE不够，我们用Long.MAX_VALUE</p>
<p>所以，最后的问题就是在区间 [0, LONG_MAX] 中寻找满⾜ trailingZeroes(n) &#x3D;&#x3D; K 的左侧边界和右侧边界  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没通过，后面复习了二分查找可以再看看</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (<span class="keyword">int</span>)(rightBound(k) - leftBound(k) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= Long.MAX_VALUE || trailingZeroes(lo) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt; <span class="number">0</span> || trailingZeroes(hi) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（3）如何在无限序列中随机抽取元素"><a href="#（3）如何在无限序列中随机抽取元素" class="headerlink" title="（3）如何在无限序列中随机抽取元素"></a>（3）如何在无限序列中随机抽取元素</h3><p>如果让你只能遍历对象（特备是链表这种）一遍，并且同等概率的取出其中的一个或者k个元素，应该怎么办？</p>
<p>先说一个元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回链表的一个随机节点，核心是：当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//这里在遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//生成一个[0,i)之间的随机整数，这个整数等于0的概率就是1/i,从而判断是否更新这个值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-79.png" alt="sf-2-79"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回链表的K个随机节点，核心是：当如果要随机选择 k 个数，只要在第 i 个元素处以 k/i 的概率选择该元素，以 1 - k/i 的概率保持原有选择即可（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前k个元素默认选上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; p != <span class="keyword">null</span>; j++)&#123;</span><br><span class="line">        res[j] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//第一次生成一个[0,i)之间的整数</span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i);</span><br><span class="line">        <span class="comment">//这个整数⼩于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k)&#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-80.png" alt="sf-2-80"></p>
<p><strong>（力扣382——链表随机节点）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-81.png" alt="sf-2-81" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random r;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r = <span class="keyword">new</span> Random();</span><br><span class="line">        ListNode p = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">                res = p.val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣398——随机数索引）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-82.png" alt="sf-2-82" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里的k要从0开始，不然从1开始会出错，我也不知道为啥出错</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(k))&#123;</span><br><span class="line">                    res = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣528——权重随机选择）</strong></p>
<h3 id="（4）吃葡萄"><a href="#（4）吃葡萄" class="headerlink" title="（4）吃葡萄"></a>（4）吃葡萄</h3><p><strong><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada">（牛客——吃葡萄）</a></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-83.png" alt="sf-2-83" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>吃的最多的人要吃的最少—&gt;也就是尽量要平分这些葡萄。假设没有吃的种类的限制，那么（总数&#x2F;3）向上去整就能得到想要的结果。（<u>注：如果你想计算 M 除以 N，M &#x2F; N 会向下取整，你想向上取整的话，可以改成 (M+(N-1)) &#x2F; N</u>  ）</p>
<p>但是因为有了条件限制，那么三种葡萄构成了三条边a,b,c，这三条边可以对应三角形的组成的两种情况：</p>
<p>第一种：a + b &gt; c，此时可以组成三角形（&#x3D;的情况虽然不是三角形，但也是平均分最合理），此时可以通过(a + b + c + 2) &#x2F; 3来获取平均分配后的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-84.png" alt="sf-2-84" style="zoom:67%;" />

<p>第二种：a + b &lt;&#x3D; c &amp;&amp; c &lt;&#x3D;  2*(a+b) </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-86.png" alt="sf-2-86"></p>
<p>第二种：c &gt; 2*(a+b)  ，此时不能是三角形，尽量要平分的话，就是一个人吃完a + b两种葡萄，剩下两人平分c</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-85.png" alt="sf-2-85" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        <span class="keyword">long</span>[][] purples = <span class="keyword">new</span> <span class="keyword">long</span>[k][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            purples[i][<span class="number">0</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">1</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">2</span>] = sc.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            System.out.println(solution(purples[i]));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span>[] nums)</span></span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">long</span> sum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] &gt;= nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + <span class="number">2</span>) / <span class="number">3</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*(nums[<span class="number">0</span>] + nums[<span class="number">1</span>]) &lt; nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">2</span>] + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）同时寻找缺失和重复的元素"><a href="#（5）同时寻找缺失和重复的元素" class="headerlink" title="（5）同时寻找缺失和重复的元素"></a>（5）同时寻找缺失和重复的元素</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-87.png" alt="sf-2-87" style="zoom: 80%;" />

<p><strong>思路</strong>：对于遍历的一个数值，我们将对应的下标元素变为负数，如果遍历到的数值对应下标的值已经是负数，那么这个值就是重复的，下标就是缺失的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1，遍历数组，将遍历到的值对应下标的值变为负数，表示这个索引有对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> dup = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lost = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，在循环中把数字对应下标的值标记为负数，此时若发现对应下标已经被标记过，则这个数重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[a - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                dup = a;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[a - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历数据，如果发现还有没有标记的数，则对应下标就是确实的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                lost = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dup, lost&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2，面试必知必会"><a href="#2，面试必知必会" class="headerlink" title="2，面试必知必会"></a>2，面试必知必会</h2><h3 id="（1）nSum问题"><a href="#（1）nSum问题" class="headerlink" title="（1）nSum问题"></a>（1）nSum问题</h3><p><strong>（两数之和）</strong></p>
<p><strong>引入</strong>：就是一个数组中的两个元素的和是不是等于特定值，可以用哈希表的方式来解决；或者将数组排序使用双指针</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-89.png" alt="sf-2-89" style="zoom:80%;" />

<p><strong>思路</strong>：我们排序后使用双指针，由于有重复,那么当指针当前指向的两个元素能够组成目标值时，两个指针应该跳过所有相同的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] toRes = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] temp : res)&#123;</span><br><span class="line">        toRes[i] = temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣15——三数之和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-90.png" alt="sf-2-90" style="zoom:80%;" />

<p><strong>思路</strong>：同样还是对数组进行排序，然后遍历数组，对于某个位置上的数x，假设它在结果中，那我们就需要找两个数，满足target - x，问题得以转化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; towSum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            towSum = twoSumTarget(nums, i + <span class="number">1</span>, <span class="number">0</span> -(nums[i]));</span><br><span class="line">            <span class="keyword">if</span>(towSum.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt;  two : towSum)&#123;</span><br><span class="line">                    two.add(nums[i]);</span><br><span class="line">                    res.add(two);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(left);</span><br><span class="line">                list.add(right);</span><br><span class="line">                res.add(list);</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣18——四数之和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-91.png" alt="sf-2-91"></p>
<p><strong>思路</strong>：到这里应该直接写一个nsum的通用算法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nSumTarget(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1,输入数组，求几个数的和，开始坐标，以及目标值</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; nSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,这是一个base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，2个数其实也是一个base case算法</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lo = start, hi = sz - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">                <span class="keyword">int</span> left = nums[lo],right = nums[hi];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(left);</span><br><span class="line">                    list.add(right);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//这里递归计算n - 1个数的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; sz; i++)&#123;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; temp_res = nSumTarget(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">                <span class="comment">//如果temp_res不为空，这里能加入进去</span></span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; temp : temp_res)&#123;</span><br><span class="line">                    temp.add(nums[i]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）区间问题"><a href="#（2）区间问题" class="headerlink" title="（2）区间问题"></a>（2）区间问题</h3><p>（力扣1288——删除被覆盖的区间）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-92.png" alt="sf-2-92"></p>
<p><strong>思路</strong>：对于这些区间，我们先排序，按照起点升序排序，终点降序排序（这样能确保起点相同的区间，是长的那个在上面）；排序结束后，便可遍历，会有三种情况，对于每种情况进行不同的处理。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-93.png" alt="sf-2-93" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这里按照起点升序，起点相同时终点降序排列。</span></span><br><span class="line">        Arrays.sort(intervals, (a, b)-&gt;&#123;<span class="comment">//返回值大于0，就是a大，返回值小于0，就是b大。sort默认从小到大排序</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,设置第一个值为起点</span></span><br><span class="line">        <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，开始遍历判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="comment">//第一种情况，包含第二个区间</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= left &amp;&amp; intervals[i][<span class="number">1</span>] &lt;= right)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二种情况，两个区间部分相交，需要扩大右边界</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= right)&#123;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三种情况，完全不相交</span></span><br><span class="line">            <span class="keyword">if</span>(right &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（）还有两道题，后面再来写</p>
<h3 id="（3）快速选择算法"><a href="#（3）快速选择算法" class="headerlink" title="（3）快速选择算法"></a>（3）快速选择算法</h3><p><strong>（力扣215——数组中第K个最大的元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-94.png" alt="sf-2-94"></p>
<p><strong>思路</strong>：两种方法，一个是二叉堆，一个是快速选择算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1），使用二叉堆的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,使用优先级队列，这里默认是小根堆，如果是大根堆，还需要处理一下</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于每个元素，先加进去，如果此时pq大小超过k，则要去除堆顶元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，剩下的就是我们要的第k大的元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2），使用快速选择算法，它的时间复杂度更低，是快速排序的简化版（参考3）</span></span><br><span class="line"><span class="comment">//:我们要找第K大的元素，partition 函数会返回p，那么我们可以把 p 和 k 进⾏⽐较，如果 p &lt; k 说明第 k ⼤的元素在 nums[p+1..hi] 中，如果 p &gt; k 说明第 k ⼤的元素在 nums[lo..p-1] 中。</span></span><br><span class="line"><span class="comment">//:题⽬要求的是「第 k 个最⼤元素」，这个元素其实就是 nums 升序排序后「索引」为 len(nums) - k 的这个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="comment">//这个p就是一个数字最终的位置</span></span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(p &lt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[p + 1] ~ nums[hi]之间</span></span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p &gt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[lo] ~ nums[p - 1]之间</span></span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）快速排序回顾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo , <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点索引 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line">	<span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo == hi) <span class="keyword">return</span> lo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1，将lo位置的元素作为基准比较元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里j要+1，因为后面要先自减</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//找一个比pivot大的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[++i] &lt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找一个比pivot小的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[--j] &gt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果走到这里，说明这两个元素需要换位置，确保lo~i的范围比pivot小，lo~j的范围比pivot大</span></span><br><span class="line">        swap(nums, i, j); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将pivot放到中间那个划分的位置</span></span><br><span class="line">    swap(nums, j , lo);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）分治法"><a href="#（4）分治法" class="headerlink" title="（4）分治法"></a>（4）分治法</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-95.png" alt="sf-2-95" style="zoom:67%;" />

<p><strong>思路</strong>：对于一个复杂问题的，但是可以划分为子问题（分），最后右子问题获取到总的结果（治），我们可以尝试使用分治法，这是递归的一个思想，对于本题我们可以从下面的思路中进行思考：</p>
<p>A，对于一个expression，我们可以获得一个运算符，并把它分为运算符左边的字符串和右边的字符串。</p>
<p>B，分别计算左边和右边字符串的结果，可能会返回很多值（前两步就是分）</p>
<p>C，那么A中这个运算符的结果就是由B中返回的值组合而成（治）</p>
<p>D，需要考虑Base Case</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; rigth = diffWaysToCompute(expression.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b : rigth)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a + b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a - b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a * b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Integer.parseInt(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="（5）扫描线（安排会议室）"><a href="#（5）扫描线（安排会议室）" class="headerlink" title="（5）扫描线（安排会议室）"></a>（5）扫描线（安排会议室）</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-96.png" alt="sf-2-96" style="zoom: 67%;" />

<p><strong>思路</strong>：如下图，将会议区间投影到时间线上，用一个蓝色的线去进行扫描，如果遇到红色的点，则计数+1，遇到蓝色的点，则计数-1，进而count的最大值就是我们要的到的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-97.png" alt="sf-2-97" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetignRooms</span><span class="params">(<span class="keyword">int</span>[][] meetings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = meetings.length;</span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//1,这里用start来保存起点，end来保存重点，并排序，模拟出上图中的点的排序情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        start[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(start);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里我们开始模拟扫描，过程中我们去记录当前重叠的会议，并将最大的情况赋给res</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i] &lt; end[j])&#123;</span><br><span class="line">            <span class="comment">//同一时间又有一个会议，所以count++</span></span><br><span class="line">            conut++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//同一时间有个会议结束了，count--</span></span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）贪心算法1"><a href="#（6）贪心算法1" class="headerlink" title="（6）贪心算法1"></a>（6）贪心算法1</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-98.png" alt="sf-2-98" style="zoom: 67%;" />

<p><strong>思路</strong>：两种算法，第一种是根据数据分析的做法（数学做法）；第二种是贪心思想</p>
<p>第一种：数据分析</p>
<p>这里有两个数组，我们可以将其归并为一个数组（油箱结余），然后画出变化图，我们发现，要找的起点是最低点（当然如果从最低点开始油箱中都会出现负数，那就是不行）</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-99.png" alt="sf-2-99" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,min记录此时的邮箱结余最小值，start记录起点，sum记录油量和花费的总差值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2，遍历数组，更新上面的这些值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; min)&#123;</span><br><span class="line">                min = sum;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,注意这里是环形数组</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start == gas.length ? <span class="number">0</span> : start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：如果从i到j恰好出现了油箱中的油为负数的情况，那么i ~ j中间的节点k都不会是起点。因为此时i ~ j-1油箱中的油肯定都是正数，j-1 ~ j的消耗太大。所以如果在遍历的过程中，sum值变为负数，那么就将起点设置为j</p>
<p>贪心的关键在于，如果找不到重复计算，那就通过问题中⼀些隐藏较深的规律，来减少冗余计算  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, n = gas.length;</span><br><span class="line">        <span class="comment">//1,先把不好弄的情况给排除了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2,开始贪心，注意这里start取新的起点应该是i + 1</span></span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>,start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start == n ? <span class="number">0</span> : start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）贪心算法2"><a href="#（7）贪心算法2" class="headerlink" title="（7）贪心算法2"></a>（7）贪心算法2</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-100.png" alt="sf-2-100"></p>
<p><strong>思路</strong>：这里和之前的区间问题类似，先将区间排序，然后采用下面的策略</p>
<p> 1、要⽤若⼲短视频凑出完成视频 [0, T]，⾄少得有⼀个短视频的起点是 0。<br>        2、如果有⼏个短视频的起点都相同，那么⼀定应该选择那个最⻓（终点最⼤）的视频。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(clips,(a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clips[<span class="number">0</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, curEnd = <span class="number">0</span>, nextEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">                nextEnd = Math.max(nextEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">            <span class="keyword">if</span>(curEnd &gt;= time)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>（8）</p>

      
    </div>
    
    
    
	
	


    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/xxx/" rel="tag"><i class="fa fa-tag"></i> xxx</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/02/06/js-2-springmvc/" rel="next" title="js-3-springmvc">
                <i class="fa fa-chevron-left"></i> js-3-springmvc
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/03/29/%E4%B8%8D%E5%81%9A%E4%BA%86/xm-3-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/" rel="prev" title="xm-3-项目基本功能">
                xm-3-项目基本功能 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/photo.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                 
					<a href="/tags/index.html">
					 
					<span class="site-state-item-count">4</span>
					<span class="site-state-item-name">标签</span>
				</a>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhao-xxxx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:17302550892@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          
		  
		  
		  
		    <div class="links-of-blogroll motion-element links-of-blogroll-block">
			  <div class="links-of-blogroll-title">
			    <!-- modify icon to fire by szw -->
			    <i class="fa fa-history fa-" aria-hidden="true"></i>
			    近期文章
			  </div>
			  <ul class="links-of-blogroll-list">
			    
			    
				  <li class="recent_posts_li">
				    <a href="/2022/04/25/js-3-mybatis/" title="js-3-mybatis" target="_blank">js-3-mybatis</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/2022/04/25/jc-6-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="jc-6-数据结构" target="_blank">jc-6-数据结构</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/2022/04/25/jc-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="jc-5-操作系统" target="_blank">jc-5-操作系统</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/2022/04/25/jc-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="jc-4-计算机网络" target="_blank">jc-4-计算机网络</a>
				  </li>
			    
				  <li class="recent_posts_li">
				    <a href="/2022/04/25/js-7-linux/" title="js-6-linux" target="_blank">js-6-linux</a>
				  </li>
			    
			  </ul>
		    </div>
		  

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%EF%BC%8C%E5%88%B7%E9%A2%98%E6%80%9D%E7%BB%B4"><span class="nav-number">1.</span> <span class="nav-text">一，刷题思维</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">1，数据结构的存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E2%BD%85%E5%BC%8F%E5%8F%AA%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A%E6%95%B0%E7%BB%84%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89%E5%92%8C%E9%93%BE%E8%A1%A8%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8-%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">（2）数组和链表的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">2，数据结构的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%88%E6%9E%81%E7%9B%AE%E7%9A%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">（1）数据结构的终极目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">（2）操作的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97"><span class="nav-number">1.3.</span> <span class="nav-text">3,算法刷题指南</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.</span> <span class="nav-text">二，计算机算法的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E6%A0%B8%E5%BF%83"><span class="nav-number">2.1.</span> <span class="nav-text">1，核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%BE%E7%82%B9%E5%9C%A8%E3%80%8C%E5%A6%82%E4%BD%95%E7%A9%B7%E4%B8%BE%E3%80%8D%E5%91%A2%EF%BC%9F%E2%BC%80%E8%88%AC%E6%98%AF%E9%80%92%E5%BD%92%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%80%E5%85%B8%E5%9E%8B%E7%9A%84%E5%B0%B1%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-number">2.1.1.</span> <span class="nav-text">（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95%E7%9A%84%E9%9A%BE%E7%82%B9%E5%9C%A8%E3%80%8C%E5%A6%82%E4%BD%95%E8%81%AA%E6%98%8E%E5%9C%B0%E7%A9%B7%E4%B8%BE%E3%80%8D%E5%91%A2%EF%BC%9F%E2%BC%80%E4%BA%9B%E2%BD%BF%E7%86%9F%E8%83%BD%E8%AF%A6%E7%9A%84%E2%BE%AE%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BD%92%E5%9C%A8%E8%BF%99%E2%BC%80%E7%B1%BB%E3%80%82"><span class="nav-number">2.1.2.</span> <span class="nav-text">（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%EF%BC%8C%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">三，基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E6%95%B0%E7%BB%84-x2F-%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">1，数组&#x2F;链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">（1）前缀和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.2.</span> <span class="nav-text">（2）差分数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.1.3.</span> <span class="nav-text">（3）滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6"><span class="nav-number">3.1.4.</span> <span class="nav-text">（4）二分搜索框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%A2%98%E5%9E%8B"><span class="nav-number">3.1.5.</span> <span class="nav-text">（5）二分搜索题型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C"><span class="nav-number">3.1.6.</span> <span class="nav-text">（6）优势洗牌</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84"><span class="nav-number">3.1.7.</span> <span class="nav-text">（7）原地修改数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="nav-number">3.1.8.</span> <span class="nav-text">（8）单链表解题技巧总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89%E9%80%92%E5%BD%92%E6%93%8D%E4%BD%9C%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.9.</span> <span class="nav-text">（9）递归操作链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%EF%BC%8C%E9%98%9F%E5%88%97-x2F-%E6%A0%88%EF%BC%88%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E5%95%A5%E5%B0%B1%E8%B7%B3%E5%88%B03%E4%BA%86%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">3，队列&#x2F;栈（不知道为啥就跳到3了）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">3.2.1.</span> <span class="nav-text">（1）队列实现栈，以及栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">（2）括号匹配问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">3.2.3.</span> <span class="nav-text">（3）单调栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.2.4.</span> <span class="nav-text">（4）单调队列解决滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-number">3.2.5.</span> <span class="nav-text">（5）数组去重</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.3.</span> <span class="nav-text">4，数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">（1）实现LRU算法（最近最少使用算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AE%9E%E7%8E%B0LFU%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">3.3.2.</span> <span class="nav-text">（2）实现LFU算法（最不经常使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%9F%A5%E6%89%BE-x2F-%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0"><span class="nav-number">3.3.3.</span> <span class="nav-text">（3）常数时间查找&#x2F;删除数组中任意元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">3.3.4.</span> <span class="nav-text">（4）中位数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%EF%BC%8C%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">四，进阶数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">1，二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%941"><span class="nav-number">4.1.1.</span> <span class="nav-text">（1）二叉树——1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%942"><span class="nav-number">4.1.2.</span> <span class="nav-text">（2）二叉树——2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%943"><span class="nav-number">4.1.3.</span> <span class="nav-text">（3）二叉树——3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A4%9A%E7%A7%8D%E6%A1%86%E6%9E%B6"><span class="nav-number">4.1.4.</span> <span class="nav-text">（4）二叉树序列化，多种框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">4.1.5.</span> <span class="nav-text">（5）后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.6.</span> <span class="nav-text">（6）总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">4.2.</span> <span class="nav-text">2，二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%941"><span class="nav-number">4.2.1.</span> <span class="nav-text">（1）二叉搜索树——1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%942-%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%90%9C%E7%B4%A2%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4"><span class="nav-number">4.2.2.</span> <span class="nav-text">（2）二叉搜索树——2   (检查，搜索，插入，删除)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%80%94%E2%80%943"><span class="nav-number">4.2.3.</span> <span class="nav-text">（3）二叉搜索树——3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%EF%BC%8C%E5%9B%BE%E8%AE%BA"><span class="nav-number">4.3.</span> <span class="nav-text">3，图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">4.3.1.</span> <span class="nav-text">（1）图论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">（2）拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A"><span class="nav-number">4.3.3.</span> <span class="nav-text">（3）二分图判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.3.4.</span> <span class="nav-text">（4）并查集算法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Kruskal%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.5.</span> <span class="nav-text">（5）Kruskal最小生成树算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89Dijistra%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.6.</span> <span class="nav-text">（6）Dijistra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E5%90%8D%E6%B5%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.7.</span> <span class="nav-text">（7）名流问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%EF%BC%8C%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">五，暴力搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8CDFS%E7%AE%97%E6%B3%95-x2F-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">1，DFS算法&#x2F;回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">5.1.1.</span> <span class="nav-text">（1）回溯算法框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.2.</span> <span class="nav-text">（2）集合划分问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8E%92%E5%88%97-x2F-%E7%BB%84%E5%90%88-x2F-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.3.</span> <span class="nav-text">（3）排列&#x2F;组合&#x2F;子集问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.4.</span> <span class="nav-text">（4）岛屿问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8CBFS%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">2，BFS算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">5.2.1.</span> <span class="nav-text">（1）BFS算法框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89BFS%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="nav-number">5.2.2.</span> <span class="nav-text">（2）BFS解决智力题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">六，动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.</span> <span class="nav-text">1，动态规划核心原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6"><span class="nav-number">6.1.1.</span> <span class="nav-text">（1）动态规划解题核心框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89base-case%E5%92%8C%E5%A4%87%E5%BF%98%E5%BD%95%E7%9A%84%E5%88%9D%E8%AF%95%E5%80%BC%E6%80%8E%E4%B9%88%E5%AE%9A"><span class="nav-number">6.1.2.</span> <span class="nav-text">（2）base case和备忘录的初试值怎么定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E5%92%8Cdp%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91%E6%80%8E%E4%B9%88%E5%AE%9A"><span class="nav-number">6.1.3.</span> <span class="nav-text">（3）最优子结构和dp数组的遍历方向怎么定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%8F%90%E9%AB%98%E5%88%B7%E9%A2%98%E5%B9%B8%E7%A6%8F%E6%84%9F%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">6.1.4.</span> <span class="nav-text">（4）提高刷题幸福感的小技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8C%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.2.</span> <span class="nav-text">2，经典动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.1.</span> <span class="nav-text">（1）最长递增子序列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.2.</span> <span class="nav-text">（2）最大子数组和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.3.</span> <span class="nav-text">（3）最长公共子序列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.4.</span> <span class="nav-text">（4）编辑距离问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.5.</span> <span class="nav-text">（5）正则表达式问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%EF%BC%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">3，背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%890-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.1.</span> <span class="nav-text">（1）0-1背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.2.</span> <span class="nav-text">（2）完全背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AD%90%E9%9B%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.3.</span> <span class="nav-text">（3）子集背包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%EF%BC%8C%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E6%B8%B8%E6%88%8F%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.</span> <span class="nav-text">4，用动态规划解决游戏类问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.1.</span> <span class="nav-text">（1）股票买卖类问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.2.</span> <span class="nav-text">（2）打家劫舍类问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98"><span class="nav-number">6.4.3.</span> <span class="nav-text">（3）博弈问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">6.4.4.</span> <span class="nav-text">（4）最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B"><span class="nav-number">6.4.5.</span> <span class="nav-text">（5）高楼扔鸡蛋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E9%AD%94%E5%A1%94"><span class="nav-number">6.4.6.</span> <span class="nav-text">（6）魔塔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E8%BE%90%E5%B0%84"><span class="nav-number">6.4.7.</span> <span class="nav-text">（7）辐射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E5%8A%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">6.4.8.</span> <span class="nav-text">（8）加权最短路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%EF%BC%8C%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">七，其他经典算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8C%E6%95%B0%E5%AD%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">1，数学算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AF%BB%E6%89%BE%E7%B4%A0%E6%95%B0"><span class="nav-number">7.1.1.</span> <span class="nav-text">（1）如何高效寻找素数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%A4%E9%81%93%E5%B8%B8%E8%80%83%E7%9A%84%E9%98%B6%E4%B9%98%E7%AE%97%E6%B3%95%E9%A2%98"><span class="nav-number">7.1.2.</span> <span class="nav-text">（2）两道常考的阶乘算法题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A6%82%E4%BD%95%E5%9C%A8%E6%97%A0%E9%99%90%E5%BA%8F%E5%88%97%E4%B8%AD%E9%9A%8F%E6%9C%BA%E6%8A%BD%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">7.1.3.</span> <span class="nav-text">（3）如何在无限序列中随机抽取元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%90%83%E8%91%A1%E8%90%84"><span class="nav-number">7.1.4.</span> <span class="nav-text">（4）吃葡萄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%90%8C%E6%97%B6%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E5%92%8C%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">7.1.5.</span> <span class="nav-text">（5）同时寻找缺失和重复的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">2，面试必知必会</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89nSum%E9%97%AE%E9%A2%98"><span class="nav-number">7.2.1.</span> <span class="nav-text">（1）nSum问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">7.2.2.</span> <span class="nav-text">（2）区间问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.3.</span> <span class="nav-text">（3）快速选择算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">7.2.4.</span> <span class="nav-text">（4）分治法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%89%AB%E6%8F%8F%E7%BA%BF%EF%BC%88%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%AE%A4%EF%BC%89"><span class="nav-number">7.2.5.</span> <span class="nav-text">（5）扫描线（安排会议室）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%951"><span class="nav-number">7.2.6.</span> <span class="nav-text">（6）贪心算法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%952"><span class="nav-number">7.2.7.</span> <span class="nav-text">（7）贪心算法2</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">George Zhao</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">113.4k</span>
  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
-->



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> Visitor
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> Total Visit
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"live2d-widget-model-tororo"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
