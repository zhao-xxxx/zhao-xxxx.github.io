<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js-mysql-1</title>
    <url>/2022/02/05/js-2-mysql/</url>
    <content><![CDATA[<p><strong>简介：</strong>MySQL的简介和安装</p>
<span id="more"></span>

<h1 id="一，MySQL介绍"><a href="#一，MySQL介绍" class="headerlink" title="一，MySQL介绍"></a>一，MySQL介绍</h1><p>​     MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>，由瑞典MySQL AB 公司开发，目前属于 <a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>之一，在 WEB 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<p>   MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>​    MySQL的优点有：1）成本低：开放源代码，一般可免费使用；2）性能高：执行很快；3）简单：容易安装和使用                                                                                                                                                                                                 </p>
<h1 id="二，Mysql安装（win系统，5-7版本）"><a href="#二，Mysql安装（win系统，5-7版本）" class="headerlink" title="二，Mysql安装（win系统，5.7版本）"></a>二，Mysql安装（win系统，5.7版本）</h1><p><strong>下载地址：</strong></p>
<p>官网下载(不推荐使用)：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br> 清华镜像站下载(推荐)：<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7">https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7</a></p>
<h2 id="1，软件安装版"><a href="#1，软件安装版" class="headerlink" title="1，软件安装版"></a>1，软件安装版</h2><p>软件安装版也就是后缀为.msi的安装包，进行有界面操作的安装，在安装的过程中对相关的属性进行设置，可参考这篇博客：<a href="https://blog.csdn.net/weixin_43790276/article/details/102090540">https://blog.csdn.net/weixin_43790276/article/details/102090540</a></p>
<h2 id="2，安装包解压版"><a href="#2，安装包解压版" class="headerlink" title="2，安装包解压版"></a>2，安装包解压版</h2><p>使用.zip后缀的安装包进行安装时，需要结合命令行和配置文件进行配置，适合有一定基础的使用，可参考博客：<a href="https://www.jianshu.com/p/ea4accd7afb4%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%EF%BC%9A">https://www.jianshu.com/p/ea4accd7afb4以及博客：</a></p>
<p><strong>总结：</strong>上面两种方式各有优点和缺点，选择适合自己的方法进行安装即可。我选择的是.mis安装方式，Windows中的服务名忘了设置，是默认的MySQL57，端口也是3306，用户名和密码都是root（自己学习用就设置简单一点，否则忘了就很麻烦）。最后MySQL的卸载比较麻烦，一定要从软件，安装路径，注册表这三个方面卸载干净。</p>
<h1 id="三，（补充）关系型数据库"><a href="#三，（补充）关系型数据库" class="headerlink" title="三，（补充）关系型数据库"></a>三，（补充）关系型数据库</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作"><a href="#三，MySQL操作" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作-1"><a href="#三，MySQL操作-1" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-2"><a href="#1，这是二级标题-2" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-4"><a href="#（1），这是三级标题-4" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-2"><a href="#2，这是二级标题-2" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-5"><a href="#（1），这是三级标题-5" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>尚融宝项目背景</title>
    <url>/2022/02/05/xm-1-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>**简介：尚融宝是尚硅谷培训机构的一个中等规模的项目，实现了一个网络借贷信息中介服务平台，为个人投资者、个人融资用户和小微企业提供专业的线上信贷及出借撮合服务。是学习微服务一个不错的项目。</p>
<span id="more"></span>

<h1 id="一，项目简介"><a href="#一，项目简介" class="headerlink" title="一，项目简介"></a>一，项目简介</h1><h2 id="1，项目的业务流程"><a href="#1，项目的业务流程" class="headerlink" title="1，项目的业务流程"></a>1，项目的业务流程</h2><p>业务流程如下图，从业务流程图可以看出，每个步骤必须有一个开始和结束，中间没有特别复杂的分支，设计业务的时候就应该像这样清晰简洁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-1.png" alt="xm-1-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-2.png" alt="xm-1-2"></p>
<h2 id="2，项目的架构图"><a href="#2，项目的架构图" class="headerlink" title="2，项目的架构图"></a>2，项目的架构图</h2><p>从架构图可以看出，不同服务之间的前端，网关，配置，数据库都可能会不一样，并且在发布时使用了Doker技术</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-3.png" alt="xm-1-3"></p>
<h1 id="二，技术栈（注意版本）"><a href="#二，技术栈（注意版本）" class="headerlink" title="二，技术栈（注意版本）"></a>二，技术栈（注意版本）</h1><p>首先基础的部分需要掌握：java基础、HTML、CSS、JavaScript、Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud Alibaba，MySQL（5.7及以上）、Redis、RabbitMQ、nginx、idea、maven、VMWare 虚拟机、CentOS 操作系统</p>
<h2 id="1，后端"><a href="#1，后端" class="headerlink" title="1，后端"></a>1，后端</h2><p><strong>SpringBoot 2.3.4.RELEASE</strong></p>
<p><strong>SpringCloud Hoxton.SR8：</strong>微服务基础设施 - 服务注册、服务发现、服务熔断、微服务网关、配置中心等</p>
<p>SpringCloud Alibaba 2.2.2.RELEASE</p>
<p><strong>MyBatis Plus：持久层框架和代码生成器</strong></p>
<p>Lombok：简化实体类开发</p>
<p>Swagger2：Api接口文档生成工具</p>
<p>Logback：日志系统</p>
<p>alibaba-easyexcel：Excel读写</p>
<p><strong>Spring Data Redis：Spring项目中访问Redis缓存</strong></p>
<p>HTTPClient: 基于Http协议的客户端，用来实现远程调用</p>
<p>Spring Task：定时任务</p>
<h2 id="2，数据库和中间件"><a href="#2，数据库和中间件" class="headerlink" title="2，数据库和中间件"></a>2，数据库和中间件</h2><p><strong>MySQL 5.7：关系型数据库   管理工具：Navicat</strong></p>
<p><strong>Redis 5.0：缓存技术   管理工具：RedisDesktopManager</strong></p>
<p><strong>RabbitMQ 3.8：消息中间件</strong></p>
<h2 id="3，三方接口"><a href="#3，三方接口" class="headerlink" title="3，三方接口"></a>3，三方接口</h2><p>阿里云短信：短信网关</p>
<p>阿里云OSS：分布式文件存储</p>
<p>资金托管平台API对接：汇付宝</p>
<h2 id="4，了解即可"><a href="#4，了解即可" class="headerlink" title="4，了解即可"></a>4，了解即可</h2><p>Node.js： JavaScript 运行环境</p>
<p>ES6：JavaScript的模块化版本</p>
<p>axios：一个发送Ajax请求的工具</p>
<p>Vue.js：web 界面的渐进式框架</p>
<p>Element-UI：前端组件库</p>
<p>模块化开发：解决javascript变量全局空间污染的问题</p>
<p>NPM：模块资源管理器</p>
<p>vue-element-admin：基于Vue.js的后台管理系统UI集成方案</p>
<p>NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架</p>
<h1 id="三，开发环境"><a href="#三，开发环境" class="headerlink" title="三，开发环境"></a>三，开发环境</h1><h2 id="1，开发环境检测"><a href="#1，开发环境检测" class="headerlink" title="1，开发环境检测"></a>1，开发环境检测</h2><p>在开始开发之前，需要确定基本的环境是否和开发要求的一致，在本项目中，要检查以下几个方面：</p>
<ul>
<li><p>jdk 1.8 配置：JAVA_HOME，path</p>
</li>
<li><p>maven 3.6 配置：MAVEN_HOME，本地仓库</p>
</li>
<li><p>ideaIU-2020.2.3，尽量在欢迎页面进行设置，这样对所有项目都是普遍有效的，当然给特定项目设置也是可以的，这里注意通过File–&gt;close project来到欢迎界面，如果不想每次打开idea都进入已有的项目（特别是大的项目，加载就得好一会），可以通过在Setting-&gt;System Settings取消勾选Reopen last project on open（如下图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-4.png" alt="xm-1-4"></p>
<p><em>注意：在idea的欢迎页面选择Configure &gt; settings</em>（比较新的版本似乎取消了右下角的Configure，比如我的idea 2021，要设置的话可以参考下图）。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-5.png" alt="xm-1-5"></p>
</li>
</ul>
<p>接着就是在开始一个项目时，一些基础的配置，<em>包括配置：Java Compiler、File Encodings、Maven、Auto Import、Code Completion &gt; Match case（取消）</em>  <em>插件：lombok、MyBatisX</em></p>
<p>1，Java Compiler。需要在Setting中（搜索Java Compiler），设置编译器为javac，版本为自己安装的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-6.png" alt="xm-1-6"></p>
<p>2，File Encodings。同上，如图，需要设置三个地方的编码方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-7.png" alt="xm-1-7"></p>
<p>3，maven</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-8.png" alt="xm-1-8"></p>
<p>4，Auto Import、Code Completion &gt; Match case（取消) 插件：lombok、MyBatisX</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-9.png" alt="xm-1-9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-10.png" alt="xm-1-10"></p>
<p>5，插件：lombok、MyBatisX</p>
<p>插件安装这里不再赘述</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>labuladong算法秘籍阅读笔记</title>
    <url>/2022/02/07/sf-1-labuladong/</url>
    <content><![CDATA[<p><strong>简介：</strong>该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。</p>
<span id="more"></span>

<h1 id="一，刷题思维"><a href="#一，刷题思维" class="headerlink" title="一，刷题思维"></a>一，刷题思维</h1><h2 id="1，数据结构的存储方式"><a href="#1，数据结构的存储方式" class="headerlink" title="1，数据结构的存储方式"></a>1，数据结构的存储方式</h2><h3 id="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）"><a href="#（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）" class="headerlink" title="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）"></a>（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</h3><p>散列表、栈、队列、堆、树、图等等各种数据结构 ，都是基于数组和链表的</p>
<h3 id="（2）数组和链表的优缺点"><a href="#（2）数组和链表的优缺点" class="headerlink" title="（2）数组和链表的优缺点"></a>（2）数组和链表的优缺点</h3><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。<u>但正因为连</u><br><u>续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全</u><br><u>部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以</u><br><u>保持连续，时间复杂度 O(N)。</u>  </p>
<p><strong>链表</strong>因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素<br>的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。<u>但是正因为存储空间不连续，<br>你⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位<br>置的指针，会消耗相对更多的储存空间</u></p>
<h2 id="2，数据结构的基本操作"><a href="#2，数据结构的基本操作" class="headerlink" title="2，数据结构的基本操作"></a>2，数据结构的基本操作</h2><h3 id="（1）数据结构的终极目的"><a href="#（1）数据结构的终极目的" class="headerlink" title="（1）数据结构的终极目的"></a>（1）数据结构的终极目的</h3><p>在不同的应⽤场景，尽可能⾼效地增删查改。  </p>
<h3 id="（2）操作的类型"><a href="#（2）操作的类型" class="headerlink" title="（2）操作的类型"></a>（2）操作的类型</h3><p>如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。<br>线性就是 for&#x2F;while 迭代为代表，⾮线性就是递归为代表。再具体⼀步，⽆⾮以下⼏种框架  ：</p>
<p>A，数组遍历框架（典型的线性迭代结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        <span class="comment">//访问并操作arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，链表遍历框架，兼具迭代和递归结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != <span class="keyword">null</span>;p = p.next)&#123;</span><br><span class="line">        <span class="comment">//访问并操作p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，二叉树遍历框架，典型的非线性递归遍历结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D,二叉树框架扩展为N叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E，N叉树遍历扩展为图的遍历</p>
<p>与N叉树类似，但是要避免出现环型的遍历，所以要添加一个布尔类型的Visited来标记是否遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArcNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Boolean visited;<span class="comment">//这里图中的每个节点的visited初始值为false</span></span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历有好几种，深度优先，广度优先，以及非递归，这里类似于N叉树，写深度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ArcNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.visited == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//访问并操作root.val</span></span><br><span class="line">     	root.visited = <span class="keyword">true</span>;</span><br><span class="line">   	 	<span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        	traverse(child);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-算法刷题指南"><a href="#3-算法刷题指南" class="headerlink" title="3,算法刷题指南"></a>3,算法刷题指南</h2><p>首先，<strong>数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法</strong>  ，所以在刷算法之前，应该了解常用的数据结构以及它们的基本操作和优缺点（散列表、栈、队列、堆、树、图等等）</p>
<p>然后，<strong>先刷⼆叉树，</strong>因为二叉树是最容易帮助人建立起框架思维的，对于一道二叉树相关的题，可以分为几个阶段：1，认识出这是一个能通过二叉树解决的问题；2，能写出答题的总体步骤（前序，中序，还是后序？），之中的一些细节就算写错，也不会错到哪儿去；3，扩展到解决其他问题（动态规划，回溯算法等等）</p>
<p><strong>注：</strong>这里我的理解是，二叉树作为一个在整个算法系统中的中间位置，能够很高的起到锻炼的作用，熟悉了二叉树后，简单的题目中的思路可以从二叉树中提取，复杂的题目可以从二叉树中扩展。</p>
<h1 id="二，计算机算法的本质"><a href="#二，计算机算法的本质" class="headerlink" title="二，计算机算法的本质"></a>二，计算机算法的本质</h1><h2 id="1，核心"><a href="#1，核心" class="headerlink" title="1，核心"></a>1，核心</h2><p>算法的本质就是穷举。(当然，某些问题可以通过总结规律解决，某些问题可以通过数学算法解决，但是绝大多数问题都是穷举)</p>
<p>但是此处的穷举并不是指暴力破解那样的寻找，因为一个问题的答案往往有很多条路，所以“穷举”思维，是包含两个层次的含义，如何穷举<strong>和</strong>如何聪明的穷举**，每道题的难点是不一样的</p>
<h3 id="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"><a href="#（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。" class="headerlink" title="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"></a>（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</h3><blockquote>
<p>（P19）前⽂ 动态规划核⼼套路 阐述了动态规划系列问题的核⼼原理，⽆⾮就是先写出暴⼒穷举解法（状态转移⽅程），加个备忘录就成⾃顶向下的动态规划解法了，再改⼀改就成⾃底向上的迭代解法了，动态规划的降维打击 ⾥也讲过如何分析优化动态规划算法的空间复杂度  </p>
<p>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧⼀听就会<br>了。但很多读者留⾔说明⽩了这些原理，遇到动态规划题⽬还是不会做，因为第⼀步的暴⼒解法都写不出<br>来。</p>
<p>这很正常，因为动态规划类型的题⽬可以千奇百怪，找状态转移⽅程才是难点，所以才有了 动态规划设计⽅<br>法：最⻓递增⼦序列 这篇⽂章，告诉你递归穷举的核⼼是数学归纳法，明确函数的定义，然后利⽤这个定义<br>写递归函数，就可以穷举出所有可⾏解。  </p>
</blockquote>
<h3 id="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"><a href="#（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。" class="headerlink" title="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"></a>（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</h3><blockquote>
<p>（p19）⽐如前⽂ Union Find 并查集算法详解 告诉你⼀种⾼效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我⽤ DFS&#x2F;BFS 暴⼒搜索（穷举）肯定可以做到，但⼈家 Union Find 算法硬是⽤数组模拟树结构，给你把连通性相关的操作复杂度给⼲到 O(1) 了。这就属于聪明地穷举，你学过就会⽤，没学过恐怕很难想出这种思路。</p>
<p>再⽐如贪⼼算法技巧，前⽂ 当⽼司机学会贪⼼算法 就告诉你，所谓贪⼼算法就是在题⽬中发现⼀些规律（专业点叫贪⼼选择性质），使得你不⽤完整穷举所有解就可以得出答案。</p>
<p>⼈家动态规划好⽍是⽆冗余地穷举所有解，然后找⼀个最值，你贪⼼算法可好，都不⽤穷举所有解就可以找<br>到答案，所以前⽂ 贪⼼算法解决跳跃游戏 中贪⼼算法的效率⽐动态规划还⾼。</p>
<p>再⽐如⼤名鼎鼎的 KMP 算法，你写个字符串暴⼒匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复⽤⼀些信息，减少了冗余计算，前⽂ KMP 字符匹配算法 就是使⽤状态机的思路实现<br>的 KMP 算法。  </p>
</blockquote>
<h1 id="三，基础数据结构"><a href="#三，基础数据结构" class="headerlink" title="三，基础数据结构"></a>三，基础数据结构</h1><h2 id="1，数组-x2F-链表"><a href="#1，数组-x2F-链表" class="headerlink" title="1，数组&#x2F;链表"></a>1，数组&#x2F;链表</h2><h3 id="（1）前缀和数组"><a href="#（1）前缀和数组" class="headerlink" title="（1）前缀和数组"></a>（1）前缀和数组</h3><p>前缀和，指的是在在计算中，如果要频繁的读取一段区间内的值，那么设定一个基准点，将该基准点以及到各个索引之间的值先计算出来并记录，这样再进行新区间值的计算的时候，能够避免重复计算。</p>
<p><u><strong>力扣303题——区域和检索-数组不可变</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png" alt="sf-1-1"></p>
<p>如果是不考虑时间复杂度，那么每次计算两个索引范围之间的和，都会进行一次数组的遍历，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.nums = nums;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		res += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目要求降低时间复杂度，那么我们要尽量避免同样的操作，前缀和数组就能帮助我们解决这样的问题，主要思路是，建立一个新的数组preSum，然后对于原来的数组nums，以0位基准，将不同范围的nums数组和存储在preSum中，也就是preSum[1]-&gt;sum[0]，preSum[4]-&gt;sum[0] + sum[1]+sum[2] + preSum[3]，那么求索引1~3之间的和，即可用preSum[3+1] - preSum[1]即可。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前缀和数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">	<span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">			preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣304题——二维区域和检索-矩阵不可变</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png" alt="sf-1-2"></p>
<p>此题和上一题类似，还是需要先计算矩阵的前缀和，只是此处的前缀和和上题不同，那么在这里我们需要什么样的前缀和呢？基准点是哪个呢?我们先看一下下面的计算过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png" alt="sf-1-3"></p>
<p>​    要计算红框里的数组和（坐标：2,1,4,3），它的值就等于黄框（0,0,4,3）减去粉框（0,0,1,3）减去绿框（0,0,4,0）最后加上紫框（0,0,1,0），这样我们就将基准点设置好了，同时我们也知道，需要计算的前缀和为坐标为（0,0,x,y）的框的和（x，y为不同的坐标点），利用这些坐标和，就可以算出所有的小框里的数字和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] preSum;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">			preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i- <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ⽬标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">		<span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] +preSum[x1][y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣560——和为k的子数组</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png" alt="sf-1-4"></p>
<p>这道题基础的做法是采用穷举所有子数组的做法，并检查他们是否和为K。但是这种做法太简单了，我们可以尝试用前缀和，有了前缀和在穷举子数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// 构造前缀和</span></span><br><span class="line">	<span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 穷举所有⼦数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)	</span><br><span class="line">			<span class="comment">// ⼦数组 nums[j..i-1] 的元素和</span></span><br><span class="line">			<span class="keyword">if</span> (preSum[i] - preSum[j] == k)</span><br><span class="line">				res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这里的时间复杂度还是o(N^2)，空间复杂度是o(N)（空间复杂度都挺高了时间复杂度没降下来说不过去），那么我们需要进行进一步的改良，一个思路是，我们能不能在计算前缀和的同时，判断该前缀和是否存在一个对应的相差为K的前缀和，如果有则统计次数加1，如果没有则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class="line">	HashMap&lt;Integer, Integer&gt;</span><br><span class="line">		preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// base case	</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum0_i += nums[i];</span><br><span class="line">		<span class="comment">// 这是我们想找的前缀和 nums[0..j]</span></span><br><span class="line">		<span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">		<span class="comment">// 如果前⾯有这个前缀和，则直接更新答案</span></span><br><span class="line">		<span class="keyword">if</span> (preSum.containsKey(sum0_j))</span><br><span class="line">			res += preSum.get(sum0_j);</span><br><span class="line">		<span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数</span></span><br><span class="line">		preSum.put(sum0_i,</span><br><span class="line">			preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）差分数组"><a href="#（2）差分数组" class="headerlink" title="（2）差分数组"></a>（2）差分数组</h3><p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和 。本节与前缀和数组类似，讲的是差分数组，指的是频繁对原始数组的某个区间的元素进⾏增减，最后的数组内容发生了改变。</p>
<p>**<u>引例</u>**：⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给…  最后的数组是什么样的呢？一般情况下，我们不断的循环遍历修改数组就行，但这样每次的时间复杂度都是O(n)，效率不高</p>
<p>所以我们需要使用<strong>差分数组</strong>，差分数组指的是构造一个新的数组diff[]，diff[i] &#x3D; nums[i] - nums[i - 1]（如图）,并且根据差分数组可以反推出原数组（设一个数组res[]，res[0] &#x3D; diff[0]，这样的话原数组res[i] &#x3D; res[i - 1] + diff[i]，其中i &gt;&#x3D; 1），</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png" alt="sf-1-5"></p>
<p>差分数组在频繁的修改某个区间的值中能够降低复杂度，比如要将区间 i ~ j 中的所有数都加3，那么可以将差分数组diff[i] +&#x3D; 3，diff[j] -&#x3D; 3，这样恢复为原数组的时候就可以实现这样的效果。原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -&#x3D; 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 。</p>
<p>差分数组的这些初始化操作，变化操作，以及恢复操作可以抽象为一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;<span class="comment">//assert对一个boolean表达式进行检查，一个正确运行的程序保证boolean值为true，若为false，则说明程序不正确，系统需要提供警告信息并且退出程序。</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] -nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处val可以是负数，另外如果j大于diff.length的话，就表明i之后的数组都要增加val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    	diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">        	diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣370——区间加法</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png" alt="sf-1-6"></p>
<p>这道题使用引例中实现的类即可。代码如下（省略了类的定义）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length,<span class="keyword">int</span>[][] updates)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    Difference difference = <span class="keyword">new</span> Difference(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] update : updates)&#123;</span><br><span class="line">        difference.increment(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1109——航班预订统计</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png" alt="sf-1-7"></p>
<p>本体也就是差分数组的变体，写法与上题大致相同，但是这里注意，航班的编号是1 ~ n！，对应数组中的0 ~ n-1!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Different different = <span class="keyword">new</span> Different(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] booking : bookings)&#123;</span><br><span class="line">        different.increment(booking[<span class="number">0</span>] - <span class="number">1</span>,booking[<span class="number">1</span>] - <span class="number">1</span>,booking[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> different.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1094——拼车</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png" alt="sf-1-8"></p>
<p>本题同样是差分数组的扩展，对于这种明显的问题，我们需要明确的是我们在模板中的nums[]，[i，j，val]数组，以及res[]数组的含义。在本题中，明显能发现trip[a,b,c]这个三维数组对应的是变化的标记，那么nums[]数组就是每站车上的人数（初始为0），最后的res[]就是车开了一遍后每站都有多少人。<u>我们判断能否一次性把顾客运送完，就先假设容量无限大，计算出res[],最后遍历res[]看途中是否有不符合条件的情况即可。</u>本题中没有直接说有多少车站，但是说明了车站的范围在0~1000之间，那么可设nums[1001]（初试值为0），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    Difference df = <span class="keyword">new</span> Difference(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] trip : trips)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = trip[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里注意，j站的时候已经下车啦</span></span><br><span class="line">        <span class="keyword">int</span> j = trip[<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = df.result();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h3><p><strong>引入：</strong>指的是一类问题，通过维护⼀个窗⼝，不断滑动，然后更新答案  。该算法时间复杂度为O（N），比字符串暴利算法高效很多。但是该思路存在很多细节问题：⽐如说如何向窗⼝中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果 …除此之外，出现了Bug调试也很困难。</p>
<p>所以根据labuladong笔记，其中总结了一个框架（包含了debug的输出提示），遇到相关类型，默写该框架，修改三个地方即可解决大部分滑动窗口题。(后面会有几道力扣的题进行使用展示)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need ,window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">//右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">        <span class="comment">//下面更新窗口数据</span></span><br><span class="line">        ...update...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面是debug输出的位置    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>,left,right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">           <span class="comment">//d 是将移出窗口的字符</span></span><br><span class="line">           <span class="keyword">char</span> d = s[left];</span><br><span class="line">           <span class="comment">//左移窗口</span></span><br><span class="line">           left++;</span><br><span class="line">           <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">           ...update...</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>滑动窗⼝很多时候都是在处理字符串相关的问题，Java 处理字符串不⽅便，所以本⽂代码为 C++ 实<br>现。不会⽤到什么编程⽅⾯的奇技淫巧，但是还是简单介绍⼀下⼀些⽤到的数据结构，以免有的读者因为语<br>⾔的细节问题阻碍对算法思想的理解：  </p>
<p>unordered_map 就是哈希表（字典），它的⼀个⽅法 count(key) 相当于 Java 的 containsKey(key)<br>可以判断键 key 是否存在。<br>        可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个<br>key，并把 map[key] 赋值为 0。<br>        所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) +1)。  </p>
<p><strong><u>力扣76——最小覆盖子串</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png" alt="sf-1-9"></p>
<p>这道题我们将代码先贴在下面，然后结合图片观察滑动窗口实现的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,先更新start和len的值，然后左移窗口，取left处的字符d，然后自增1。更新操作：判断need中是否有字符d，存在的话（如果window中的d的次数和need中的一样，则valid自减1，）则window中的d的出现次数自减1。若字符d导致了valid自减1，start记录的位置是将其包含在内的。</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若跳出了上面的循环，则取s的子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，本题中的代码的运行流程应该是下面这样，读者可以自己手动过一遍，加强印象</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png" alt="sf-1-10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png" alt="sf-1-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png" alt="sf-1-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png" alt="sf-1-13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png" alt="sf-1-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png" alt="sf-1-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png" alt="sf-1-16"></p>
<blockquote>
<p>使⽤ Java 的读者要尤其警惕语⾔特性的陷阱。Java 的 Integer，String 等类型判定相等应该⽤<br>equals ⽅法⽽不能直接⽤等号 &#x3D;&#x3D;，这是 Java包装类的⼀个隐晦细节。所以在左移窗⼝更新数据的时<br>候，不能直接改写为 window.get(d) &#x3D;&#x3D; need.get(d)，⽽要⽤window.get(d).equals(need.get(d))，之后的题⽬代码同理。  </p>
</blockquote>
<p><strong><u>力扣567——字符串排列</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png" alt="sf-1-17"></p>
<p>说明：本题第目的就是给你⼀个 s1 和⼀个 s2，请问你 s2中是否存在⼀个⼦串，包含 s1 中所有字符且不包含其他字符？  这里注意，s1中可以包含相同的字符串。</p>
<p>这道题应用在框架中要注意几点：1）窗口在往右扩大时，是一样的，将对应的字母都要包含的窗口中。2）收缩窗口时便有所不同，首先窗口的关闭条件应该是，while（right - left &gt;&#x3D; t.size()），这样才能保证及时缩小窗口。3）在缩小的过程中，一旦valid &#x3D;&#x3D; need.size()  ，便表明找到了最后的答案。    具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,这里窗口收缩的条件不同，right和left限制了一个与目标字符串相同大小的窗口，并且本题不需要记录该字符串的位置，所以也不需要start和len</span></span><br><span class="line">        <span class="comment">// while(valid == need.size())</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">		   <span class="comment">//这里注意，valid值如果与need的值相同，则表明当前窗口下的size个字符都是我们需要的字符</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的循环没有返回true，那就一定是false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣438——找到字符串中所有字母异位词</strong></u></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png" alt="sf-1-18" style="zoom:67%;" />

<p>说明：本题扩大窗口没有特殊的地方，收缩窗口时注意记录子串的起始索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣3——最长不重复子串</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png" alt="sf-1-19"></p>
<p>说明：本题没有固定的字符串对应，所以不需要need数组，也不需要valid来记录情况，但是需要window数组来记录窗口中字符的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">char</span> d = s[left];</span><br><span class="line">             left++;</span><br><span class="line">			window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）二分搜索框架"><a href="#（4）二分搜索框架" class="headerlink" title="（4）二分搜索框架"></a>（4）二分搜索框架</h3><p><strong>引入</strong>：⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。⽽且，我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的⼆分查找算法  。下面是二分查找的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">     	<span class="keyword">int</span> mid = left + (right - left)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚，读者理解后可⾃⾏简化。<br>    其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样的变化。<br>    另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) &#x2F; 2 就和 (left +right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。  </p>
<p>接下来说明几个二分搜索的应用场景：</p>
<p><strong><u>寻找一个数（基本的二分搜索）</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left =  mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该算法有几个注意的地方：    1）while判断条件是（left &lt;&#x3D; right），而不是（left &lt; right），我们使用的闭区间搜索（因为right赋值为nums.length - 1)，若此时left和right都是2的话，while(left &lt; right)这个判断语句就会错过2这个下标所代表的位置；      2）当判断过mid位置的数字后，left和right的更新就对应的+1和-1；      3）该算法无法处理有多个结果的情况，比如在数组nums &#x3D; [1,2,2,2,3]中搜索数字2，只能得到索引2，无法得到左侧的索引1和右侧的索引2.</p>
<p><strong><u>寻找左侧边界的二分搜索</u></strong></p>
<p>下面的算法是左右都是闭区间检查，那么rigth的初试值就是nums.length - 1，while的终止条件就是left &#x3D; right + 1。这里要注意，循环的退出条件既然变成了left &#x3D; right + 1，那么如果一个数组中的左右元素都比target小，left就会比right大，所以最后那里需要进行判读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_boud</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.lenght - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>寻找右侧边界的二分查找</u></strong></p>
<p>下面是两边闭区间的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; taeget)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是左侧还是右侧边界的搜索，其实可以抽象为一定范围内的找极值的行为，比如对于nums &#x3D; [1,2,3,3,3,5,7]，想搜索target &#x3D; 3，搜索左侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-20.png" alt="sf-1-20"></p>
<p>搜索右侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-21.png" alt="sf-1-21"></p>
<p>是不是有一种做函数题的感觉</p>
<h3 id="（5）二分搜索题型"><a href="#（5）二分搜索题型" class="headerlink" title="（5）二分搜索题型"></a>（5）二分搜索题型</h3><p>⽂总结的⼆分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够⽤到⼆分搜索 。所以接下来需要一套二分搜索算法应用的套路（思路）</p>
<p><strong>首先</strong>，什么样的题可以使用二分搜索的技巧呢？一般是符合以下条件的题：</p>
<p>可以从题目中抽象出一个自变量x，关于x的函数f(x)，以及一个目标值target，同时x，f(x)，target需要满足以下条件</p>
<p>1，f(x)必须是在x上的单调函数（单增单减都可以）</p>
<p>2，题目要求计算f(x) &#x3D;&#x3D; target时的x的值</p>
<p>对于上一节的例子（就是nums &#x3D; [1,2,3,3,3,5,7]，搜索左侧target &#x3D; 3），可以抽象为下面这样的形式（虽然没必要）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid, nums) == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || f(left, nums) != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，对于一个需要二分搜索解决的问题，我们的思考点应该是几个方面，具体见下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1,根据题意确定x的最小值是多少</span></span><br><span class="line">    <span class="keyword">int</span> left = ...;</span><br><span class="line">    <span class="comment">//2,根据题意确定x的最小值是多少（这个是闭区间写法）</span></span><br><span class="line">    <span class="keyword">int</span> right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= rigth)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//3,怎么让f(x)大一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//4,怎么让f(x)小一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//5,题目求的左边界还是右边界（注意是闭区间写法）</span></span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6,闭区间需要判断是都超出范围</span></span><br><span class="line">    <span class="keyword">if</span> ...;</span><br><span class="line">    <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，想用二分搜索来解决问题的话，主要有以下几步：</p>
<ul>
<li>确定 x, f(x), target 分别是什么，并写出函数 f 的代码  </li>
<li>找到 x 的取值范围作为⼆分搜索的搜索区间，初始化 left 和 right 变量。  </li>
<li>根据题⽬的要求，确定应该使⽤搜索左侧还是搜索右侧的⼆分搜索算法，写出解法代码</li>
</ul>
<p><strong>力扣875——爱吃香蕉的珂珂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</span><br><span class="line"></span><br><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        Tool tool  = <span class="keyword">new</span> Tool();</span><br><span class="line">        <span class="keyword">int</span>[] res = tool.getMaxandMin(piles);</span><br><span class="line">        <span class="keyword">int</span> min = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = res[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getTime(piles,mid) &lt; h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) == h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] getMaxandMin(<span class="keyword">int</span>[] piles)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &gt; max)&#123;</span><br><span class="line">                max = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &lt; min)&#123;</span><br><span class="line">                min = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = min;</span><br><span class="line">        res[<span class="number">1</span>] = max;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            res += (pile % speed == <span class="number">0</span>) ? (pile / speed) : (pile / speed + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1011——在D天内送达包裹的能力</u></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line">返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= days &lt;= weights.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= weights[i] &lt;= 500</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">5000000</span>;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights,mid) == -<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights, mid) &lt; days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights, mid) &gt; days)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights,mid) == days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">5000000</span>) <span class="keyword">return</span> <span class="number">5000000</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &gt; capacity)&#123;</span><br><span class="line">                loc = -<span class="number">1</span>;</span><br><span class="line">                day = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp + weights[i] &gt; capacity)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                loc = i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt; weights.length &amp;&amp; loc != -<span class="number">1</span>)&#123;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="（6）优势洗牌"><a href="#（6）优势洗牌" class="headerlink" title="（6）优势洗牌"></a>（6）优势洗牌</h3><p>该点与双指针关联，这里暂时不添加</p>
<h3 id="（7）原地修改数组"><a href="#（7）原地修改数组" class="headerlink" title="（7）原地修改数组"></a>（7）原地修改数组</h3><p><u><strong>力扣26——删除排序数组中的重复项</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-22.png" alt="sf-1-22"></p>
<p>说明：由于不能新建数组，所以只能通过指针去探测并记录，在此基础上更新。一个指针无法确定新的元素和应该插入的位置，所以这里需要使用双指针，一个记录插入的位置，一个进行探测，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">           slow ++;</span><br><span class="line">           nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣83——删除排序链表中的重复元素</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-23.png" alt="sf-1-23"></p>
<p>说明：本题和上一题（力扣26）其实是一样的，只是把数据结构换成了链表，并且多了删除链表的操作，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.val != slow.val)&#123;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣27——移除元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-24.png" alt="sf-1-24"></p>
<p>说明：此题和前面是类似的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣283——移动零)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-25.png" alt="sf-1-25"></p>
<p>说明：同样用快慢指针就可以了，两种方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,可以使用快慢指针，首先将low指针定位打0的位置出，然后移动fast指针寻找非0的元素进行调换即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] != <span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; nums.length &amp;&amp; nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                nums[fast] = <span class="number">0</span>;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2, 将问题转化，将所有非零元素往前移，然后再将后面多出的元素设为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = removeElement(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(; p &lt; nums.length; p++)&#123;</span><br><span class="line">        nums[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

































































]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>xm-2-MyBatis-Plus</title>
    <url>/2022/02/06/xm-2-MyBatis-Plus/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，基础知识之字词积累"><a href="#一，基础知识之字词积累" class="headerlink" title="一，基础知识之字词积累"></a>一，基础知识之字词积累</h1><h2 id="1，《斑比出生了》"><a href="#1，《斑比出生了》" class="headerlink" title="1，《斑比出生了》"></a>1，《斑比出生了》</h2><h3 id="（1），几种类型的词语"><a href="#（1），几种类型的词语" class="headerlink" title="（1），几种类型的词语"></a>（1），几种类型的词语</h3><h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-springmvc</title>
    <url>/2022/02/06/js-3-springmvc/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-4"><a href="#（1），这是三级标题-4" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-5"><a href="#（1），这是三级标题-5" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
</search>
