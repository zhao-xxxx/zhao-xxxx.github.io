<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jc-4-计算机网络</title>
    <url>/2022/04/25/jc-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-5-操作系统</title>
    <url>/2022/04/25/jc-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-1-集合</title>
    <url>/2022/04/25/jc-1-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><strong>简介：</strong>本文对集合类的源码进行了初步的学习和消化。</p>
<span id="more"></span>

<h1 id="一，分类"><a href="#一，分类" class="headerlink" title="一，分类"></a>一，分类</h1><h2 id="1，Collection接口"><a href="#1，Collection接口" class="headerlink" title="1，Collection接口"></a>1，Collection接口</h2><h3 id="（1）set集合"><a href="#（1）set集合" class="headerlink" title="（1）set集合"></a>（1）set集合</h3><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。</p>
<p>但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。</p>
<p>并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序</p>
<h3 id="（2）List集合"><a href="#（2）List集合" class="headerlink" title="（2）List集合"></a>（2）List集合</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>基于动态数组实现，支持随机访问。</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>和 ArrayList 类似，但它是线程安全的。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
<h3 id="（3）Queue"><a href="#（3）Queue" class="headerlink" title="（3）Queue"></a>（3）Queue</h3><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>可以用它来实现双向队列。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列</p>
<h2 id="2，Map接口"><a href="#2，Map接口" class="headerlink" title="2，Map接口"></a>2，Map接口</h2><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>基于红黑树实现。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>基于哈希表实现。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p>
<h1 id="二，ArrayList源码解析"><a href="#二，ArrayList源码解析" class="headerlink" title="二，ArrayList源码解析"></a>二，ArrayList源码解析</h1><h2 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h2><p>ArrayList实现了List接口，底层通过数组实现，元素顺序与放入的顺序相同，允许放null值。其类中有capacity变量，表示当前能存储的元素，会自动扩容。</p>
<p>get() ，set()，size()等方法均能在常数时间内完成。add()方法与插入的位置有关。addAll()方法与添加的元素个数成正比</p>
<h2 id="2，底层数据结构"><a href="#2，底层数据结构" class="headerlink" title="2，底层数据结构"></a>2，底层数据结构</h2><p>维护了一个object数组和size变量。这个size默认是10</p>
<h2 id="3，构造函数"><a href="#3，构造函数" class="headerlink" title="3，构造函数"></a>3，构造函数</h2><p>1，可以按照要求的大小（传入initialCapacity参数）进行初始化，elementData数组中的元素都为null。</p>
<p>2，传入一个list，以获取迭代器</p>
<p>3，不传入参数，按照默认大小创建，默认size为10</p>
<h2 id="4，自动扩容"><a href="#4，自动扩容" class="headerlink" title="4，自动扩容"></a>4，自动扩容</h2><p>数组扩容通过一个public方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。</p>
<p>当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5，add-addAll"><a href="#5，add-addAll" class="headerlink" title="5，add(),addAll()"></a>5，add(),addAll()</h2><p><code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</p>
<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addAll()</code>方法能够一次添加多个元素</p>
<p>在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，</p>
<p>从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。</p>
<p>跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 <code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6，get和set方法"><a href="#6，get和set方法" class="headerlink" title="6，get和set方法"></a>6，get和set方法</h2><p>太简单了不说了</p>
<h2 id="7，remove方法"><a href="#7，remove方法" class="headerlink" title="7，remove方法"></a>7，remove方法</h2><p><code>remove()</code>方法也有两个版本</p>
<p><code>remove(int index)</code>删除指定位置的元素</p>
<p><code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。</p>
<p>删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8，trimToSize"><a href="#8，trimToSize" class="headerlink" title="8，trimToSize()"></a>8，trimToSize()</h2><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现</p>
<h2 id="9-indexOf-lastIndexOf"><a href="#9-indexOf-lastIndexOf" class="headerlink" title="9,indexOf(), lastIndexOf()"></a>9,indexOf(), lastIndexOf()</h2><p>获取元素的第一次出现的index,和获取元素的最后一次出现的index</p>
<h2 id="10，-Fail-Fast机制"><a href="#10，-Fail-Fast机制" class="headerlink" title="10， Fail-Fast机制"></a>10， Fail-Fast机制</h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p>
<h1 id="三，LinkedList源码"><a href="#三，LinkedList源码" class="headerlink" title="三，LinkedList源码"></a>三，LinkedList源码</h1><h2 id="1，概述-1"><a href="#1，概述-1" class="headerlink" title="1，概述"></a>1，概述</h2><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<em>Queue</em>)，同时又可以看作一个栈(<em>Stack</em>)。这样看来，<em>LinkedList</em>简直就是个全能冠军。</p>
<p>LinkedList底层是一个双向链表，有两个指针，first和last。<em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220428164125372.png" alt="image-20220428164125372" style="zoom:67%;" />

<h2 id="2，底层数据结构-1"><a href="#2，底层数据结构-1" class="headerlink" title="2，底层数据结构"></a>2，底层数据结构</h2><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Node是私有的内部类:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，构造函数-1"><a href="#3，构造函数-1" class="headerlink" title="3，构造函数"></a>3，构造函数</h2><p>一个空参，一个有参（可以传入一个collection，做出list中的元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，常用方法"><a href="#4，常用方法" class="headerlink" title="4，常用方法"></a>4，常用方法</h2><h3 id="（1）getFirst-和getLast-方法"><a href="#（1）getFirst-和getLast-方法" class="headerlink" title="（1）getFirst()和getLast()方法"></a>（1）getFirst()和getLast()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="（2）remove系列方法"><a href="#（2）remove系列方法" class="headerlink" title="（2）remove系列方法"></a>（2）remove系列方法</h3><p>下面的这写方法中，都涉及了修改size，modCount，和考虑GC</p>
<p><strong>remove(Object o)方法</strong> - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p>
<p>这里被删除的节点手动赋值为了null，方便GC去收集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">// 第一个元素</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">// 最后一个元素</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>; <span class="comment">// GC</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**remove(int index)**方法使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。返回的是被删除的这个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeFirst()方法</strong>，这个方法中先判断头节点是不是null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeLast()方法</strong>中，同样也是先判断这个节点是不是null，然后再进行进一步的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the last element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）add系列方法"><a href="#（3）add系列方法" class="headerlink" title="（3）add系列方法"></a>（3）add系列方法</h3><p>有add(),addAll()</p>
<p>**add()*<em>方法有两个版本，一个是<code>add(E e)</code>，该方法在LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E element)</strong>, 当index&#x3D;&#x3D;size时，等同于add(E e); 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>addAll()方法</strong>，addAll(Collection&lt;? extends E&gt; c)直接在链表为连上，addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">   * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment">   * collection&#x27;s iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment">   * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment">   * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment">   * this list, and it&#x27;s nonempty.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">   * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">   * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">   * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">   * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">   * specified collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment">   *              from the specified collection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line"><span class="comment">//1，首先将collection c转换为数组，并且判断长度是不是0</span></span><br><span class="line">      Object[] a = c.toArray();</span><br><span class="line">      <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">      <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//2,如果说位置和长度相同，那么pre指针就是last；否则用succ指向要插入位置的node，pre指向succ的前一个</span></span><br><span class="line">      Node&lt;E&gt; pred, succ;</span><br><span class="line">      <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">          succ = <span class="keyword">null</span>;</span><br><span class="line">          pred = last;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          succ = node(index);</span><br><span class="line">          pred = succ.prev;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//3,对于数组中的每个元素，创建新node，并链接在pred的后面，此时判断一下First的情况，并不断移动pre</span></span><br><span class="line">      <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">          Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">              first = newNode;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              pred.next = newNode;</span><br><span class="line">          pred = newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4,判断一下succ的值，看是不是要进行连接</span></span><br><span class="line">      <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          last = pred;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pred.next = succ;</span><br><span class="line">          succ.prev = pred;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      size += numNew;</span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）clear"><a href="#（4）clear" class="headerlink" title="（4）clear"></a>（4）clear</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.</span></span><br><span class="line"><span class="comment"> * The list will be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（5）Positional-Access-方法"><a href="#（5）Positional-Access-方法" class="headerlink" title="（5）Positional Access 方法"></a>（5）Positional Access 方法</h3><p>通过index获取元素，将某个位置的元素重新赋值，删除指定位置的元素，这些都比较简单。下面看看将元素插入到指定index位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（6）查找操作"><a href="#（6）查找操作" class="headerlink" title="（6）查找操作"></a>（6）查找操作</h3><p>查找操作的本质是查找元素的下标:</p>
<p>查找第一次出现的index, 如果找不到返回-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the first occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找最后一次出现的index, 如果找不到返回-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the last occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（7）队列操作"><a href="#（7）队列操作" class="headerlink" title="（7）队列操作"></a>（7）队列操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the first element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the last element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the first element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the last element of this list,</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the last occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四，HashMap（HashSet）"><a href="#四，HashMap（HashSet）" class="headerlink" title="四，HashMap（HashSet）"></a>四，HashMap（HashSet）</h1><h2 id="1，java1-7版本"><a href="#1，java1-7版本" class="headerlink" title="1，java1.7版本"></a>1，java1.7版本</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。该容器不保证元素有序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。</p>
<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429205921429.png" alt="image-20220429205921429" style="zoom: 67%;" />

<p><strong>读存性能：</strong>如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>
<p><strong>有两个参数可以影响<em>HashMap</em>的性能：</strong>:初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p><strong>存放的注意事项：</strong>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<u><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”。</u>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要*@Override*<code>hashCode()</code>和<code>equals()</code>方法。</p>
<h3 id="（2）get方法"><a href="#（2）get方法" class="headerlink" title="（2）get方法"></a><strong>（2）get方法</strong></h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，<code>get(Object key)</code>方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心</p>
<p><code>getEntry()</code>方法是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。</p>
<p>要计算key对应的bucket的下标，<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429220035827.png" alt="image-20220429220035827" style="zoom:67%;" />

<h3 id="（3）put方法"><a href="#（3）put方法" class="headerlink" title="（3）put方法"></a>（3）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；</p>
<p>如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429221657125.png" alt="image-20220429221657125" style="zoom:67%;" />

<h3 id="（3）remove"><a href="#（3）remove" class="headerlink" title="（3）remove()"></a>（3）remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>getEntry()</code>过程类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2，Java1-8版本"><a href="#2，Java1-8版本" class="headerlink" title="2，Java1.8版本"></a>2，Java1.8版本</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><p>java8在处理同位置的元素时，该用数组+链表+红黑树的组合解决，当同一位置的元素超过8个时，由链表变为红黑树，这样就降低了寻找元素的时间。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<h3 id="（2）put方法"><a href="#（2）put方法" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，参数理解：第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作，第五个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 2，数组的初试化时机：第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度，第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 3.1找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//3.2数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.1，如何插入到位置，如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2，如何插入到位置，到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// ***此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5，与***对应，处理相同的情况。e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;。对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）数组扩容"><a href="#（3）数组扩容" class="headerlink" title="（3）数组扩容"></a>（3）数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移</p>
<p>这也太复杂了，得空再看看资料</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//1.1，开始进行参数的调整 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2，将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//1.3 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 1.4 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//1.5 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 2.2 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 2.3 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 2.4 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-get方法"><a href="#4-get方法" class="headerlink" title="(4)get方法"></a>(4)get方法</h3><p>相对于 put 来说，get 真的太简单了。</p>
<ul>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="五，LinkedHashMap（LinkedHashSet）"><a href="#五，LinkedHashMap（LinkedHashSet）" class="headerlink" title="五，LinkedHashMap（LinkedHashSet）"></a>五，LinkedHashMap（LinkedHashSet）</h1><h2 id="1，概述-2"><a href="#1，概述-2" class="headerlink" title="1，概述"></a>1，概述</h2><p><em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说**LinkedHashSet里面有一个LinkedHashMap(适配器模式)*<em>。因此本文将重点分析</em>LinkedHashMap*。</p>
<p><strong>优点</strong>：<em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。LinkedHashMap<em>是</em>HashMap*的直接子类，<strong>二者唯一的区别是*LinkedHashMap*在*HashMap*的基础上，采用双向链表(doubly-linked list)的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p>
<p>除了可以保迭代历顺序，这种结构还有一个好处 : <strong>迭代*LinkedHashMap*时不需要像*HashMap*那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>
<p><strong>性能</strong>: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p><strong>原理</strong>：将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。**<code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</p>
<h2 id="2，常用方法"><a href="#2，常用方法" class="headerlink" title="2，常用方法"></a>2，常用方法</h2><h3 id="（1）get方法"><a href="#（1）get方法" class="headerlink" title="（1）get方法"></a>（1）get方法</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样</p>
<h3 id="（2）put方法-1"><a href="#（2）put方法-1" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该Entry，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；</p>
<p>如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。插入有两个含义：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li>
<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下:</span></span><br><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="(3)remove方法"></a>(3)remove方法</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p>
<p>删除也有两层含义：</p>
<blockquote>
<p>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</p>
<p>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3，实现FIFO替换策略的缓存"><a href="#3，实现FIFO替换策略的缓存" class="headerlink" title="3，实现FIFO替换策略的缓存"></a>3，实现FIFO替换策略的缓存</h3><p><em>LinkedHashMap</em>除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。</p>
<p>在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="六，TreeMap（TreeSet）"><a href="#六，TreeMap（TreeSet）" class="headerlink" title="六，TreeMap（TreeSet）"></a>六，TreeMap（TreeSet）</h1><h2 id="1，概述-3"><a href="#1，概述-3" class="headerlink" title="1，概述"></a>1，概述</h2><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口（key不能为null），也就是说会按照<code>key</code>的大小顺序对<em>Map</em>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p>
<p>*<strong>TreeMap*底层通过红黑树(Red-Black tree)实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度</p>
<p><em>TreeMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成(wrapped)同步的:</p>
<h2 id="2，红黑树"><a href="#2，红黑树" class="headerlink" title="2，红黑树"></a>2，红黑树</h2><h3 id="（1）认识红黑树"><a href="#（1）认识红黑树" class="headerlink" title="（1）认识红黑树"></a>（1）认识红黑树</h3><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色</li>
<li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li>
<li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。</li>
</ol>
<p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p>
<h3 id="（2）左旋调整"><a href="#（2）左旋调整" class="headerlink" title="（2）左旋调整"></a>（2）左旋调整</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501141626265.png" alt="image-20220501141626265" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeMap中的左旋调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1，准备将r转上去</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        <span class="comment">//2，p左边连接r的左子树，注意这是双向连接</span></span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        <span class="comment">//3，r挂在p原来的父节点的下面，注意这也是双向连接</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        <span class="comment">//4，最后再调整一下r左边的双向连接，右边不用动</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）右旋调整"><a href="#（3）右旋调整" class="headerlink" title="（3）右旋调整"></a>（3）右旋调整</h3><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501141858898.png" alt="image-20220501141858898" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeMap的右旋调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1,p的左孩子挂上l的右子树，注意是双向连接</span></span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        <span class="comment">//2，l的父节点更新为p的父节点</span></span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        <span class="comment">//3，l的右孩子更新为p</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-寻找节点的后继"><a href="#4-寻找节点的后继" class="headerlink" title="(4)寻找节点的后继"></a>(4)寻找节点的后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p>
<blockquote>
<ol>
<li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li>
<li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找节点后继函数successor()</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;<span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3，常用方法"><a href="#3，常用方法" class="headerlink" title="3，常用方法"></a>3，常用方法</h2><h3 id="（1）get方法-1"><a href="#（1）get方法-1" class="headerlink" title="（1）get方法"></a>（1）get方法</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。</p>
<p>算法思想是根据<code>key</code>的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501145145879.png" alt="image-20220501145145879" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）put方法-2"><a href="#（2）put方法-2" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1，使用元素的自然顺序进行比较，并找到要插入的位置parent</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//2，创建并插入新的entry插入到parent下面</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    <span class="comment">//3，调整树的结构</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里最难的是第三步的fixAfterInsertion函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/TreeMap_put.png" alt="TreeMap_put.png"></p>
<p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）remove方法"><a href="#（4）remove方法" class="headerlink" title="（4）remove方法"></a>（4）remove方法</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。<code>deleteEntry()</code>函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p>
<p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p>
<blockquote>
<ol>
<li>删除点p的左右子树都为空，或者只有一棵子树非空。</li>
<li>删除点p的左右子树都非空。</li>
</ol>
</blockquote>
<p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 1. 删除点p的左右子树都非空。</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 删除点p只有一棵子树非空。</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p>
<p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/TreeMap_fixAfterDeletion.png" alt="TreeMap_fixAfterDeletion.png"></p>
<p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p>
<p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-2-虚拟机</title>
    <url>/2022/04/25/jc-2-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-3-多线程</title>
    <url>/2022/04/25/jc-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-6-数据结构</title>
    <url>/2022/04/25/jc-6-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-mybatis</title>
    <url>/2022/04/25/js-3-mybatis/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-5-Dubbo</title>
    <url>/2022/04/25/js-6-Dubbo/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-4-Redis</title>
    <url>/2022/04/25/js-5-Redis/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-6-linux</title>
    <url>/2022/04/25/js-7-linux/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/02/06/js-1-spring/</url>
    <content><![CDATA[<p>title: Spring知识点<br>categories: Spring框架<br>tags: Spring5<br>top: xxx<br>date: 2022-02-06 16:04:38</p>
<p><strong>简介：</strong>Spring是目前java后端开发最核心，最基础的框架之一。网络上已经有很多资源，本文的主要目标为总结和整理学习中遇到的知识点，集百家之长和自己的实践，去粗取精。参考的资料有：，<a href="http://c.biancheng.net/spring/spring-abc.html">C语言中文网Spring教程</a>，<a href="http://www.voidme.com/spring">小白教程</a>，<a href="https://github.com/Snailclimb/JavaGuide">Java Guide</a></p>
<span id="more"></span>

<h1 id="一，认识Spring"><a href="#一，认识Spring" class="headerlink" title="一，认识Spring"></a>一，认识Spring</h1><h2 id="1，Spring是什么"><a href="#1，Spring是什么" class="headerlink" title="1，Spring是什么"></a>1，Spring是什么</h2><h3 id="（1），诞生于发展"><a href="#（1），诞生于发展" class="headerlink" title="（1），诞生于发展"></a>（1），诞生于发展</h3><p>早期的 J2EE（Java EE 平台）推崇以 EJB 为核心的开发方式，但这种开发方式在实际的开发过程中存在种种弊端，例如使用复杂、代码臃肿、代码侵入性强、开发周期长、移植难度大等。</p>
<p>Rod Johnson 在其 2002 年编著的畅销书《Expert One-on-One J2EE Design and Development》中，针对 EJB 各种臃肿的结构进行了逐一的分析和否定，并分别以更加简洁的方式进行了替换。这本书影响甚远，后来 Rod Johnson 将代码开源，并把这个新框架并命名为“Spring”，含义为：Spring 像一缕春风一样，扫平传统 J2EE 的寒冬。</p>
<p>2003 年 2 月，Spring 0.9 版本发布，；2004 年 4 月，Spring 1.0 版本正式发布。到目前为止，Spring 已经步入到了第 5 个大版本，也就是我们常说的 Spring 5。</p>
<h3 id="（2），Spring的含义"><a href="#（2），Spring的含义" class="headerlink" title="（2），Spring的含义"></a>（2），Spring的含义</h3><p><strong>广义：</strong>指代Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义：</strong>特指 Spring Framework，通常我们将它称为 Spring 框架。Spring 有两个核心部分： IOC 和 AOP。</p>
<table>
<thead>
<tr>
<th>核心</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>IOC</td>
<td align="center">Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。</td>
</tr>
<tr>
<td>AOP</td>
<td align="center">Aspect Oriented Programming 的简写，译为“面向切面编程”。                                                                           AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。</td>
</tr>
</tbody></table>
<h3 id="（3），特点"><a href="#（3），特点" class="headerlink" title="（3），特点"></a>（3），特点</h3><ul>
<li>方便解耦，简化开发</li>
<li>方便集成各种优秀框架</li>
<li>降低 Java EE API 的使用难度</li>
<li>方便程序的测试</li>
<li>AOP 编程的支持</li>
<li>声明式事务的支持</li>
</ul>
<h2 id="2，Spring体系结构"><a href="#2，Spring体系结构" class="headerlink" title="2，Spring体系结构"></a>2，Spring体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-1.png" alt="js-1-1"></p>
<p>  从上图可以看出，Spring架构中有5个模块，在我们后面的学习中，经常导入的一些包属于哪个模块，要有了解。</p>
<h3 id="（1），Data-Access-x2F-Integration（数据访问／集成）"><a href="#（1），Data-Access-x2F-Integration（数据访问／集成）" class="headerlink" title="（1），Data Access&#x2F;Integration（数据访问／集成）"></a>（1），Data Access&#x2F;Integration（数据访问／集成）</h3><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，这里暂时不深入</p>
<h3 id="（2），Web-模块"><a href="#（2），Web-模块" class="headerlink" title="（2），Web 模块"></a>（2），Web 模块</h3><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件</p>
<h3 id="（3），Core-Container（Spring-的核心容器）"><a href="#（3），Core-Container（Spring-的核心容器）" class="headerlink" title="（3），Core Container（Spring 的核心容器）"></a>（3），Core Container（Spring 的核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。</p>
<ul>
<li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li>
<li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li>
<li>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<h3 id="（4）AOP、Aspects、Instrumentation-和-Messaging"><a href="#（4）AOP、Aspects、Instrumentation-和-Messaging" class="headerlink" title="（4）AOP、Aspects、Instrumentation 和 Messaging"></a>（4）AOP、Aspects、Instrumentation 和 Messaging</h3><p> Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p>
<ul>
<li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li>
</ul>
<h3 id="（5）Test模块"><a href="#（5）Test模块" class="headerlink" title="（5）Test模块"></a>（5）Test模块</h3><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能</p>
<h1 id="二，第一个Spring程序"><a href="#二，第一个Spring程序" class="headerlink" title="二，第一个Spring程序"></a>二，第一个Spring程序</h1><h2 id="1，开发环境"><a href="#1，开发环境" class="headerlink" title="1，开发环境"></a>1，开发环境</h2><h3 id="（1）java-8的安装和IDE的准备"><a href="#（1）java-8的安装和IDE的准备" class="headerlink" title="（1）java 8的安装和IDE的准备"></a>（1）java 8的安装和IDE的准备</h3><p>这里不再赘述。</p>
<h3 id="（2）Spring下载"><a href="#（2）Spring下载" class="headerlink" title="（2）Spring下载"></a>（2）Spring下载</h3><p>Spring 下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a>  根据操作系统下载对应的版本</p>
<p>以5.3.13为例，下载后的目录结构如下，其中：docs 包含 Spring 的 API 文档和开发规范；libs包含开发需要的 jar 包和源码包；schema包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-2.png"></p>
<p>在 libs 目录中，包含了 Spring 框架提供的所有 jar 文件，其中有 4 个 jar 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块，具体如下表所示。</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>spring-core-x.x.xx.jar</td>
<td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td>
</tr>
<tr>
<td>spring-beans-x.x.xx.jar</td>
<td>所有应用都要用到的，它包含访问配置文件、创建和管理 Bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。</td>
</tr>
<tr>
<td>spring-context-x.x.xx.jar</td>
<td>Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等。</td>
</tr>
<tr>
<td>spring-expression-x.x.xx.jar</td>
<td>定义了 Spring 的表达式语言。</td>
</tr>
</tbody></table>
<p><strong>注：</strong>除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息。Apache Common Logging API 下载地址：<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">https://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p>
<h2 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2,hello world"></a>2,hello world</h2><h3 id="（1）新建一个java项目，并将上面提到的5个jar包添加"><a href="#（1）新建一个java项目，并将上面提到的5个jar包添加" class="headerlink" title="（1）新建一个java项目，并将上面提到的5个jar包添加"></a>（1）新建一个java项目，并将上面提到的5个jar包添加</h3><p>两种编译器添加jar包的方式不一样</p>
<p>eclipse：<a href="https://blog.csdn.net/qq_21808961/article/details/81215590">https://blog.csdn.net/qq_21808961/article/details/81215590</a></p>
<p>idea：<a href="https://blog.csdn.net/hwt1070359898/article/details/90517291">https://blog.csdn.net/hwt1070359898/article/details/90517291</a></p>
<h3 id="（2）创建普通类并添加方法"><a href="#（2）创建普通类并添加方法" class="headerlink" title="（2）创建普通类并添加方法"></a>（2）创建普通类并添加方法</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-3.png" alt="js-1-3"></p>
<h3 id="（3）创建Spring配置文件，并配置新建的对象"><a href="#（3）创建Spring配置文件，并配置新建的对象" class="headerlink" title="（3）创建Spring配置文件，并配置新建的对象"></a>（3）创建Spring配置文件，并配置新建的对象</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-4.png" alt="js-1-4"></p>
<h3 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-5.png" alt="js-1-5"></p>
<p><strong>注：</strong>截图来源为尚硅谷Spring教程。</p>
<p><strong>总结：</strong>在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1.xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext(“配置文件路径”)来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。</p>
<h1 id="三，什么是Spring-IOC"><a href="#三，什么是Spring-IOC" class="headerlink" title="三，什么是Spring IOC"></a>三，什么是Spring IOC</h1><h2 id="1，什么是IoC"><a href="#1，什么是IoC" class="headerlink" title="1，什么是IoC"></a>1，什么是IoC</h2><p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p>
<p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p>
<h2 id="2，IoC原理"><a href="#2，IoC原理" class="headerlink" title="2，IoC原理"></a>2，IoC原理</h2><p>首先我们需要了解一下IoC思想的出现和发展，推荐<a href="https://www.cnblogs.com/superjt/p/4311577.html">这篇博文</a></p>
<p>然后，本质上Spring IoC就是将对象创建的过程托管给一个IoC容器来进行，和简单工厂模式类似，但是Spring中采用了反射机制，通过读取配置文件类判断要创建的类。推荐<a href="https://www.cnblogs.com/zhuoqingsen/p/8592951.html">这篇博文</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-6.png" alt="js-1-6"></p>
<p>上图则为Sprin创建对象的一个简单的过程，左上角ApplicationContext接受读取配置文件的内容，并使用getBean方法来实例化对象，此时getBean中的字符串是”person”，匹配到配置文件中id为person的标签，并根据该标签下的其他属性通过反射机制创建该对象，该对象是单例，效率比new 高</p>
<h2 id="3，依赖注入（引）"><a href="#3，依赖注入（引）" class="headerlink" title="3，依赖注入（引）"></a>3，依赖注入（引）</h2><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”</p>
<p>在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    String bid;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，B 中存在一个 A 类型的对象属性 a，此时我们就可以说 B 的对象依赖于对象 a。而依赖注入就是就是基于这种“依赖关系”而产生的</p>
<p>我们知道，控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p>
<p>依赖注入本质上是 <a href="http://c.biancheng.net/spring/attr-injection.html">Spring Bean 属性注入</a>的一种，只不过这个属性是一个对象属性而已</p>
<h2 id="4，IoC容器的两种实现"><a href="#4，IoC容器的两种实现" class="headerlink" title="4，IoC容器的两种实现"></a>4，IoC容器的两种实现</h2><p>IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架中的 IoC 容器有BeanFactory 和 ApplicationContext。</p>
<h3 id="（1），BeanFactory"><a href="#（1），BeanFactory" class="headerlink" title="（1），BeanFactory"></a>（1），BeanFactory</h3><p> IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 。<strong>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</strong></p>
<h3 id="（2）-ApplicationContext："><a href="#（2）-ApplicationContext：" class="headerlink" title="（2） ApplicationContext："></a>（2） ApplicationContext：</h3><p> BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用。<strong>加载配置文件时候就会把在配置文件对象进行创建</strong>，并且它有实现类</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-7.png" alt="js-1-7"></p>
<p>这两个实现类的使用方式有些许不同，具体如下图：</p>
<table>
<thead>
<tr>
<th align="center">实现类</th>
<th align="center"><strong>描述</strong></th>
<th align="center">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClassPathXmlApplicationContext</td>
<td align="center">加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(String configLocation);</td>
</tr>
<tr>
<td align="center">FileSystemXmlApplicationContext</td>
<td align="center">加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new FileSystemXmlApplicationContext(String configLocation);</td>
</tr>
</tbody></table>
<blockquote>
<p>在上表的示例代码中，参数 configLocation 用于指定 Spring 配置文件的名称和位置，如 Beans.xml。</p>
</blockquote>
<h1 id="四，Spring中bean配置"><a href="#四，Spring中bean配置" class="headerlink" title="四，Spring中bean配置"></a>四，Spring中bean配置</h1><h2 id="1，Spring中bean管理——属性注入"><a href="#1，Spring中bean管理——属性注入" class="headerlink" title="1，Spring中bean管理——属性注入"></a>1，Spring中bean管理——属性注入</h2><p>前面说到，Spring中的bean在配置文件中进行了配置，那么属性的设置也在配置文件中进行，下面我们将从普通属性注入（构造器注入，setter注入，短命名空间注入），以及特殊属性注入（内部bean，集合，其他属性）</p>
<h3 id="（1）普通属性–构造器注入"><a href="#（1）普通属性–构造器注入" class="headerlink" title="（1）普通属性–构造器注入"></a>（1）普通属性–构造器注入</h3><p>使用构造函数实现属性注入大致步骤如下：</p>
<ol>
<li><p>在 Bean 中添加一个有参构造函数，构造函数内的每一个参数代表一个需要注入的属性；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，通过 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <constructor-arg> 元素，对构造函数内的属性进行赋值，Bean 的构造函数内有多少参数，就需要使用多少个 <constructor-arg> 元素。</p>
<p>下图就是一个使用构造器注入的例子，student有一个构造器，包含三个参数的初试化过程。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-8.png" alt="js-1-8"></p>
<h3 id="（2）setter注入（重点）"><a href="#（2）setter注入（重点）" class="headerlink" title="（2）setter注入（重点）"></a>（2）setter注入（<strong>重点</strong>）</h3><p>在 Spring 实例化 Bean 的过程中，IoC 容器首先会调用默认的构造方法（无参构造方法）实例化 Bean（Java 对象），然后通过 Java 的反射机制调用这个 Bean 的 setXxx() 方法，将属性值注入到 Bean 中。</p>
<p>使用 setter 注入的方式进行属性注入，大致步骤如下：</p>
<ol>
<li><p>在 Bean 中提供一个默认的无参构造函数（在没有其他带参构造函数的情况下，可省略），并为所有需要注入的属性提供一个 setXxx() 方法；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，使用 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <property> 元素对各个属性进行赋值。</p>
<p>下图为一个使用setter方法注入的例子，student类中的id，name，grade属性都有set方法</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-9.png" alt="js-1-9"></p>
<h3 id="（3）短命名空间注入"><a href="#（3）短命名空间注入" class="headerlink" title="（3）短命名空间注入"></a>（3）短命名空间注入</h3><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a><strong>p命名空间注入</strong></h4><p>p 命名空间是 setter 方式属性注入的一种快捷实现方式。通过它，我们能够以 bean 属性的形式实现 setter 方式的属性注入，而不再使用嵌套的 <property> 元素，以实现简化 Spring 的 XML 配置的目的。</p>
<p>使用 p 命名空间注入依赖时，必须注意以下 3 点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）；</li>
<li>在使用 p 命名空间实现属性注入前，XML 配置的 <beans> 元素内必须先导入 p 命名空间的 XML 约束。</li>
</ul>
<p>下图是一个p标签的例子，其中在xml文件头部必须要导入以下 XML 约束，然后employee类中有empName，dept，empNo属性以及对应对应的get和set方法，dept是一个类。在bean文件的其他部分已经进行了配置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-10.png" alt="js-1-10"></p>
<p><strong>c命名空间注入</strong></p>
<p>c命名空间用的比较少，这里不再介绍</p>
<h2 id="2，Spring中bean管理——内部bean注入"><a href="#2，Spring中bean管理——内部bean注入" class="headerlink" title="2，Spring中bean管理——内部bean注入"></a>2，Spring中bean管理——内部bean注入</h2><h3 id="（1）setter-方式注入内部-Bean"><a href="#（1）setter-方式注入内部-Bean" class="headerlink" title="（1）setter 方式注入内部 Bean"></a>（1）setter 方式注入内部 Bean</h3><p>我们可以通过 setter 方式注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <property> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义。</p>
<p><strong>需要注意的是</strong>，内部 Bean 都是匿名的，不需要指定 id 和 name 的。即使制定了，IoC 容器也不会将它作为区分 Bean 的标识符，反而会无视 Bean 的 Scope 标签。因此内部 Bean 几乎总是匿名的，且总会随着外部的 Bean 创建。内部 Bean 是无法被注入到它所在的 Bean 以外的任何其他 Bean 的。</p>
<p>下图是一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-11.png" alt="js-1-11"></p>
<h3 id="（2）构造函数方式注入内部-Bean"><a href="#（2）构造函数方式注入内部-Bean" class="headerlink" title="（2）构造函数方式注入内部 Bean"></a>（2）构造函数方式注入内部 Bean</h3><p>我们可以通过构造方法注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <constructor-arg> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义，格式如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-12.png" alt="js-1-12"></p>
<h2 id="3，Spring中bean管理——集合注入"><a href="#3，Spring中bean管理——集合注入" class="headerlink" title="3，Spring中bean管理——集合注入"></a>3，Spring中bean管理——集合注入</h2><p>这里的集合包含以下几种</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><list></td>
<td>用于注入 list 类型的值，允许重复</td>
</tr>
<tr>
<td><set></td>
<td>用于注入 set 类型的值，不允许重复</td>
</tr>
<tr>
<td><map></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型</td>
</tr>
<tr>
<td><props></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都是字符串类型</td>
</tr>
</tbody></table>
<h3 id="（1）集合中存放普通属性"><a href="#（1）集合中存放普通属性" class="headerlink" title="（1）集合中存放普通属性"></a>（1）集合中存放普通属性</h3><p>如下图，javaCollection类中，有四个参数，course，list，maps和sets，并且都有对应的get和set方法，那么使用property标签进行赋值，四种类型情况如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-13.png" alt="js-1-13"></p>
<h3 id="（2）集合中存放对象类型"><a href="#（2）集合中存放对象类型" class="headerlink" title="（2）集合中存放对象类型"></a>（2）集合中存放对象类型</h3><p>如下图，配置了三个course的实例，那么在javaCollection类中，进行配置的话，具体方式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-14.png" alt="js-1-14"></p>
<h3 id="（3）把集合注入部分提取出来"><a href="#（3）把集合注入部分提取出来" class="headerlink" title="（3）把集合注入部分提取出来"></a>（3）把集合注入部分提取出来</h3><p>首先是在配置文件中引入名称空间 util，然后util标签写好这个list（或者其他集合），在类中引用即可，这样写的话，可读性更高</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4，Spring中bean管理——其他类型属性注入"><a href="#4，Spring中bean管理——其他类型属性注入" class="headerlink" title="4，Spring中bean管理——其他类型属性注入"></a>4，Spring中bean管理——其他类型属性注入</h2><p>除了普通属性、对象属性（Bean）、集合等属性外，Spring 也能够将其他类型的属性注入到 Bean 中，例如 Null 值、字面量、复合物属性等。</p>
<h3 id="（1）注入Null值"><a href="#（1）注入Null值" class="headerlink" title="（1）注入Null值"></a>（1）注入Null值</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-15.png" alt="js-1-15"></p>
<h3 id="（2）注入空字符串"><a href="#（2）注入空字符串" class="headerlink" title="（2）注入空字符串"></a>（2）注入空字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-16.png" alt="js-1-16"></p>
<h3 id="（3）注入字面量"><a href="#（3）注入字面量" class="headerlink" title="（3）注入字面量"></a>（3）注入字面量</h3><p>在 XML 配置中“&lt;”、“&gt;”、“&amp;”等特殊字符是不能直接保存的，否则 XML 语法检查时就会报错。此时，我们可以通过以下两种方式将包含特殊符号的属性注入 Bean 中。</p>
<p>A，使用转义字符</p>
<p>在 XML 中，特殊符号经过转义可以进行赋值，这个转义的规则和HTML中的非常类似</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-17.png" alt="js-1-17"></p>
<p>B，使用短字符串 <![CDATA[]]> </p>
<p>通过短字符串 <![CDATA[]]> 将包含特殊符号的属性值包裹起来，可以让 XML 解析器忽略对其中内容的解析，以属性原本的样子注入到 Bean 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-18.png" alt="js-1-18"></p>
<p>（4）级联赋值</p>
<p>我们可以在 <bean> 的 <property> 子元素中，为它所依赖的 Bean 的属性进行赋值，这就是所谓的“级联属性赋值”。使用级联属性赋值时，需要注意以下 3点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（默认存在）；</li>
<li>依赖其他 Bean 的类中，必须提供一个它依赖的 Bean 的 getXxx() 方法。</li>
</ul>
<p>如下图，exampleBean中有dependBean属性，最开始是在外面初始化，value值是“依赖Bean内部赋值”，然后是内部进行了级联属性赋值，最终的值更新为“级联属性赋值”</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-19.png" alt="js-1-19"></p>
<h1 id="五，Spring中bean的管理"><a href="#五，Spring中bean的管理" class="headerlink" title="五，Spring中bean的管理"></a>五，Spring中bean的管理</h1><h2 id="1，Spring-Bean的作用域"><a href="#1，Spring-Bean的作用域" class="headerlink" title="1，Spring Bean的作用域"></a>1，Spring Bean的作用域</h2><h3 id="（1）Bean的作用域的类型"><a href="#（1）Bean的作用域的类型" class="headerlink" title="（1）Bean的作用域的类型"></a>（1）Bean的作用域的类型</h3><p>我们可以在 <bean> 元素中添加 scope 属性来配置 Spring Bean 的作用范围。例如，如果每次获取 Bean 时，都需要一个新的 Bean 实例，那么应该将 Bean 的 scope 属性定义为 prototype，如果 Spring 需要每次都返回一个相同的 Bean 实例，则应将 Bean 的 scope 属性定义为 singleton。</p>
<p>Spring中，共有6中类型的作用域（这里我们只需要认识singleton和prototype即可）</p>
<table>
<thead>
<tr>
<th align="left">作用范围</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。  与 singleton 类似，但 singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而一个 Web 应用中可能会存在多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在以上 6 种 Bean 作用域中，除了 singleton 和 prototype 可以直接在常规的 Spring IoC 容器（例如 ClassPathXmlApplicationContext）中使用外，剩下的都只能在基于 Web 的 ApplicationContext 实现（例如 XmlWebApplicationContext）中才能使用，否则就会抛出一个 IllegalStateException 的异常。</p>
<h3 id="（3）-singleton-和-prototype-区别"><a href="#（3）-singleton-和-prototype-区别" class="headerlink" title="（3） singleton 和 prototype 区别"></a>（3） singleton 和 prototype 区别</h3><p>第一 singleton 单实例， prototype 多实例 </p>
<p>第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象</p>
<h2 id="2，Bean的生命周期"><a href="#2，Bean的生命周期" class="headerlink" title="2，Bean的生命周期"></a>2，Bean的生命周期</h2><p>Spring中的bean的生命周期分为5个部分：1)bean的实例化 ；2) Bean的属性赋值；3）bean的初试化  ；4）bean的使用 ；5）bean的销毁</p>
<p>Spring 根据 Bean 的作用域来选择 Bean 的管理方式，</p>
<ul>
<li>对于 singleton 作用域的 Bean 来说，Spring IoC 容器能够精确地控制 Bean 何时被创建、何时初始化完成以及何时被销毁；</li>
<li>对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，然后就将 Bean 的实例交给客户端代码管理，Spring IoC 容器将不再跟踪其生命周期</li>
</ul>
<h3 id="（1）Spring-生命周期流程"><a href="#（1）Spring-生命周期流程" class="headerlink" title="（1）Spring 生命周期流程"></a>（1）Spring 生命周期流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-20.png" alt="js-1-20"></p>
<p>这里每一步都有<a href="http://c.biancheng.net/spring/life-cycle.html">解释</a>，但是这里我们注意到：<u>如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</u></p>
<h3 id="（2）bean的生命周期设置"><a href="#（2）bean的生命周期设置" class="headerlink" title="（2）bean的生命周期设置"></a>（2）bean的生命周期设置</h3><p>有三种方式可以实现控制bean的生命周期，分别是1）通过接口实现；2）通过XML实现；3）使用注解实现。实际使用时，优先级为注解&gt;接口&gt;XML配置，这里我们以注解方式为例，来说明Bean实际的生命周期过程</p>
<p>通过 JSR-250 的 @PostConstruct 和 @PreDestroy 注解，指定 Bean 的生命周期回调方法。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@PostConstruct</td>
<td>指定初始化回调方法，这个方法会在 Spring Bean 被初始化后被调用，执行一些自定义的回调操作。</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>指定销毁回调方法，这个方法会在 Spring Bean 被销毁前被调用，执行一些自定义的回调操作。</td>
</tr>
</tbody></table>
<p>1，在 net.biancheng.c 包下，创建一个名为 AnnotationLifeCycleBean 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//网站名称</span></span><br><span class="line">    <span class="keyword">private</span> String webName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeCycleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步，执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webName</span><span class="params">(String webname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webName = webname;</span><br><span class="line">		System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，在 src 目录下，新建一个 Spring 配置文件 Beans.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过 XML 配置指定生命周期回调方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3，在 net.biancheng.c 包下，创建一个名为 MainApp 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(MainApp.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取 ClassPathXmlApplicationContext 容器</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        LifeCycleBean LifeCycleBean = context.getBean(<span class="string">&quot;LifeCycleBean&quot;</span>, LifeCycleBean.class);</span><br><span class="line">       System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">        <span class="comment">//手动销毁 Bean</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置的话，打印的结果和上面的顺序一样，具体过程如下：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） </p>
<p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p>
<p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法） </p>
<p>（4） bean 可以使用了（对象获取到了） </p>
<p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h3 id="（3），Spring-后置处理器"><a href="#（3），Spring-后置处理器" class="headerlink" title="（3），Spring 后置处理器"></a>（3），Spring 后置处理器</h3><p>BeanPostProcessor 接口也被称为后置处理器，通过该接口可以自定义调用初始化前后执行的操作方法。该接口中包含了两个方法：</p>
<p> 1）postProcessBeforeInitialization() 方法：在 Bean 实例化、属性注入后，初始化前调用。          </p>
<p> 2）postProcessAfterInitialization() 方法：在 Bean 实例化、属性注入、初始化都完成后调用。</p>
<p>当需要添加多个后置处理器实现类时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，取值越大优先级越低。实现了后置处理器后，bean 生命周期有七步：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（ 5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization （6） bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<p>在上一个例子的基础上，我们可以添加处理器，首先是添加一个InitHandler类，并实现BeanPostProcessor, Ordered两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHandler</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注册处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.InitHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么最后的运行结构就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-21.png" alt="js-1-21"></p>
<h2 id="3，bean的自动装配"><a href="#3，bean的自动装配" class="headerlink" title="3，bean的自动装配"></a>3，bean的自动装配</h2><h3 id="（1）背景："><a href="#（1）背景：" class="headerlink" title="（1）背景："></a>（1）背景：</h3><p>在以往的配置中，在 Bean 与 Bean 之间建立依赖关系的行为称为“装配”。在前面的内容中，我们可以在XML中通过<constructor-arg>和 <property>的ref属性，手动维护Bean与Bean之间的依赖关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过 &lt;property&gt; 元素维护 Employee 和 Dept 的依赖关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小规模的依赖关系可以手动操作，但是大规模的依赖，需要使用自动装配功能。</p>
<h3 id="（2）自动装配"><a href="#（2）自动装配" class="headerlink" title="（2）自动装配"></a>（2）自动装配</h3><p>bean 标签属性 autowire，配置自动装配 。autowire 属性常用两个值： </p>
<p>byName  表示按属性名称自动装配，XML 文件中 Bean 的 id 或 name 必须与类中的属性名称相同。</p>
<p>byType 表示按类中对象属性数据类型进行自动装配。即使 XML 文件中 Bean 的 id 或 name 与类中的属性名不               同，只要 Bean 的 class 属性值与类中的对象属性的类型相同，就可以完成自动装配。</p>
<p>对上面两种情况，下面给了对应的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">//。。。省略的其他属性</span></span><br><span class="line">    <span class="comment">//部门信息</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略构造器和其他属性get，set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,由于开启了自动装配，那么employee类在进行属性注入的时候，如果需要配置Dept，容器就会寻找到容器中id=&quot;dept&quot;的类，调用set方法进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,这里是byType进行装配，寻找容器中class属性为Dept的类，调用set进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>byName<br>从Spring环境中获取目标对象时，目标对象中的属性会根据名称在整个Spring环境中查找标签的id属性值。如果有相同的，那么获取这个对象，实现关联。整个Spring环境：表示所有的spring配置文件中查找，那么id不能有重复的。</p>
<p>byType<br>从Spring环境中获取目标对象时，目标对象中的属性会根据类型在整个spring环境中查找标签的class属性值。如果有相同的，那么获取这个对象，实现关联。</p>
<p>如果存在多个相同类型的bean对象，会出错；如果属性为单一类型的数据，那么查找到多个关联对象会发生错误；如果属性为数组或集合(泛型)类型，那么查找到多个关联对象不会发生异常。</p>
</blockquote>
<h2 id="4，基于注解的自动装配"><a href="#4，基于注解的自动装配" class="headerlink" title="4，基于注解的自动装配"></a>4，基于注解的自动装配</h2><p>Spring 通过注解实现自动装配的步骤如下：1，引入依赖；2，开启组件扫描；3，使用注解定义 Bean；4，依赖注入</p>
<h3 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>除了 spring 的四个基础 jar 包和 commons-logging-xxx.jar 外，想要使用注解实现 Spring 自动装配，还需要引入Spring 提供的 spring-aop 的 Jar 包。</p>
<h3 id="（2）开启组件扫描"><a href="#（2）开启组件扫描" class="headerlink" title="（2）开启组件扫描"></a>（2）开启组件扫描</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能，此时会扫描net.baincheng.c包下的所有代码，如果有注解标记的实体，便会装配到容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：在使用 <a href="context:component-scan">context:component-scan</a> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。（也就是第4行添加的内容）</p>
<h3 id="（3）使用注解定义Bean"><a href="#（3）使用注解定义Bean" class="headerlink" title="（3）使用注解定义Bean"></a>（3）使用注解定义Bean</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td>@Repository</td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Service</td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Controller</td>
<td>该注解通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<h3 id="（4）基于注解的方式实现依赖注入"><a href="#（4）基于注解的方式实现依赖注入" class="headerlink" title="（4）基于注解的方式实现依赖注入"></a>（4）基于注解的方式实现依赖注入</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>可以应用到 Bean 的属性变量、setter 方法、非 setter 方法及构造函数等，默认按照 Bean 的类型进行装配。@Autowired注解默认按照 Bean 的类型进行装配，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合 @Qualifier 注解一起使用</td>
</tr>
<tr>
<td>@Resource</td>
<td>作用与 Autowired 相同，区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 的名称进行装配。@Resource 中有两个重要属性：name 和 type。<br>1，Spring 将 name 属性解析为 Bean 的实例名称，type 属性解析为 Bean 的实例类型。<br/>2，如果指定 name 属性，则按实例名称进行装配；<br/>3，如果指定 type 属性，则按 Bean 类型进行装配；<br/>4，如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</td>
</tr>
</tbody></table>
<h3 id="（5）示例"><a href="#（5）示例" class="headerlink" title="（5）示例"></a>（5）示例</h3><p>A，创建Spring-autowire-demo工程，并导入要求的6个包（基本的5个加上Spring-aop-xxxx）</p>
<p>B，创建com.zhao.spring.dao包，并创建名为UserDao的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，创建com.zhao.spring.dao.impl包，在其中创建UserDao的实现类UserDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system.out.print(<span class="string">&quot;进行了Dao层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，创建com.zhao.spring.servcie包，在其中创建UserServcie接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，创建com.zhao.spring.service.impl包，并创建UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> UserServcieImpl implements UserService&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.print(<span class="string">&quot;进行了Service层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>F,创建com.zhao.spring.controller包，并在包下创建UserController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;userController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span><span class="comment">//能实现和@Autowired一样的效果</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServcie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.out;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了Controller层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>G，在src目录下，创建配置文件Beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spirng&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>H，在com.zhao.spring包下，创建MainApplication.class，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        UserController userController = context.getBean(<span class="string">&quot;userController&quot;</span>,UserController.class);</span><br><span class="line">        userController.doStr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I，最后控制台输出应该是下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行了Dao层访问</span><br><span class="line">进行了Service层访问</span><br><span class="line">进行了Controller层访问</span><br></pre></td></tr></table></figure>

<h2 id="5，外部属性文件的配置链接"><a href="#5，外部属性文件的配置链接" class="headerlink" title="5，外部属性文件的配置链接"></a>5，外部属性文件的配置链接</h2><p>在操作数据库时，我们经常会用到连接池对数据库链接进行管理，其中比较常用的就是Druid，有两种方式在Spring配置该数据库连接池。</p>
<p>（1）直接配置数据库信息</p>
<p>首先，引入Druid连接池依赖jar包</p>
<p>然后，在xml文件中配置连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）引入外部属性文件配置数据库连接池</p>
<p>首先，新建jdbc.properties配置文件，文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql://localhost:3306/userDb</span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>然后，把外部 properties 属性文件引入到 spring 配置文件中（注意引入 context 名称空间）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六，AOP面向切面编程"><a href="#六，AOP面向切面编程" class="headerlink" title="六，AOP面向切面编程"></a>六，AOP面向切面编程</h1><h2 id="1，认识AOP"><a href="#1，认识AOP" class="headerlink" title="1，认识AOP"></a>1，认识AOP</h2><h3 id="（1）目标"><a href="#（1）目标" class="headerlink" title="（1）目标"></a>（1）目标</h3><p>假设现在有一个电商系统，我们根据业务使用 OOP（面向对象）思想，将应用划分为多个不同的业务模块，例如订单模块、商品模块等。但是，除了这些功能模块，我们还需要一些一些非业务的通用功能，例如日志管理、权限管理、事务管理、异常管理等。这些功能可能贯穿所有业务模块。</p>
<p>理论上可以将这些非业务功能抽象为公共方法，但是这样代码间的耦合性就会非常高。我们想能不能让业务只专注与业务，添加非业务代码不会影响业务本身。</p>
<h3 id="（2）面向切面编程（AOP）"><a href="#（2）面向切面编程（AOP）" class="headerlink" title="（2）面向切面编程（AOP）"></a>（2）面向切面编程（AOP）</h3><p>AOP 的全称是“Aspect Oriented Programming”，译为“面向切面编程”，和 OOP（面向对象编程）类似，它也是一种编程思想。</p>
<p>与 OOP 中纵向的父子继承关系不同，AOP 是通过横向的抽取机制实现的。它将应用中的一些非业务的通用功能抽取出来单独维护，并通过声明的方式（例如配置文件、注解等）定义这些功能要以何种方式作用在那个应用中，而不是在业务模块的代码中直接调用。</p>
<p>这虽然设计公共函数有几分类似，但传统的公共函数除了在代码直接硬调用之外并没有其他手段。AOP 则为这一问题提供了一套灵活多样的实现方法（例如 Proxy 代理、拦截器、字节码翻译技术等），可以在无须修改任何业务代码的基础上完成对这些通用功能的调用和修改。</p>
<h3 id="（3）AOP实现（框架）"><a href="#（3）AOP实现（框架）" class="headerlink" title="（3）AOP实现（框架）"></a>（3）AOP实现（框架）</h3><table>
<thead>
<tr>
<th align="left">AOP 框架</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Spring AOP</td>
<td>是一款基于 AOP 编程的框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。  Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。Spring AOP 支持 2 种代理方式，分别是基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理。</td>
</tr>
<tr>
<td align="left">AspectJ</td>
<td>是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。  AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。</td>
</tr>
</tbody></table>
<h3 id="（4）AOP术语"><a href="#（4）AOP术语" class="headerlink" title="（4）AOP术语"></a>（4）AOP术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint（连接点）</td>
<td>AOP 的核心概念，指的是程序执行期间明确定义的一个点，例如方法的调用、类初始化、对象实例化等。 <strong>通俗说</strong>，类里面的可以被增强的方法（or变量），称之为连接点。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>又称切点，指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。<strong>通俗说</strong>，就是实际被增强的方法。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>指拦截到 Joinpoint 之后要执行的代码，即对切入点增强的内容。<strong>通俗说</strong>，实际增强的逻辑部分就称为通知</td>
</tr>
<tr>
<td>Target（目标）</td>
<td>指代理的目标对象，通常也被称为被通知（advised）对象。</td>
</tr>
<tr>
<td>Weaving（织入）</td>
<td>指把增强代码应用到目标对象上，生成代理对象的过程。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>指生成的代理对象。</td>
</tr>
<tr>
<td>Aspect（切面）</td>
<td>切面是切入点（Pointcut）和通知（Advice）的结合。<strong>通俗说，</strong>就是把通知应用到切入点的过程</td>
</tr>
</tbody></table>
<h2 id="2，Spring-AOP"><a href="#2，Spring-AOP" class="headerlink" title="2，Spring AOP"></a>2，Spring AOP</h2><h3 id="（1）Spring-AOP的代理机制"><a href="#（1）Spring-AOP的代理机制" class="headerlink" title="（1）Spring AOP的代理机制"></a>（1）Spring AOP的代理机制</h3><p>Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。</p>
<p>Spring AOP 的底层是通过以下 2 种动态代理机制，为目标对象（Target Bean）执行横向织入的。</p>
<table>
<thead>
<tr>
<th>代理技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 动态代理</td>
<td>Spring AOP 默认的动态代理方式，若目标对象实现了若干接口，Spring 使用 JDK 的 java.lang.reflect.Proxy 类进行代理。(也就是通过接口来实现一个对象来进行操作)</td>
</tr>
<tr>
<td>CGLIB 动态代理</td>
<td>若目标对象没有实现任何接口，Spring 则使用 CGLIB 库生成目标对象的子类，以实现对目标对象的代理。（创建一个类的子类来进行增强操作）</td>
</tr>
</tbody></table>
<p>对于使用JDK的 java.lang.reflect.Proxy 类进行代理，主要是考Proxy类的newProxyInstance 方法实现，该方法有三个参数，<u>第一参数</u>，类加载器；<u>第二参数</u>，增强方法所在的类，这个类实现的接口，支持多个接口；<u>第三参数</u>，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance (ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h);</span><br></pre></td></tr></table></figure>

<p>下面就贴一段代码帮助理解这样的代理具体是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，创建接口，定义方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2,创建接口实现类，实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3,使用Proxy类创建接口代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="comment">//这里的dao也就是加了增强逻辑了的</span></span><br><span class="line">        <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4,这里是代理对象的逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先这个有参构造器，是用来接受需要创建代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里填写增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="comment">//执行方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法执行（也就是调用原来的增强的方法）</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）Spring-AOP连接点"><a href="#（2）Spring-AOP连接点" class="headerlink" title="（2）Spring AOP连接点"></a>（2）Spring AOP连接点</h3><p>Spring AOP 并没有像其他 AOP 框架（例如 AspectJ）一样提供了完成的 AOP 功能，它是 Spring 提供的一种简化版的 AOP 组件。其中最明显的简化就是，Spring AOP 只支持一种连接点类型：方法调用。您可能会认为这是一个严重的限制，但实际上 Spring AOP 这样设计的原因是为了让 Spring 更易于访问。</p>
<p>方法调用连接点是迄今为止最有用的连接点，通过它可以实现日常编程中绝大多数与 AOP 相关的有用的功能。如果需要使用其他类型的连接点（例如成员变量连接点），我们可以将 Spring AOP 与其他的 AOP 实现一起使用，最常见的组合就是 Spring AOP + ApectJ。 </p>
<h3 id="（3）Spring-AOP通知类型"><a href="#（3）Spring-AOP通知类型" class="headerlink" title="（3）Spring AOP通知类型"></a>（3）Spring AOP通知类型</h3><table>
<thead>
<tr>
<th>通知类型</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
<td>在目标方法执行前实施增强。</td>
</tr>
<tr>
<td>后置通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行后实施增强。</td>
</tr>
<tr>
<td>后置返回通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行完成，并返回一个返回值后实施增强。</td>
</tr>
<tr>
<td>环绕通知</td>
<td>org.aopalliance.intercept.MethodInterceptor</td>
<td>在目标方法执行前后实施增强。</td>
</tr>
<tr>
<td>异常通知</td>
<td>org.springframework.aop.ThrowsAdvice</td>
<td>在方法抛出异常后实施增强。</td>
</tr>
<tr>
<td>引入通知</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
<td>在目标类中添加一些新的方法和属性。</td>
</tr>
</tbody></table>
<h2 id="3，Spring集成AspectJ"><a href="#3，Spring集成AspectJ" class="headerlink" title="3，Spring集成AspectJ"></a>3，Spring集成AspectJ</h2><p>Spring AOP 是一个简化版的 AOP 实现，并没有提供完整版的 AOP 功能。通常情况下，Spring AOP 是能够满足我们日常开发过程中的大多数场景的，但在某些情况下，我们可能需要使用 Spring AOP 范围外的某些 AOP 功能。例如 Spring AOP 仅支持执行公共（public）非静态方法的调用作为连接点，如果我们需要向受保护的（protected）或私有的（private）的方法进行增强，此时就需要使用功能更加全面的 AOP 框架来实现，其中使用最多的就是 AspectJ。</p>
<p>AspectJ 是一个基于 Java 语言的全功能的 AOP 框架，它并不是 Spring 组成部分，是一款独立的 AOP 框架。但由于 AspectJ 支持通过 Spring 配置 AspectJ 切面，因此它是 Spring AOP 的完美补充，通常情况下，我们都是将 AspectJ 和 Spirng 框架一起使用，简化 AOP 操作。</p>
<h3 id="（1）引入依赖-1"><a href="#（1）引入依赖-1" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>使用AspectJ需要引入一些依赖，这些包可以自行下载（红色为必须新增的，绿色则看情况）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-22.png" alt="js-1-22"></p>
<h3 id="（2）基于XML的AOP开发"><a href="#（2）基于XML的AOP开发" class="headerlink" title="（2）基于XML的AOP开发"></a>（2）基于XML的AOP开发</h3><p><u>A，引入aop命名空间（在xml文件头中引入）</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>B，定义切面</u></p>
<p>在 Spring 配置文件中，使用 &lt;aop:aspect&gt; 元素定义切面。该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 &lt;aop:aspect&gt; 之前需要先定义一个普通的 Spring Bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用来定义该切面的唯一标识名称，ref 用于引用普通的 Spring Bean。</p>
<p><u>C，定义切入点&lt;aop:pointcut&gt;</u> </p>
<p>&lt;aop:pointcut&gt; 用来定义切入点，用来表示对哪个类中的那个方法进行增强。它既可以在 &lt;aop:pointcut&gt; 元素中使用，也可以在&lt;aop:pointcut&gt; 元素下使用。</p>
<ul>
<li>当&lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享；</li>
<li>当 &lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素时，表示该切入点只对当前切面有效。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* net.biancheng.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式。</p>
<p>execution 的语法格式格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符] [返回值类型] [类的完全限定名] [方法名称]([参数列表]) </span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>返回值类型、方法名、参数列表是必须配置的选项，而其它参数则为可选配置项。</li>
<li>返回值类型：<code>*</code>表示可以为任何返回值。如果返回值为对象，则需指定全路径的类名。</li>
<li>类的完全限定名：指定包名 + 类名。</li>
<li>方法名：<code>*</code>代表所有方法，<code>set*</code> 代表以 set 开头的所有方法。</li>
<li>参数列表：<code>(..)</code>代表所有参数；<code>(*)</code>代表只有一个参数，参数类型为任意类型；<code>(*,String)</code>代表有两个参数，第一个参数可以为任何值，第二个为 String 类型的值。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-23.png" alt="js-1-23"></p>
<p><u>D，定义通知</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异常通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最终通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    .... </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>E，示例</u></p>
<p>E-1. 新建一个名为 my-spring-asepctj-demo 的 Java 项目，并将以下依赖 Jar 包导入到该项目中。</p>
<ul>
<li>commons-logging-1.2.jar</li>
<li>spring-aop-5.3.13.jar</li>
<li>spring-aspects-5.3.13.jar</li>
<li>spring-beans-5.3.13.jar</li>
<li>spring-context-5.3.13.jar</li>
<li>spring-core-5.3.13.jar</li>
<li>spring-expression-5.3.13.jar</li>
<li>aspectjweaver-1.9.7.jar</li>
</ul>
<p>E-2. 在 com.zhao.spring.dao 包下，创建一个名为 OrderDao 的接口，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-3.在 com.zhao.spring.dao.impl 包下，创建 OrderDao 的实现类 OrderDaoImpl，这是一个被增强类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 add() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 delete() 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-4. 在com.zhao.spring 包下，创建一个名为 MyOrderAspect 的类，这是一个增强类，用来实现一些增强方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderAspect</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---前……&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---后……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常增强…… 异常信息为：&quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置返回增强…… 方法返回值为：&quot;</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-5. 在 src 目录下创建一个 Spring 配置文件 Beans2.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义 Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.dao.impl.OrderDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myOrderAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.MyOrderAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开始配置增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面是两个切面，前一个代表了对add方法进行增强，后一个代表对OrderDao类的所有方法进行增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;beforePointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.add(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;afterPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面的这个aop:aspect使用了myOrderAspect增强类中的方法-&gt;</span></span><br><span class="line"><span class="comment">        &lt;aop:aspect ref=&quot;myOrderAspect&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;!--前置增强，这里使用before方法对add方法进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--后置返回增强，这个使用afterReturning方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterReturnPointCut&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">returning</span>=<span class="string">&quot;returnValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最终通知，这个使用after方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterPointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--环绕通知，这个使用aroud方法对add进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>E-6. 在 net.biancheng.c 包下，创建一个名 MainApp 的类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans2.xml&quot;</span>);</span><br><span class="line">        OrderDao orderDao = context2.getBean(<span class="string">&quot;orderDao&quot;</span>, OrderDao.class);</span><br><span class="line">        orderDao.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        orderDao.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-7. 执行 MainApp 中的 main 方法，控制台输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置增强……</span><br><span class="line">环绕增强---前……</span><br><span class="line">正在执行 OrderDao 中的 add() 方法</span><br><span class="line">环绕增强---后……</span><br><span class="line">最终增强……</span><br><span class="line">====</span><br><span class="line">正在执行 OrderDao 中的 delete() 方法</span><br><span class="line">后置返回增强…… 方法返回值为：1</span><br><span class="line">最终增强……</span><br></pre></td></tr></table></figure>

<h3 id="（3）基于AspectJ注解的AOP开发"><a href="#（3）基于AspectJ注解的AOP开发" class="headerlink" title="（3）基于AspectJ注解的AOP开发"></a>（3）基于AspectJ注解的AOP开发</h3><p>如果所有的配置都是在xml文件中进行，未免会使得配置文件变得非常臃肿。而AspectJ 框架为 AOP 开发提供了一套 @AspectJ 注解。它允许我们直接在 Java 类中通过注解的方式对切面（Aspect）、切入点（Pointcut）和增强（Advice）进行定义，Spring 框架可以根据这些注解生成 AOP 代理。这些注解主要是以下几种类别：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>用于定义一个切面。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>用于定义一个切入点。</td>
</tr>
<tr>
<td>@Before</td>
<td>用于定义前置通知，相当于 BeforeAdvice。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>用于定义后置通知，相当于 AfterReturningAdvice。</td>
</tr>
<tr>
<td>@Around</td>
<td>用于定义环绕通知，相当于 MethodInterceptor。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>用于定义抛出通知，相当于 ThrowAdvice。</td>
</tr>
<tr>
<td>@After</td>
<td>用于定义最终通知，不管是否异常，该通知都会执行。</td>
</tr>
</tbody></table>
<p>使用时，需要设置的几个点如下：</p>
<p><u>A，启用@AspectJ注解支持（两种形式）</u></p>
<p>1）使用 Java 配置类启用</p>
<p>我们可以在 Java 配置类（标注了 @Configuration 注解的类）中，使用 @EnableAspectJAutoProxy 和 @ComponentScan 注解启用 @AspectJ 注解支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;xxx&quot;)</span> <span class="comment">//注解扫描,扫描你想要管理的包及其下面的文件</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启 AspectJ 的自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）基于XML配置启用（<strong>！常用</strong>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启AspectJ 自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>B，定义切面（使用@Aspect注解）</u></p>
<p>一般使用两个注解来顶一个切面（切面一般是增强类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 定义成 Bean，这样再上一步被扫描后，该类就会作为一个bean被Spring管理</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>C，定义切点（使用@Pointcut切点）</u></p>
<p>在 AspectJ 中，我们可以使用 @Pointcut 注解用来定义一个切点。其中execution的格式参考上一节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意！！！方法必须是private，返回值类型为 void，名称自定义，没有参数</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(*net.biancheng..*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我除了可以通过切入点表达式（execution）直接对切点进行定义外，还可以通过切入点方法的名称来引用其他的切入点。在使用方法名引用其他切入点时，还可以使用“&amp;&amp;”、“||”和“!”等表示“与”、“或”、“非”的含义，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 net.biancheng.c.dao包下 UserDao 类中的 get() 方法定义为一个切点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 net.biancheng.c.dao包下 UserDao 类中的 delete() 方法定义为一个切点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.delete(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 除了 net.biancheng.c.dao包下 UserDao 类中 get() 方法和 delete() 方法外，其他方法都定义为切点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ！ 表示 非 ，即 &quot;不是&quot; 的含义，求补集</span></span><br><span class="line"><span class="comment">* * &amp;&amp; 表示 与，即 ”并且“ ，求交集</span></span><br><span class="line"><span class="comment">* || 表示 或，即 “或者”，求并集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;!pointCut1() &amp;&amp; !pointCut2()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>D，定义通知</u></p>
<p>AspectJ 为我们提供了以下 6 个注解，来定义 6 种不同类型的通知（Advice），如下表。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Before</td>
<td>用于定义前置通知，相当于 BeforeAdvice。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>用于定义后置通知，相当于 AfterReturningAdvice。</td>
</tr>
<tr>
<td>@Around</td>
<td>用于定义环绕通知，相当于 MethodInterceptor。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>用于定义抛出通知，相当于 ThrowAdvice。</td>
</tr>
<tr>
<td>@After</td>
<td>用于定义最终通知，不管是否异常，该通知都会执行。</td>
</tr>
<tr>
<td>@DeclareParents</td>
<td>用于定义引介通知，相当于 IntroductionInterceptor（不要求掌握）。</td>
</tr>
</tbody></table>
<p>以上这些通知注解中都有一个 value 属性，这个 value 属性的取值就是这些通知（Advice）作用的切点（PointCut），它既可以是切入点表达式，也可以是切入点的引用（切入点对应的方法名称），示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.delete(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Pointcut(value =&quot;!pointCut1() &amp;&amp; !pointCut2()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用切入点引用</span></span><br><span class="line"><span class="meta">@Before(&quot;MyAspect.pointCut3()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕增强……&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用切入点表达式</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot; ,returning = &quot;returnValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法返回值为：&quot;</span>+returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>E，示例</u></p>
<p>E-1，在com.zhao.dao包下创建UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-2，在com.zhao.dao.impl包下创建UserDaoImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span><span class="comment">//将这个类交给Spring容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行add方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行delete方法&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-3，在Spring的配置文件中开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启AspectJ 自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>E-4,在com.zhao.aspect包下创建MyAspect切面类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册成 Bean</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span></span>&#123;</span><br><span class="line">    <span class="comment">//对于add方法，我们使用注解直接对这个切点进行增强</span></span><br><span class="line">    <span class="meta">@Before(&quot;excution(* com.zhao.dao.UserDao.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinpoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于delete方法，我们使用先定义切入点，在引用切入点的方式进行增强，这样的增强方式能更加灵活的设置要增强的       方法</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.zhao.dao.UserDao.delete(..)))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(MyAspect.pointCut1())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强……1&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强……2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-5,在com.zhao包下，创建MainApp类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        UserDao userDao = context.getBean(<span class="string">&quot;userDao&quot;</span>, UserDao.class);</span><br><span class="line">        userDao.add();</span><br><span class="line">        userDao.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-6,打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置增强……execution(void com.zhao.dao.UserDao.add())</span><br><span class="line">正在执行 UserDao 的 add 方法</span><br><span class="line">环绕增强……1</span><br><span class="line">正在执行 UserDao 的 delete 方法</span><br><span class="line">环绕增强……2</span><br></pre></td></tr></table></figure>

<h1 id="七，Spring集成JDBC"><a href="#七，Spring集成JDBC" class="headerlink" title="七，Spring集成JDBC"></a>七，Spring集成JDBC</h1><h2 id="1，Spring配置使用JdbcTemplate"><a href="#1，Spring配置使用JdbcTemplate" class="headerlink" title="1，Spring配置使用JdbcTemplate"></a>1，Spring配置使用JdbcTemplate</h2><h3 id="（1）引入"><a href="#（1）引入" class="headerlink" title="（1）引入"></a>（1）引入</h3><p>Spring 提供了一个 Spring JDBC 模块，它对 JDBC API 进行了封装，其的主要目的降低 JDBC API 的使用难度，以一种更直接、更简洁的方式使用 JDBC API。</p>
<p>使用 Spring JDBC，开发人员只需要定义必要的参数、指定需要执行的 SQL 语句，即可轻松的进行 JDBC 编程，对数据库进行访问。Spring JDBC 提供了多个实用的数据库访问工具，以简化 JDBC 的开发，其中使用最多就是 JdbcTemplate。</p>
<h3 id="（2）JdbcTemplate中的方法介绍"><a href="#（2）JdbcTemplate中的方法介绍" class="headerlink" title="（2）JdbcTemplate中的方法介绍"></a>（2）JdbcTemplate中的方法介绍</h3><p>JdbcTemplate 的全限定命名为 org.springframework.jdbc.core.JdbcTemplate，配置必要的参数后，便可以使用它来实现和数据库的交互。它提供了大量的查询和更新数据库的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String sql)</td>
<td>（1）用于执行新增、更新、删除等语句；sql：需要执行的 SQL 语句；args 表示需要传入到 SQL 语句中的参数。</td>
</tr>
<tr>
<td>public int update(String sql,Object… args)</td>
<td>同（1）</td>
</tr>
<tr>
<td>public void execute(String sql)</td>
<td>（2）可以执行任意 SQL，一般用于执行 DDL 语句； sql：需要执行的 SQL 语句；action 表示执行完 SQL 语句后，要调用的函数。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>同（2）</td>
</tr>
<tr>
<td>public <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</td>
<td>（3）用于执行查询语句；  sql：需要执行的 SQL 语句； rowMapper：用于确定返回的集合（List）的类型； args：表示需要传入到 SQL 语句的参数。</td>
</tr>
<tr>
<td>public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</td>
<td>同（3）</td>
</tr>
<tr>
<td>public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)</td>
<td>用于批量执行新增、更新、删除等语句； sql：需要执行的 SQL 语句；argTypes：需要注入的 SQL 参数的 JDBC 类型；batchArgs：表示需要传入到 SQL 语句的参数。</td>
</tr>
</tbody></table>
<p><strong>补充</strong>：</p>
<p>DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段，数据库，表，列，索引等数据库对象。常用的语句关键字主要包括create,drop,alter等。<br>        DML（Data Manipulation Language）语句：数据操纵语句，用于添加，删除，更新和查询数据库记录，并检查数据完整性。常用的语句关键字主要包括insert，delete,update,select等。<br>        DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库，表，字段，用户的访问权限和安全级别。主要的语句关键字包括grant,revoke等。</p>
<h3 id="（3）使用示例"><a href="#（3）使用示例" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><p>步骤：1）创建数据库表；2）引入包；3）创建jdbc.properties；4）创建Beans.xml，开启组件扫描，进行数据库配置，以及配置JdbcTemplate Bean；5）新建bean，数据访问Dao接口，Dao接口实现类，以及servcie，然后主程序中使用。</p>
<p><u>A，创建数据库表</u></p>
<p>在Mysql语句中执行以下语句创建User表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;用户 ID&#x27;,</span><br><span class="line">  `user_name` varchar(255) DEFAULT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `status` varchar(255) DEFAULT NULL COMMENT &#x27;用户状态&#x27;,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><u>B，创建my-spring-jdbc-demo，导入以下包</u></p>
<p><img src="C:\Users\zhao\Desktop\js-1-24.png" alt="js-1-24"></p>
<p><u>C，在项目src目录下创建 jdbc.properties，对数据库链接进行配置</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_jdbc_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<p><u>D，在src目录下创建配置文件 Beans.xml（注意2~8行命名空间增加的内容）</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入 jdbc.properties 中的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据源 Bean，&gt;</span></span><br><span class="line"><span class="comment">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;!--下面四个参数根据实际情况调整--&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--数据库连接地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义JdbcTemplate Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将数据源的 Bean 注入到 JdbcTemplate 中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在以上配置中，我们共定义了两个 Bean，</p>
<ul>
<li>dataSource 为数据库连接池对象的 Bean。</li>
<li>jdbcTemplate 则为 JdbcTemplate 的 Bean，它由一个名为 datasSource 的属性。</li>
</ul>
<p>Spring 默认使用 DriverManagerDataSource 对数据库连接池进行管理，我们可以在 Spring 的 XML 配置文件中定义 DriverManagerDataSource 的 Bean，并注入到 JdbcTempate 的 Bean 中。</p>
<p>  <u>E，在com.zhao.entity包下，创建User.java</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">//下面省略了对应的get/set,toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>F，在com.zhao.dao下，创建UserDao接口</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;<span class="comment">//add,delete和update用的方法一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(User user)</span></span>;<span class="comment">//getUser和count用的方法一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getList</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>G，在com.zhao.dao.impl包下，创建 UserDao 的实现类 UserDaoImpl</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE `user` SET status=? WHERE user_name=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, user.getStatus(), user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT COUNT(*) FROM `user` where `status`=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class, user.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getList</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM `user` where `status`=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class), user.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT into `user` (`user`.user_name,`user`.`status`) VALUES(?,?);&quot;</span>;</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>H，在 com.zhao.service 包下，创建一个名为 UserService 的 Service 接口</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>I,在 com.zhao.service.impl 包下，创建 UserService 的实现类 UserServiceImpl</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.update(user);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.count(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getList(user);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">        userDao.batchAddUser(batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>J,在 com.zhao 包下，创建一个名为 MainApp 的类</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        UserService userService = context2.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">      </span><br><span class="line">       </span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        user1.setStatus(<span class="string">&quot;在线&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> u = userService.updateUser(user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户成功&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Object[] o1 = &#123;<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        Object[] o2 = &#123;<span class="string">&quot;小龙&quot;</span>, <span class="string">&quot;离线&quot;</span>&#125;;</span><br><span class="line">        Object[] o3 = &#123;<span class="string">&quot;小林&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        Object[] o4 = &#123;<span class="string">&quot;小李&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        batchArgs.add(o1);</span><br><span class="line">        batchArgs.add(o2);</span><br><span class="line">        batchArgs.add(o3);</span><br><span class="line">        batchArgs.add(o4);</span><br><span class="line">        userService.batchAddUser(batchArgs);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量增加完毕&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        User user2 = <span class="keyword">new</span> User();</span><br><span class="line">        user2.setStatus(<span class="string">&quot;在线&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i1 = userService.countUser(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;在线用户的个数为：&quot;</span> + i1);</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList = userService.getUserList(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;在线用户列表查询成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user4 : userList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户 ID:&quot;</span> + user4.getUserId() + <span class="string">&quot;，用户名：&quot;</span> + user4.getUserName() + <span class="string">&quot;，状态：&quot;</span> + user4.getStatus());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2，Spring事务管理"><a href="#2，Spring事务管理" class="headerlink" title="2，Spring事务管理"></a>2，Spring事务管理</h2><h3 id="（1）事务的特性"><a href="#（1）事务的特性" class="headerlink" title="（1）事务的特性"></a>（1）事务的特性</h3><p>事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。</p>
<ul>
<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li>
<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>
<li>持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>
</ul>
<h3 id="（2）事务的隔离级别"><a href="#（2）事务的隔离级别" class="headerlink" title="（2）事务的隔离级别"></a>（2）事务的隔离级别</h3><p><a href="http://blog.itpub.net/26736162/viewspace-2638951/">点击这里</a> 可查看详细说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-25.png" alt="js-1-25"></p>
<p>在 SQL 标准中定义了 4 种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<p> SQL 标准定义的四个隔离级别为： Read Uncommitted （ 未提交读 ） 、 Read Committed （提交读）、 Repeatable Read （可重复读）、 Serializable （可串行化） ，隔离级别越高，并发性能越低。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-26.png" alt="js-1-26"></p>
<p><strong>Spring事务传播机制</strong></p>
<p>@Transactional(propagation&#x3D;Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br>        @Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务<br>        @Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br>        @Transactional(propagation&#x3D;Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常<br>        @Transactional(propagation&#x3D;Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br>        @Transactional(propagation&#x3D;Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</p>
<p><a href="https://blog.csdn.net/qq_26323323/article/details/81908955">参考示例</a></p>
<h3 id="（3）PlatformTransactionManager接口（事务管理器）"><a href="#（3）PlatformTransactionManager接口（事务管理器）" class="headerlink" title="（3）PlatformTransactionManager接口（事务管理器）"></a>（3）PlatformTransactionManager接口（事务管理器）</h3><p>Spring 并不会直接管理事务，而是通过事务管理器对事务进行管理的。</p>
<p>在 Spring 中提供了一个 org.springframework.transaction.PlatformTransactionManager 接口，这个接口被称为 Spring 的事务管理器，其源码和三个接口的功能如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//用于获取事务的状态信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//用于提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//	用于回滚事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该接口对于不同的持久化框架或平台有不同的实现，对于JDBC来说，实现类是org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）TransactionDefinition-接口"><a href="#（4）TransactionDefinition-接口" class="headerlink" title="（4）TransactionDefinition 接口"></a>（4）TransactionDefinition 接口</h3><p>Spring 将 XML 配置中的事务信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。</p>
<p>TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;<span class="comment">//获取事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;<span class="comment">//获取事务的隔离级别</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取事务的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;<span class="comment">//获取事务的超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;<span class="comment">//获取事务是否只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）TransactionStatus-接口"><a href="#（5）TransactionStatus-接口" class="headerlink" title="（5）TransactionStatus 接口"></a>（5）TransactionStatus 接口</h3><p>TransactionStatus 接口提供了一些简单的方法，来控制事务的执行、查询事务的状态，接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;<span class="comment">//获取是否是新事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;<span class="comment">//获取是否存在保存点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;<span class="comment">//设置事务回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;<span class="comment">//获取事务是否回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;<span class="comment">//获取事务是否完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3，Spring基于XML实现事务管理"><a href="#3，Spring基于XML实现事务管理" class="headerlink" title="3，Spring基于XML实现事务管理"></a>3，Spring基于XML实现事务管理</h2><p>XML似乎用的不多（因为注解式更加简洁），日后再补充</p>
<h2 id="4，Spring基于注解实现事务管理"><a href="#4，Spring基于注解实现事务管理" class="headerlink" title="4，Spring基于注解实现事务管理"></a>4，Spring基于注解实现事务管理</h2><h3 id="（1）引入tx命名空间"><a href="#（1）引入tx命名空间" class="headerlink" title="（1）引入tx命名空间"></a>（1）引入tx命名空间</h3><p>Spring 提供的声明式事务管理是依赖于 Spring AOP 实现的，因此我们在 XML 配置文件中还应该添加与 aop 命名空间相关的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）在bean的配置文件中开启注解事务"><a href="#（2）在bean的配置文件中开启注解事务" class="headerlink" title="（2）在bean的配置文件中开启注解事务"></a>（2）在bean的配置文件中开启注解事务</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;tx:annotation-driven&gt; 也需要通过 transaction-manager 属性来定义一个事务管理器，这个参数的取值默认为transactionManager。如果我们使用的事务管理器的 id 与默认值相同，则可以省略对该属性的配置，形式如下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-Transactional-注解"><a href="#3-使用-Transactional-注解" class="headerlink" title="(3)使用 @Transactional 注解"></a>(3)使用 @Transactional 注解</h3><p>@Transactional 注解是 Spring 声明式事务编程的核心注解，该注解既可以在类上使用，也可以在方法上使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若 @Transactional 注解在类上使用，则表示类中的所有方法都支持事务；若 @Transactional 注解在方法上使用，则表示当前方法支持事务。Spring 在容器中查找所有使用了 @Transactional 注解的 Bean，并自动为它们添加事务通知，通知的事务属性则是通过 @Transactional 注解的属性来定义的。</p>
<p>@Transactional 注解包含多个属性，其中常用属性如下表。</p>
<table>
<thead>
<tr>
<th>事务属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>propagation</td>
<td>指定事务的传播行为。</td>
</tr>
<tr>
<td>isolation</td>
<td>指定事务的隔离级别。</td>
</tr>
<tr>
<td>read-only</td>
<td>指定是否为只读事务。</td>
</tr>
<tr>
<td>timeout</td>
<td>表示超时时间，单位为“秒”；声明的事务在指定的超时时间后，自动回滚，避免事务长时间不提交会回滚导致的数据库资源的占用。</td>
</tr>
<tr>
<td>rollback-for</td>
<td>指定事务对于那些类型的异常应当回滚，而不提交。</td>
</tr>
<tr>
<td>no-rollback-for</td>
<td>指定事务对于那些异常应当继续运行，而不回滚。</td>
</tr>
</tbody></table>
<h3 id="4）示例"><a href="#4）示例" class="headerlink" title="(4）示例"></a>(4）示例</h3><p>A，新建数据库表</p>
<p>有三个表，简单说一下：1）<strong>account</strong> ：id, user_id, total, used, residue。2）<strong>order</strong> : id, order_id, user_id, product_id, count, money, status。3）<strong>storage</strong> : id, product_id, total, used, residue。</p>
<p>B，导入依赖</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-27.png" alt="js-1-27"></p>
<p>C，在com.zhao.entity包下，创建名为Order的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//订单 id</span></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="comment">//用户 id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">//商品 id</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">//订单商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">//订单金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">    <span class="comment">//订单状态</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，在com.zhao.entity包下，创建名为Account的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//用户 id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">//账户总金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line">    <span class="comment">//已用账户金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal used;</span><br><span class="line">    <span class="comment">//剩余账户金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal residue;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E,在com.zhao.entity下，创建名为Storage的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//商品 id</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">//商品库存总数</span></span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line">    <span class="comment">//已用商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer used;</span><br><span class="line">    <span class="comment">//剩余商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer residue;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>F，在com.zhao.dao下，创建OrderDao，AccountDao和StorageDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">    <span class="comment">//修改订单状态,将订单状态从未完成（0）修改为已完成（1）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateOrderStatus</span><span class="params">(String orderId, Integer status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">//根据用户查询账户金额</span></span><br><span class="line">    <span class="function">Account <span class="title">selectByUserId</span><span class="params">(String userId)</span></span>;</span><br><span class="line">   <span class="comment">//扣减账户金额</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decrease</span><span class="params">(String userId, BigDecimal money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StorageDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询商品的库存</span></span><br><span class="line">    <span class="function">Storage <span class="title">selectByProductId</span><span class="params">(String productId)</span></span>;</span><br><span class="line">    <span class="comment">//扣减商品库存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decrease</span><span class="params">(Storage record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>G,进行数据库和Beans.xml的配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//在src目录下，创建jdbc.properties配置文件，内容如下</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring-tx-db</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在src下创建Beans.xml，其中按顺序进行操作：1）引入命名空间；2）开启组件扫描；3）引入jdbc的配置并定义数据源bean</p>
<p>4）定义jdbcTemplate Bean（注入数据源bean） 5）配置事务管理器并开启事务注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--引入 jdbc.properties 中的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据源 Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义 JdbcTemplate Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将数据源的 Bean 注入到 JdbcTemplate 中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>H,在com.zhao.dao.impl包下，创建上面接口的三个实现类：OrderDaoImpl，AccountDaoImpl和StorageDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into `order` (order_id,user_id, product_id, `count`, money, status) values (?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, order.getOrderId(), order.getUserId(), order.getProductId(), order.getCount(), order.getMoney(), order.getStatus());</span><br><span class="line">        <span class="keyword">return</span> update;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrderStatus</span><span class="params">(String orderId, Integer status)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot; update `order`  set status = 1 where order_id = ? and status = ?;&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, orderId, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">selectByUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;  select * from account where user_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">(String userId, BigDecimal money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE account SET residue = residue - ?, used = used + ? WHERE user_id = ?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, money, money, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageDaoImpl</span> <span class="keyword">implements</span> <span class="title">StorageDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Storage <span class="title">selectByProductId</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select *   from storage where product_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Storage&gt;(Storage.class), productId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">(Storage record)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot; update storage set  used =? ,residue=? where product_id=?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, record.getUsed(), record.getResidue(), record.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I，在com.zhao.service和com.zhao.service.impl中分别实现OrderServcie接口和OrderServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建订单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;orderService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在方法上使用 @Transactional 注解，隔离级别设置为DEFAULT，传播机制设置为REQUIRED</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED, timeout = 10, readOnly = false)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动生成订单 id</span></span><br><span class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmssSSS&quot;</span>);</span><br><span class="line">        String format = df.format(<span class="keyword">new</span> Date());</span><br><span class="line">        String orderId = order.getUserId() + order.getProductId() + format;</span><br><span class="line">        System.out.println(<span class="string">&quot;自动生成的订单 id 为：&quot;</span> + orderId);</span><br><span class="line">        order.setOrderId(orderId);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始创建订单数据，订单号为：&quot;</span> + orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建订单数据</span></span><br><span class="line">        orderDao.createOrder(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;订单数据创建完成，订单号为：&quot;</span> + orderId);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查询商品库存，商品 id 为：&quot;</span> + order.getProductId());</span><br><span class="line">        Storage storage = storageDao.selectByProductId(order.getProductId());</span><br><span class="line">        <span class="keyword">if</span> (storage != <span class="keyword">null</span> &amp;&amp; storage.getResidue().intValue() &gt;= order.getCount().intValue()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品库存充足，正在扣减商品库存&quot;</span>);</span><br><span class="line">            storage.setUsed(storage.getUsed() + order.getCount());</span><br><span class="line">            storage.setResidue(storage.getTotal().intValue() - storage.getUsed());</span><br><span class="line">            <span class="keyword">int</span> decrease = storageDao.decrease(storage);</span><br><span class="line">            System.out.println(<span class="string">&quot;商品库存扣减完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;警告：商品库存不足，正在执行回滚操作！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;开始查询用户的账户金额&quot;</span>);</span><br><span class="line">        Account account = accountDao.selectByUserId(order.getUserId());</span><br><span class="line">        <span class="keyword">if</span> (account != <span class="keyword">null</span> &amp;&amp; account.getResidue().intValue() &gt;= order.getMoney().intValue()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;账户金额充足，正在扣减账户金额&quot;</span>);</span><br><span class="line">            accountDao.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">            System.out.println(<span class="string">&quot;账户金额扣减完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;警告：账户余额不足，正在执行回滚操作！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;账户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始修改订单状态，未完成》》》》》已完成&quot;</span>);</span><br><span class="line">        orderDao.updateOrderStatus(order.getOrderId(), <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改订单状态完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>J，最后，创建一个MainApp类来执行整个操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        OrderService orderService = context2.getBean(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        <span class="comment">//设置商品 id</span></span><br><span class="line">        order.setProductId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//商品数量</span></span><br><span class="line">        order.setCount(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//商品金额</span></span><br><span class="line">        order.setMoney(<span class="keyword">new</span> BigDecimal(<span class="number">600</span>));</span><br><span class="line">        <span class="comment">//设置用户 id</span></span><br><span class="line">        order.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//订单状态为未完成</span></span><br><span class="line">        order.setStatus(<span class="number">0</span>);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行后的输出应该是下面这样</span></span><br><span class="line">自动生成的订单 id 为：<span class="number">1120220111173635296</span></span><br><span class="line">开始创建订单数据，订单号为：<span class="number">1120220111173635296</span></span><br><span class="line">订单数据创建完成，订单号为：<span class="number">1120220111173635296</span></span><br><span class="line">开始查询商品库存，商品 id 为：<span class="number">1</span></span><br><span class="line">商品库存充足，正在扣减商品库存</span><br><span class="line">商品库存扣减完成</span><br><span class="line">开始查询用户的账户金额</span><br><span class="line">账户金额充足，正在扣减账户金额</span><br><span class="line">账户金额扣减完成</span><br><span class="line">开始修改订单状态，未完成》》》》》已完成</span><br><span class="line">修改订单状态完成！</span><br><span class="line"><span class="comment">//如果再次执行整个MainApp中的方法的话，是无法成功实现的，如下</span></span><br><span class="line">自动生成的订单 id 为：<span class="number">1120220111175556986</span></span><br><span class="line">开始创建订单数据，订单号为：<span class="number">1120220111175556986</span></span><br><span class="line">订单数据创建完成，订单号为：<span class="number">1120220111175556986</span></span><br><span class="line">开始查询商品库存，商品 id 为：<span class="number">1</span></span><br><span class="line">商品库存充足，正在扣减商品库存</span><br><span class="line">商品库存扣减完成</span><br><span class="line">开始查询用户的账户金额</span><br><span class="line">警告：账户余额不足，正在执行回滚操作！</span><br></pre></td></tr></table></figure>































<h1 id="八，Spring整合日志框架"><a href="#八，Spring整合日志框架" class="headerlink" title="八，Spring整合日志框架"></a>八，Spring整合日志框架</h1>]]></content>
  </entry>
  <entry>
    <title>xm-3-项目基本功能</title>
    <url>/2022/03/29/xm-3-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，后端接口工程"><a href="#一，后端接口工程" class="headerlink" title="一，后端接口工程"></a>一，后端接口工程</h1><h2 id="1，创建接口工程的架构"><a href="#1，创建接口工程的架构" class="headerlink" title="1，创建接口工程的架构"></a>1，创建接口工程的架构</h2><h3 id="（1）模块和依赖的设置"><a href="#（1）模块和依赖的设置" class="headerlink" title="（1）模块和依赖的设置"></a>（1）模块和依赖的设置</h3><p>这部分直接看Part04-01就可以，注意新建项目的时候有几点需要注意，可以看视频</p>
<p><strong>考点</strong>：maven的使用</p>
<h3 id="（2）代码生成器"><a href="#（2）代码生成器" class="headerlink" title="（2）代码生成器"></a>（2）代码生成器</h3><p>看Part04-01</p>
<p>2.1  在Navicat中新建数据库和表，这里有线程的脚本</p>
<p>2.2  使用Mybits-Plus来配置代码生成器，这部分代码不用掌握，<a href="https://baomidou.com/pages/d357af/#%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">官网</a>有。项目中使用代码生成器生成的代码不需要放在最终的项目中，所以我们是在service-core的test目录下创建一个包来运行代码生成器的代码。代码中一些参数的含义自行百度，这里不再啰嗦。这里补充一些关键的</p>
<p>首先关于Swagger的配置时打开的，那么我们要先引入Swagger的依赖，然后最后生成的bean中会有Swagger相关的注解（后面用）</p>
<p>然后是代码最后使用了策略控制的代码</p>
<p><strong>注意</strong>：本人在测试的时候出现了问题，提示数据库无法解析，因为数据库名写错了（db200921_srb_core）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: java.sql.SQLSyntaxErrorException: Unknown database &#x27;db_200921_srb_core&#x27;</span><br><span class="line"></span><br><span class="line">	at com.baomidou.mybatisplus.generator.config.DataSourceConfig.getConn(DataSourceConfig.java:170)</span><br><span class="line">	at com.baomidou.mybatisplus.generator.config.builder.ConfigBuilder.&lt;init&gt;(ConfigBuilder.java:110)</span><br><span class="line">	at com.baomidou.mybatisplus.generator.AutoGenerator.execute(AutoGenerator.java:96)</span><br><span class="line">	at com.atguigu.srb.core.CodeGenerator.genCode(CodeGenerator.java:58)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p><strong>考点</strong>：MyBatis-plus的使用，Mysql数据库链接的知识</p>
<h3 id="（3）配置及启动项目"><a href="#（3）配置及启动项目" class="headerlink" title="（3）配置及启动项目"></a>（3）配置及启动项目</h3><p>看Part04-01</p>
<p>3.1  创建配置文件D:\MyCodingRoom\IdeaWorkSpace\srb\service-core\src\main\resources\application.yml ，其中应该怎么填是Spring-boot中的知识</p>
<p>3.2  在service-core中创建config包，创建MybatisPlusConfig类</p>
<p>3.3 在service-core的com.atguigu.srb.core下创建springboot的主类（启动类），启动成功可以看到我们配置的端口号</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-3-1.png" alt="xm-3-1"></p>
<p><strong>知识点</strong>：SpringBoot的主类，MyBatis-plus的配置和配置类应该怎么设置（配置类中实现了分页）</p>
<p><strong>考点</strong>：SpringBoot启动流程</p>
<h3 id="（4）实现积分等级的CRUD"><a href="#（4）实现积分等级的CRUD" class="headerlink" title="（4）实现积分等级的CRUD"></a>（4）实现积分等级的CRUD</h3><p>看Part04-02</p>
<p>这里对应的integral_grade这张表</p>
<p>4.1  实现查询：在controller中添加admin包，添加AdminIntegralGradeController类,admin包存放用来进行后台管理的接口</p>
<p>​       在上面那个类中添加list查询方法，然后重启服务，访问： <a href="http://localhost:8110/admin/core/integralGrade/list">http://localhost:8110/admin/core/integralGrade/list</a> 查看结果json数据</p>
<p>4.2  实现删除：AdminIntegralGradeController添加removeById方法</p>
<p>​      使用postman测试删除， <a href="http://localhost:8110/admin/core/integralGrade/remove/1">http://localhost:8110/admin/core/integralGrade/remove/1</a></p>
<p><strong>注意</strong>：下面这到底是不是报错？？？似乎是不是？因为效果是实现了，id为1的数据is_delete字段变为了1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1066f0e9] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@513875093 wrapping com.mysql.cj.jdbc.ConnectionImpl@20b52534] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: UPDATE integral_grade SET is_deleted=1 WHERE id=? AND is_deleted=0</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">&lt;==    Updates: 0</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1066f0e9]</span><br></pre></td></tr></table></figure>

<p><strong>知识点</strong>：SpringMVC的注解</p>
<p><strong>考点</strong>：@CrossOrigin @RestController @Resource都是啥意思呀？</p>
<h3 id="（5）Swagger的引入"><a href="#（5）Swagger的引入" class="headerlink" title="（5）Swagger的引入"></a>（5）Swagger的引入</h3><p>postman做一些简单的接口测试还行，但是在大型项目中，你的方法的mapping要是修改了，postman里面就得一个个自己修改？这能接受吗？太累啦</p>
<p>所以我们用Swagger，能够帮助你根据接口自动生成测试用例哦。</p>
<p>配置看4.2（必须先由Swagger的依赖，自动生成代码的时候才会添加@ApiModel()这样的swagger注解）</p>
<p><strong>知识点</strong>：（1）Swagger的使用配置方式；（2）<strong>常用注解</strong>（看4.2，自行百度了解）；（3）Swagger前后端的Api怎么分组管理（110）；（4）文档描述信息的配置？（ApiInfoBuilder的使用）</p>
<p><strong>考点</strong>：Restful风格的通信方式，特点？与微服务结合？</p>
<h3 id="（6）同一返回结果的定义和使用"><a href="#（6）同一返回结果的定义和使用" class="headerlink" title="（6）同一返回结果的定义和使用"></a>（6）同一返回结果的定义和使用</h3><p><strong>引入</strong>：我们在接口测试的时候，有时候返回的结果自己不太懂怎么办？当然是标准化最好啦，对返回结果定义好使用</p>
<p>配置看4.3</p>
<p><strong>注意</strong>：就因为多了一个逗号，就报错一个Json字符串转换的错误，shit，还好发现了。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-3-2.png" alt="xm-3-2" style="zoom:67%;" /> 

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character (&#x27;&#125;&#x27; (code 125)): was expecting double-quote to start field name</span><br></pre></td></tr></table></figure>

<p><strong>知识点</strong>：（1）设计返回的信息格式；（2）使用枚举类和结果类来辅助返回结果；（3）将接口的返回值直接修改为结果类</p>
<p><strong>考点</strong>：R类的设计中，使用了静态方法，重载方法，Lombok注解。restful风格的传输中对象转换（@RequestBody 注解修饰的参数接受了Json字符串就自动转换咯，然后报错了就尴尬），</p>
<h3 id="（7）统一异常处理"><a href="#（7）统一异常处理" class="headerlink" title="（7）统一异常处理"></a>（7）统一异常处理</h3><p><strong>引入</strong>：如果在调用接口的时候出现异常，返回的json可读性不高，并且情况多样，我们需要一个标准的格式和信息</p>
<p>配置看4.4</p>
<p><strong>知识点</strong>：（1）使用了@RestControllerAdvice，这是一个切面编程中的通知哦，这样就能在controller层添加通知；（2）添加特定异常是需要对应的包哦（比如sql异常需要jdbc包）；（3）使用一个或较少的异常类，可以捕获和显示所有的异常信息。因此，我们可以创建一个自定义异常类<strong>（必须是运行时异常）</strong>，在程序中抛出这个自定义异常对象，并在统一异常处理器中捕获自定义异常对象（所以遇到新的异常，我们是放在业务的代码中进行处理了）；（4）Assert校验业务的异常，避免写if else；（5）4中说的是controller中的异常，那么如果进入Controller之前发生的异常呢？我们最好分开一下</p>
<p><strong>考点</strong>：切面编程；java中的异常处理和异常类；无参构造器注解（为什么必须要有呢？）；Assert怎么使用呢？；抽象类的用法</p>
<h3 id="（8）统一日志处理"><a href="#（8）统一日志处理" class="headerlink" title="（8）统一日志处理"></a>（8）统一日志处理</h3><p><strong>引入</strong>：我们在编程的时候会发现控制台有日志的输出，我们想控制什么样的日志输出，什么样的日志不输出，需要进行统一的管理。日志有等级（观察控制台便可以看出来），分为TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF。默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别(低级别就不打印咯)，我们可以在SpringBoot的配置文件application.yml中进行设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure>

<p> 配置看4.5</p>
<p><strong>知识点</strong>：</p>
<p>A，在core中添加Logback-spring.xml配置文件，这是一个可以被自动加载的名称，注意其中的内容，了解即可</p>
<p><strong>考点</strong>：Spring加载这个配置文件的过程</p>
<h1 id="二，管理平台前端搭建"><a href="#二，管理平台前端搭建" class="headerlink" title="二，管理平台前端搭建"></a>二，管理平台前端搭建</h1><p>前端这里没记笔记，主要是看培训的记录点</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-mysql-1</title>
    <url>/2022/02/05/js-4-mysql/</url>
    <content><![CDATA[<p><strong>简介：</strong>MySQL的简介和安装</p>
<span id="more"></span>

<h1 id="一，MySQL介绍"><a href="#一，MySQL介绍" class="headerlink" title="一，MySQL介绍"></a>一，MySQL介绍</h1><p>​     MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>，由瑞典MySQL AB 公司开发，目前属于 <a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>之一，在 WEB 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<p>   MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>​    MySQL的优点有：1）成本低：开放源代码，一般可免费使用；2）性能高：执行很快；3）简单：容易安装和使用                                                                                                                                                                                                 </p>
<h1 id="二，Mysql安装（win系统，5-7版本）"><a href="#二，Mysql安装（win系统，5-7版本）" class="headerlink" title="二，Mysql安装（win系统，5.7版本）"></a>二，Mysql安装（win系统，5.7版本）</h1><p><strong>下载地址：</strong></p>
<p>官网下载(不推荐使用)：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br> 清华镜像站下载(推荐)：<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7">https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7</a></p>
<h2 id="1，软件安装版"><a href="#1，软件安装版" class="headerlink" title="1，软件安装版"></a>1，软件安装版</h2><p>软件安装版也就是后缀为.msi的安装包，进行有界面操作的安装，在安装的过程中对相关的属性进行设置，可参考这篇博客：<a href="https://blog.csdn.net/weixin_43790276/article/details/102090540">https://blog.csdn.net/weixin_43790276/article/details/102090540</a></p>
<h2 id="2，安装包解压版"><a href="#2，安装包解压版" class="headerlink" title="2，安装包解压版"></a>2，安装包解压版</h2><p>使用.zip后缀的安装包进行安装时，需要结合命令行和配置文件进行配置，适合有一定基础的使用，可参考博客：<a href="https://www.jianshu.com/p/ea4accd7afb4%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%EF%BC%9A">https://www.jianshu.com/p/ea4accd7afb4以及博客：</a></p>
<p><strong>总结：</strong>上面两种方式各有优点和缺点，选择适合自己的方法进行安装即可。我选择的是.mis安装方式，Windows中的服务名忘了设置，是默认的MySQL57，端口也是3306，用户名和密码都是root（自己学习用就设置简单一点，否则忘了就很麻烦）。最后MySQL的卸载比较麻烦，一定要从软件，安装路径，注册表这三个方面卸载干净。</p>
<h1 id="三，（补充）关系型数据库"><a href="#三，（补充）关系型数据库" class="headerlink" title="三，（补充）关系型数据库"></a>三，（补充）关系型数据库</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作"><a href="#三，MySQL操作" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作-1"><a href="#三，MySQL操作-1" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-2"><a href="#1，这是二级标题-2" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-4"><a href="#（1），这是三级标题-4" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-2"><a href="#2，这是二级标题-2" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-5"><a href="#（1），这是三级标题-5" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>尚融宝项目背景</title>
    <url>/2022/02/05/xm-1-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>**简介：尚融宝是尚硅谷培训机构的一个中等规模的项目，实现了一个网络借贷信息中介服务平台，为个人投资者、个人融资用户和小微企业提供专业的线上信贷及出借撮合服务。是学习微服务一个不错的项目。</p>
<span id="more"></span>

<h1 id="一，项目简介"><a href="#一，项目简介" class="headerlink" title="一，项目简介"></a>一，项目简介</h1><h2 id="1，项目的业务流程"><a href="#1，项目的业务流程" class="headerlink" title="1，项目的业务流程"></a>1，项目的业务流程</h2><p>业务流程如下图，从业务流程图可以看出，每个步骤必须有一个开始和结束，中间没有特别复杂的分支，设计业务的时候就应该像这样清晰简洁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-1.png" alt="xm-1-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-2.png" alt="xm-1-2"></p>
<h2 id="2，项目的架构图"><a href="#2，项目的架构图" class="headerlink" title="2，项目的架构图"></a>2，项目的架构图</h2><p>从架构图可以看出，不同服务之间的前端，网关，配置，数据库都可能会不一样，并且在发布时使用了Doker技术</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-3.png" alt="xm-1-3"></p>
<h1 id="二，技术栈（注意版本）"><a href="#二，技术栈（注意版本）" class="headerlink" title="二，技术栈（注意版本）"></a>二，技术栈（注意版本）</h1><p>首先基础的部分需要掌握：java基础、HTML、CSS、JavaScript、Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud Alibaba，MySQL（5.7及以上）、Redis、RabbitMQ、nginx、idea、maven、VMWare 虚拟机、CentOS 操作系统</p>
<h2 id="1，后端"><a href="#1，后端" class="headerlink" title="1，后端"></a>1，后端</h2><p><strong>SpringBoot 2.3.4.RELEASE</strong></p>
<p><strong>SpringCloud Hoxton.SR8：</strong>微服务基础设施 - 服务注册、服务发现、服务熔断、微服务网关、配置中心等</p>
<p>SpringCloud Alibaba 2.2.2.RELEASE</p>
<p><strong>MyBatis Plus：持久层框架和代码生成器</strong></p>
<p>Lombok：简化实体类开发</p>
<p>Swagger2：Api接口文档生成工具</p>
<p>Logback：日志系统</p>
<p>alibaba-easyexcel：Excel读写</p>
<p><strong>Spring Data Redis：Spring项目中访问Redis缓存</strong></p>
<p>HTTPClient: 基于Http协议的客户端，用来实现远程调用</p>
<p>Spring Task：定时任务</p>
<h2 id="2，数据库和中间件"><a href="#2，数据库和中间件" class="headerlink" title="2，数据库和中间件"></a>2，数据库和中间件</h2><p><strong>MySQL 5.7：关系型数据库   管理工具：Navicat</strong></p>
<p><strong>Redis 5.0：缓存技术   管理工具：RedisDesktopManager</strong></p>
<p><strong>RabbitMQ 3.8：消息中间件</strong></p>
<h2 id="3，三方接口"><a href="#3，三方接口" class="headerlink" title="3，三方接口"></a>3，三方接口</h2><p>阿里云短信：短信网关</p>
<p>阿里云OSS：分布式文件存储</p>
<p>资金托管平台API对接：汇付宝</p>
<h2 id="4，了解即可"><a href="#4，了解即可" class="headerlink" title="4，了解即可"></a>4，了解即可</h2><p>Node.js： JavaScript 运行环境</p>
<p>ES6：JavaScript的模块化版本</p>
<p>axios：一个发送Ajax请求的工具</p>
<p>Vue.js：web 界面的渐进式框架</p>
<p>Element-UI：前端组件库</p>
<p>模块化开发：解决javascript变量全局空间污染的问题</p>
<p>NPM：模块资源管理器</p>
<p>vue-element-admin：基于Vue.js的后台管理系统UI集成方案</p>
<p>NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架</p>
<h1 id="三，开发环境"><a href="#三，开发环境" class="headerlink" title="三，开发环境"></a>三，开发环境</h1><h2 id="1，开发环境检测"><a href="#1，开发环境检测" class="headerlink" title="1，开发环境检测"></a>1，开发环境检测</h2><p>在开始开发之前，需要确定基本的环境是否和开发要求的一致，在本项目中，要检查以下几个方面：</p>
<ul>
<li><p>jdk 1.8 配置：JAVA_HOME，path</p>
</li>
<li><p>maven 3.6 配置：MAVEN_HOME，本地仓库</p>
</li>
<li><p>ideaIU-2020.2.3，尽量在欢迎页面进行设置，这样对所有项目都是普遍有效的，当然给特定项目设置也是可以的，这里注意通过File–&gt;close project来到欢迎界面，如果不想每次打开idea都进入已有的项目（特别是大的项目，加载就得好一会），可以通过在Setting-&gt;System Settings取消勾选Reopen last project on open（如下图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-4.png" alt="xm-1-4"></p>
<p><em>注意：在idea的欢迎页面选择Configure &gt; settings</em>（比较新的版本似乎取消了右下角的Configure，比如我的idea 2021，要设置的话可以参考下图）。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-5.png" alt="xm-1-5"></p>
</li>
</ul>
<p>接着就是在开始一个项目时，一些基础的配置，<em>包括配置：Java Compiler、File Encodings、Maven、Auto Import、Code Completion &gt; Match case（取消）</em>  <em>插件：lombok、MyBatisX</em></p>
<p>1，Java Compiler。需要在Setting中（搜索Java Compiler），设置编译器为javac，版本为自己安装的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-6.png" alt="xm-1-6"></p>
<p>2，File Encodings。同上，如图，需要设置三个地方的编码方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-7.png" alt="xm-1-7"></p>
<p>3，maven</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-8.png" alt="xm-1-8"></p>
<p>4，Auto Import、Code Completion &gt; Match case（取消) 插件：lombok、MyBatisX</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-9.png" alt="xm-1-9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-10.png" alt="xm-1-10"></p>
<p>5，插件：lombok、MyBatisX</p>
<p>插件安装这里不再赘述</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>xm-2-MyBatis-Plus</title>
    <url>/2022/02/06/xm-2-MyBatis-Plus/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，基础知识之字词积累"><a href="#一，基础知识之字词积累" class="headerlink" title="一，基础知识之字词积累"></a>一，基础知识之字词积累</h1><h2 id="1，《斑比出生了》"><a href="#1，《斑比出生了》" class="headerlink" title="1，《斑比出生了》"></a>1，《斑比出生了》</h2><h3 id="（1），几种类型的词语"><a href="#（1），几种类型的词语" class="headerlink" title="（1），几种类型的词语"></a>（1），几种类型的词语</h3><h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-springmvc</title>
    <url>/2022/02/06/js-2-springmvc/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：快速了解Spring的用法，能够对Spring形成自己的框架。本文的学习基于<a href="http://c.biancheng.net/spring_mvc/mvc.html">C语言中文网</a>，尚硅谷Spring讲解</p>
<span id="more"></span>

<h1 id="一，MVC设计模式简介"><a href="#一，MVC设计模式简介" class="headerlink" title="一，MVC设计模式简介"></a>一，MVC设计模式简介</h1><h2 id="1，认识MVC"><a href="#1，认识MVC" class="headerlink" title="1，认识MVC"></a>1，认识MVC</h2><p>MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。</p>
<ul>
<li>视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。</li>
<li>控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。</li>
<li>数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。</li>
</ul>
<h2 id="2，MVC优缺点"><a href="#2，MVC优缺点" class="headerlink" title="2，MVC优缺点"></a>2，MVC优缺点</h2><p>优点</p>
<ul>
<li>多视图共享一个模型，大大提高了代码的可重用性</li>
<li>MVC 三个模块相互独立，松耦合架构</li>
<li>控制器提高了应用程序的灵活性和可配置性</li>
<li>有利于软件工程化管理</li>
</ul>
<p>总之，我们通过 MVC 设计模式最终可以打造出一个松耦合+高可重用性+高可适用性的完美架构。</p>
<p>缺点</p>
<ul>
<li>原理复杂</li>
<li>增加了系统结构和实现的复杂性</li>
<li>视图对模型数据的低效率访问</li>
</ul>
<p>MVC 并不适合小型甚至中型规模的项目，花费大量时间将 MVC 应用到规模并不是很大的应用程序，通常得不偿失，所以对于 MVC 设计模式的使用要根据具体的应用场景来决定。</p>
<h1 id="二，Spring-MVC是什么？"><a href="#二，Spring-MVC是什么？" class="headerlink" title="二，Spring MVC是什么？"></a>二，Spring MVC是什么？</h1><h2 id="1，认识Spring-MVC"><a href="#1，认识Spring-MVC" class="headerlink" title="1，认识Spring MVC"></a>1，认识Spring MVC</h2><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。</p>
<p>Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性</p>
<h2 id="2-Spring-MVC的优缺点"><a href="#2-Spring-MVC的优缺点" class="headerlink" title="2,Spring MVC的优缺点"></a>2,Spring MVC的优缺点</h2><ul>
<li>清晰地角色划分，Spring MVC 在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。</li>
<li>灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。</li>
<li>提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。</li>
<li>真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。</li>
<li>国际化支持</li>
<li>面向接口编程</li>
<li>与 Spring 框架无缝集成</li>
</ul>
<h1 id="三，第一个Spring-MVC程序"><a href="#三，第一个Spring-MVC程序" class="headerlink" title="三，第一个Spring MVC程序"></a>三，第一个Spring MVC程序</h1><h2 id="1，创建Web应用并引入Jar包"><a href="#1，创建Web应用并引入Jar包" class="headerlink" title="1，创建Web应用并引入Jar包"></a>1，创建Web应用并引入Jar包</h2><p>这些包中，前面的是Spring的核心包，后面两个是进行Spring MVC开发的包。（当然，如果项目是maven项目，相关依赖可以自行百度，但是要注意版本）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-1.png" alt="js-3-1"></p>
<h2 id="2，Spring-MVC配置"><a href="#2，Spring-MVC配置" class="headerlink" title="2，Spring MVC配置"></a>2，Spring MVC配置</h2><p>Spring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理。所以配置 Spring MVC，首先要定义 DispatcherServlet。跟所有 Servlet 一样，<strong>用户必须在 web.xml 中进行配置</strong>。</p>
<h3 id="1）在web-xml中定义DispatcherServlet"><a href="#1）在web-xml中定义DispatcherServlet" class="headerlink" title="1）在web.xml中定义DispatcherServlet"></a>1）在web.xml中定义DispatcherServlet</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意，如果该配置文件不是放在默认的 WEB-INF文件夹下的话，就需要下面的Init-param中的contextConfigLocation参数来设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL，因为这里根本没限制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring MVC 初始化时，加载web.xml，然后根据配置的servlet信息，在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“servletName-servlet.xml”，例如 springmvc-servlet.xml。</p>
<h3 id="2）创建Spring-MVC配置文件"><a href="#2）创建Spring-MVC配置文件" class="headerlink" title="2）创建Spring MVC配置文件"></a>2）创建Spring MVC配置文件</h3><p>在 WEB-INF 目录下创建 springmvc-servlet.xml 文件，如下所示。（这里和网上的还不一样，网上直接就上注解了，这里还没）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- LoginController控制器类，映射到&quot;/login&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/login&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;net.biancheng.controller.LoginController&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- LoginController控制器类，映射到&quot;/register&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/register&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;net.biancheng.controller.RegisterController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3，创建Controller"><a href="#3，创建Controller" class="headerlink" title="3，创建Controller"></a>3，创建Controller</h2><p>在src目录下创建com.zhao.controller，并在该包中创建 RegisterController 和 LoginController 两个<strong>传统风格</strong>（现在用的少）的控制器类（实现 Controller 接口），分别处理首页中“注册”和“登录”超链接的请求</p>
<p>RegisterController 的具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest arg0,</span></span></span><br><span class="line"><span class="params"><span class="function">            HttpServletResponse arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/WEB-INF/jsp/register.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoginController 的具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest arg0,</span></span></span><br><span class="line"><span class="params"><span class="function">            HttpServletResponse arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，创建View"><a href="#4，创建View" class="headerlink" title="4，创建View"></a>4，创建View</h2><p>index.jsp代码如下（这个页面的位置其实可以不用很讲究，此处还么有引入web环境，所以是直接打开此页面开始的）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    未注册的用户，请</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/register&quot;</span>&gt;</span> 注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span>！</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 已注册的用户，去</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/login&quot;</span>&gt;</span> 登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span>！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 WEB-INF 下创建 jsp 文件夹，将 login.jsp 和 register.jsp 放到 jsp 文件夹下。login.jsp 代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    登录页面！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">         pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    注册页面！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-部署运行"><a href="#5-部署运行" class="headerlink" title="5,部署运行"></a>5,部署运行</h3><p>将 springmvcDemo 项目部署到 Tomcat 服务器，首先访问 index.jsp 页面，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-2.png" alt="js-3-2"></p>
<p>在上图所示的页面中，当用户单击“注册”超链接时，根据 springmvc-servlet.xml 文件中的映射将请求转发给 RegisterController 控制器处理，处理后跳转到 &#x2F;WEB-INF&#x2F;jsp 下的 register.jsp 视图。同理，当单击“登录”超链接时，控制器处理后转到 &#x2F;WEB-INF&#x2F;jsp下的 login.jsp 视图。</p>
<h1 id="四，Spring-MVC-和Structs2的区别"><a href="#四，Spring-MVC-和Structs2的区别" class="headerlink" title="四，Spring MVC 和Structs2的区别"></a>四，Spring MVC 和Structs2的区别</h1><p>这里了解即可，这里不再花篇幅说明</p>
<h1 id="五，Spring-MVC视图解析器（ViewResolver）"><a href="#五，Spring-MVC视图解析器（ViewResolver）" class="headerlink" title="五，Spring MVC视图解析器（ViewResolver）"></a>五，Spring MVC视图解析器（ViewResolver）</h1><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-3.png" alt="js-3-3"></p>
<p>视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。Spring MVC提供了上面几种视图解析器，下面介绍1个常用的视图解析器，其他视图解析器如何配置这里不再赘述</p>
<h2 id="（1）InternalResourceViewResolver"><a href="#（1）InternalResourceViewResolver" class="headerlink" title="（1）InternalResourceViewResolver"></a>（1）InternalResourceViewResolver</h2><p>InternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性。</p>
<p>InternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六，Spring-MVC执行流程"><a href="#六，Spring-MVC执行流程" class="headerlink" title="六，Spring MVC执行流程"></a>六，Spring MVC执行流程</h1><h2 id="1，图解执行流程"><a href="#1，图解执行流程" class="headerlink" title="1，图解执行流程"></a>1，图解执行流程</h2><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-4.png" alt="js-3-4" style="zoom:50%;" />

<p>SpringMVC 的执行流程如下。</p>
<ol>
<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li>
<li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链给DispatcherServlet（HandlerExecutionChain）。</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol>
<h2 id="2，Spring-MVC接口"><a href="#2，Spring-MVC接口" class="headerlink" title="2，Spring MVC接口"></a>2，Spring MVC接口</h2><p>Spring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）。下面对各个组件的功能说明如下。</p>
<h4 id="1）DispatcherServlet"><a href="#1）DispatcherServlet" class="headerlink" title="1）DispatcherServlet"></a>1）DispatcherServlet</h4><p>DispatcherServlet 是前端控制器，从图 1 可以看出，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p>
<h4 id="2）HandlerMapping"><a href="#2）HandlerMapping" class="headerlink" title="2）HandlerMapping"></a>2）HandlerMapping</h4><p>HandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。</p>
<h4 id="3）HandlerAdapter"><a href="#3）HandlerAdapter" class="headerlink" title="3）HandlerAdapter"></a>3）HandlerAdapter</h4><p>HandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。</p>
<h4 id="4）Handler"><a href="#4）Handler" class="headerlink" title="4）Handler"></a>4）Handler</h4><p>Handler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。</p>
<h4 id="5）View-Resolver"><a href="#5）View-Resolver" class="headerlink" title="5）View Resolver"></a>5）View Resolver</h4><p>View Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。</p>
<h4 id="6）View"><a href="#6）View" class="headerlink" title="6）View"></a>6）View</h4><p>View 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。</p>
<p>以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。这里只是大概的说明了一下，更加具体的应该在后面的运用中加深理解。</p>
<h3 id="3，更完整的执行流程（加上了拦截器啥的）"><a href="#3，更完整的执行流程（加上了拦截器啥的）" class="headerlink" title="3，更完整的执行流程（加上了拦截器啥的）"></a>3，更完整的执行流程（加上了拦截器啥的）</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-5.png" alt="js-3-5" style="zoom:67%;" />

<h1 id="七，-Controller和-RequestMapping注解"><a href="#七，-Controller和-RequestMapping注解" class="headerlink" title="七，@Controller和@RequestMapping注解"></a>七，@Controller和@RequestMapping注解</h1><h2 id="1，Controller注解"><a href="#1，Controller注解" class="headerlink" title="1，Controller注解"></a>1，Controller注解</h2><p>@Controller 注解用于声明某类的实例是一个控制器。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC 使用扫描机制找到应用中所有基于注解的控制器类，所以，为了让控制器类被 Spring MVC 框架扫描到，需要在配置文件中声明 spring-context，并使用 <code>&lt;context:component-scan/&gt;</code> 元素指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用扫描机制扫描控制器类，控制器类都在com.zhao.controller包及其子包下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.controller&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-RequestMapping注解"><a href="#2-RequestMapping注解" class="headerlink" title="2,RequestMapping注解"></a>2,RequestMapping注解</h2><p>一个Controller内有多个处理请求的方法，如 UserController 里通常有增加用户、修改用户信息、删除指定用户、根据条件获取用户列表等。每个方法负责不同的请求操作，而 @RequestMapping 就负责将请求映射到对应的controller法上。</p>
<p>@RequestMapping 注解可用于类或方法上。用于类上，表示类中的所有响应请求的方法都以该地址作为父路径。</p>
<p>下面介绍该注解的一些参数</p>
<h3 id="（1）value-属性"><a href="#（1）value-属性" class="headerlink" title="（1）value 属性"></a>（1）value 属性</h3><p>value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称。如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;toUser&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;toUser&quot;)</span></span><br></pre></td></tr></table></figure>

<p>value 属性支持通配符匹配，如 @RequestMapping(value&#x3D;”toUser&#x2F;*”) 表示 <a href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p>
<h3 id="（2）path属性"><a href="#（2）path属性" class="headerlink" title="（2）path属性"></a>（2）path属性</h3><p>path 属性和 value 属性都用来作为映射使用。即 @RequestMapping(value&#x3D;”toUser”) 和 @RequestMapping(path&#x3D;”toUser”) 都能访问 toUser() 方法。</p>
<p>path 属性支持通配符匹配，如 @RequestMapping(path&#x3D;”toUser&#x2F;*”) 表示 <a href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p>
<h3 id="（3）name属性"><a href="#（3）name属性" class="headerlink" title="（3）name属性"></a>（3）name属性</h3><p>name属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value &#x3D; “toUser”,name &#x3D; “获取用户信息”)。</p>
<h3 id="（4）method属性"><a href="#（4）method属性" class="headerlink" title="（4）method属性"></a>（4）method属性</h3><p>method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求。</p>
<p>@RequestMapping(value &#x3D; “toUser”,method &#x3D; RequestMethod.GET) 表示该方法只支持 GET 请求。也可指定多个 HTTP 请求，如 @RequestMapping(value &#x3D; “toUser”,method &#x3D; {RequestMethod.GET,RequestMethod.POST})，说明该方法同时支持 GET 和 POST 请求。</p>
<h3 id="（5）params属性"><a href="#（5）params属性" class="headerlink" title="（5）params属性"></a>（5）params属性</h3><p>params 属性用于指定请求中规定的参数，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;showUser&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码表示请求中必须包含 type 参数时才能执行该请求。即 <a href="http://localhost:8080/toUser?type=xxx">http://localhost:8080/toUser?type=xxx</a> 能够正常访问 toUser() 方法，而 <a href="http://localhost:8080/toUser">http://localhost:8080/toUser</a> 则不能正常访问 toUser() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type=1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;showUser&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求。即 <a href="http://localhost:8080/toUser?type=1">http://localhost:8080/toUser?type=1</a> 能够正常访问 toUser() 方法，而 <a href="http://localhost:8080/toUser?type=2">http://localhost:8080/toUser?type=2</a> 则不能正常访问 toUser() 方法。</p>
<h3 id="（6）header属性"><a href="#（6）header属性" class="headerlink" title="（6）header属性"></a>（6）header属性</h3><p>header 属性表示请求中必须包含某些指定的 header 值。</p>
<p>@RequestMapping(value &#x3D; “toUser”,headers &#x3D; “Referer&#x3D;<a href="http://www.xxx.com&quot;/">http://www.xxx.com&quot;</a>) 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“<a href="http://www.xxx.com”时,才能执行该请求./">http://www.xxx.com”时，才能执行该请求。</a></p>
<h3 id="（7）consumers属性"><a href="#（7）consumers属性" class="headerlink" title="（7）consumers属性"></a>（7）consumers属性</h3><p>consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html。如<br>@RequestMapping(value &#x3D; “toUser”,consumes &#x3D; “application&#x2F;json”)。</p>
<h3 id="（8）produces属性"><a href="#（8）produces属性" class="headerlink" title="（8）produces属性"></a>（8）produces属性</h3><p>produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json”)。</p>
<p>除此之外，produces 属性还可以指定返回值的编码。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json,charset&#x3D;utf-8”)，表示返回 utf-8 编码。</p>
<h2 id="3，通过请求URL进行映射"><a href="#3，通过请求URL进行映射" class="headerlink" title="3，通过请求URL进行映射"></a>3，通过请求URL进行映射</h2><p>使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头。这里先说明通过请求URL进行映射</p>
<h3 id="（1）方法级别注解"><a href="#（1）方法级别注解" class="headerlink" title="（1）方法级别注解"></a>（1）方法级别注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以使用如下 URL 访问 login 方法（请求处理方法），在访问 login 方法之前需要事先在 &#x2F;WEB-INF&#x2F;jsp&#x2F; 目录下创建 login.jsp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/springmvcDemo/index/login</span><br></pre></td></tr></table></figure>

<h3 id="（2）类级别注解"><a href="#（2）类级别注解" class="headerlink" title="（2）类级别注解"></a>（2）类级别注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。用户可以使用如下 URL 访问 login 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/springmvcDemo/index/login</span><br></pre></td></tr></table></figure>

<h2 id="4，通过请求参数，请求方法进行映射"><a href="#4，通过请求参数，请求方法进行映射" class="headerlink" title="4，通过请求参数，请求方法进行映射"></a>4，通过请求参数，请求方法进行映射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/success&quot; method=RequestMethod.GET, Params=&quot;username&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">(<span class="meta">@RequestParam</span> String username)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，@RequestMapping 的 value 表示请求的 URL；method 表示请求方法，此处设置为 GET 请求，若是 POST 请求，则无法进入 success 这个处理方法中。params 表示请求参数，此处参数名为 username。</p>
<h2 id="5，编写请求处理方法"><a href="#5，编写请求处理方法" class="headerlink" title="5，编写请求处理方法"></a>5，编写请求处理方法</h2><h3 id="（1）请求处理方法中常出现的参数类型"><a href="#（1）请求处理方法中常出现的参数类型" class="headerlink" title="（1）请求处理方法中常出现的参数类型"></a>（1）请求处理方法中常出现的参数类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,请求处理方法中处理Servlet API（有很多，比如session）</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session,HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;skey&quot;</span>, <span class="string">&quot;session范围的值&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;rkey&quot;</span>, <span class="string">&quot;request范围的值&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）请求处理方法常见的返回类型"><a href="#（2）请求处理方法常见的返回类型" class="headerlink" title="（2）请求处理方法常见的返回类型"></a>（2）请求处理方法常见的返回类型</h3><p>求处理方法可以返回如下类型的对象：</p>
<ul>
<li>ModelAndView</li>
<li>Model</li>
<li>包含模型属性的 Map</li>
<li>View</li>
<li>代表逻辑视图名的 String</li>
<li>void</li>
<li>其它任意Java类型</li>
</ul>
<p>最常见的返回类型就是代表逻辑视图名称的 String 类型，例如前面几节中的请求处理方法。</p>
<h1 id="八，Spring-MVC传递参数"><a href="#八，Spring-MVC传递参数" class="headerlink" title="八，Spring MVC传递参数"></a>八，Spring MVC传递参数</h1><p>Spring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：</p>
<ul>
<li>通过实体 Bean 接收请求参数</li>
<li>通过处理方法的形参接收请求参数</li>
<li>通过 HttpServletRequest 接收请求参数</li>
<li>通过 @PathVariable 接收 URL 中的请求参数</li>
<li>通过 @RequestParam 接收请求参数</li>
<li>通过 @ModelAttribute 接收请求参数</li>
</ul>
<h2 id="（1）通过实体-Bean-接收请求参数"><a href="#（1）通过实体-Bean-接收请求参数" class="headerlink" title="（1）通过实体 Bean 接收请求参数"></a>（1）通过实体 Bean 接收请求参数</h2><p>实体 Bean 接收请求参数适用于 get 和 post 提交请求方式。需要注意，Bean 的属性名称必须与请求参数名称相同（比如name要和页面传过来的name是一样的才行，页面中的表单传递了两个参数，会被包装成一个user类）。示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(user.getName()) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.getPwd())) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&lt;%=request.getAttribute(&quot;messageError&quot;)%&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="（2）通过处理方法的形参接收请求参数"><a href="#（2）通过处理方法的形参接收请求参数" class="headerlink" title="（2）通过处理方法的形参接收请求参数"></a>（2）通过处理方法的形参接收请求参数</h2><p>通过处理方法的形参接收请求参数就是直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式。示例代码如下（理解如上）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String name, String pwd, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(user.getName()) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.getPwd())) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="（3）通过HttpServletRequest接收请求参数"><a href="#（3）通过HttpServletRequest接收请求参数" class="headerlink" title="（3）通过HttpServletRequest接收请求参数"></a>（3）通过HttpServletRequest接收请求参数</h2><p>通过 HttpServletRequest 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request, Model model)</span> </span>&#123;</span><br><span class="line">    String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String pwd = request.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（4）通过-PathVariable接收URL中的请求参数"><a href="#（4）通过-PathVariable接收URL中的请求参数" class="headerlink" title="（4）通过@PathVariable接收URL中的请求参数"></a>（4）通过@PathVariable接收URL中的请求参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login/&#123;name&#125;/&#123;pwd&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@PathVariable</span> String name, <span class="meta">@PathVariable</span> String pwd, Model model)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123; </span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问“<a href="http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456%E2%80%9D%E8%B7%AF%E5%BE%84%E6%97%B6%EF%BC%8C%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86">http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456”路径时，上述代码会自动将</a> URL 中的模板变量 {name} 和 {pwd} 绑定到通过 @PathVariable 注解的同名参数上，即 name&#x3D;bianchengbang、pwd&#x3D;123456。</p>
<h2 id="（5）通过-RequestParam接收请求参数"><a href="#（5）通过-RequestParam接收请求参数" class="headerlink" title="（5）通过@RequestParam接收请求参数"></a>（5）通过@RequestParam接收请求参数</h2><p>在方法入参处使用 @RequestParam 注解指定其对应的请求参数。@RequestParam 有以下三个参数：</p>
<ul>
<li>value：参数名</li>
<li>required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常</li>
<li>defaultValue：参数默认值</li>
</ul>
<p>通过 @RequestParam 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="meta">@RequestParam</span> String pwd, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方式与“通过处理方法的形参接收请求参数”部分的区别如下：当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报 404 错误，而“通过 @RequestParam 接收请求参数”会报 404 错误。</p>
<h2 id="（6）通过-ModelAttribute接收请求参数"><a href="#（6）通过-ModelAttribute接收请求参数" class="headerlink" title="（6）通过@ModelAttribute接收请求参数"></a>（6）通过@ModelAttribute接收请求参数</h2><p>@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。</p>
<p>而“通过实体 Bean 接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据，数据绑定与模型数据展示后面教程中会讲解）。</p>
<p>通过 @ModelAttribute 注解接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@ModelAttribute(&quot;user&quot;)</span> User user, Model model)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九，Spring-MVC重定向和转发"><a href="#九，Spring-MVC重定向和转发" class="headerlink" title="九，Spring MVC重定向和转发"></a>九，Spring MVC重定向和转发</h1><p>Spring MVC 请求方式分为转发、重定向 2 种，分别使用 forward 和 redirect 关键字在 controller 层进行处理。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">转发</th>
<th align="left">重定向</th>
</tr>
</thead>
<tbody><tr>
<td>含义：</td>
<td align="left">转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。</td>
<td align="left">重定向是将用户从当前处理请求定向到另一个视图（例如 JSP）或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域</td>
</tr>
<tr>
<td>对象：</td>
<td align="left">服务器</td>
<td align="left">客户端</td>
</tr>
<tr>
<td>过程：</td>
<td align="left">客户浏览器发送 http 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request。</td>
<td align="left">客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户。</td>
</tr>
<tr>
<td>理解:</td>
<td align="left">在客户浏览器的地址栏中显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</td>
<td align="left">这里 location 可以重定向到任意 URL，既然是浏览器重新发出了请求，那么就没有什么 request 传递的概念了。在客户浏览器的地址栏中显示的是其重定向的路径，客户可以观察到地址的变化。重定向行为是浏览器做了至少两次的访问请求。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转发到一个请求方法（同一个控制器类可以省略/index/）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foward:/index/isLogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/isLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">isLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重定向到一个请求方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index/isRegister&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/isRegister&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">isRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转发到一个视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十，-Autowired和-Service注解"><a href="#十，-Autowired和-Service注解" class="headerlink" title="十，@Autowired和@Service注解"></a>十，@Autowired和@Service注解</h1><h2 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h2><p>@Autowired注解对类成员变量、方法及构造函数进行标注，完成自动装配的工作。也就是从容器中找对应的使用</p>
<p>@Service注解会将标注类自动注册到 Spring 容器中。</p>
<p>使用的时候在配置文件中添加下面的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;com.zhao.service&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h2><p>1，创建bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，在com.zhao.service中创建UserService.java接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3，在com.zhao.service中创建UserServiceImpl.java实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解保证这个类能被Spring扫描和管理</span></span><br><span class="line"><span class="meta">@servcie</span></span><br><span class="line"><span class="keyword">public</span> UserServiceImpl implements UserService&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhao&quot;</span>.equals(user.getUserName()) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(user.getPwd()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhao&quot;</span>.equals(user.getUserName()) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(user.getPwd()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4，在com.zhao.controller中创建UserController.java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="comment">//会使 UserService 的一个实例被注入到 UserController 实例中</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        User user =<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;zhao&quot;</span>);</span><br><span class="line">        userServcie.login(user);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;User user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        User user =<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;zhao&quot;</span>);</span><br><span class="line">        userServcie.register(user);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;User user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5，配置springmvc-servlet.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6，配置web.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7，index.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    未注册的用户，请</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/user/register&quot;</span>&gt; 注册&lt;/a&gt;！</span><br><span class="line">    &lt;br /&gt; 已注册的用户，去</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/user/login&quot;</span>&gt; 登录&lt;/a&gt;！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>8，login.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    登录页面！ 欢迎 $&#123;user.name&#125; 登录</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>9，register.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">         pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    注册页面！</span><br><span class="line">    注册账号成功，用户名为： $&#123;user.name &#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-6.png" alt="js-3-6" style="zoom:80%;" />







































































































































































































]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong算法秘籍阅读笔记</title>
    <url>/2022/02/07/sf-1-labuladong/</url>
    <content><![CDATA[<p><strong>简介：</strong>该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。</p>
<span id="more"></span>

<h1 id="一，刷题思维"><a href="#一，刷题思维" class="headerlink" title="一，刷题思维"></a>一，刷题思维</h1><h2 id="1，数据结构的存储方式"><a href="#1，数据结构的存储方式" class="headerlink" title="1，数据结构的存储方式"></a>1，数据结构的存储方式</h2><h3 id="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）"><a href="#（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）" class="headerlink" title="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）"></a>（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</h3><p>散列表、栈、队列、堆、树、图等等各种数据结构 ，都是基于数组和链表的</p>
<h3 id="（2）数组和链表的优缺点"><a href="#（2）数组和链表的优缺点" class="headerlink" title="（2）数组和链表的优缺点"></a>（2）数组和链表的优缺点</h3><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。<u>但正因为连</u><br><u>续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全</u><br><u>部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以</u><br><u>保持连续，时间复杂度 O(N)。</u>  </p>
<p><strong>链表</strong>因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素<br>的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。<u>但是正因为存储空间不连续，<br>你⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位<br>置的指针，会消耗相对更多的储存空间</u></p>
<h2 id="2，数据结构的基本操作"><a href="#2，数据结构的基本操作" class="headerlink" title="2，数据结构的基本操作"></a>2，数据结构的基本操作</h2><h3 id="（1）数据结构的终极目的"><a href="#（1）数据结构的终极目的" class="headerlink" title="（1）数据结构的终极目的"></a>（1）数据结构的终极目的</h3><p>在不同的应⽤场景，尽可能⾼效地增删查改。  </p>
<h3 id="（2）操作的类型"><a href="#（2）操作的类型" class="headerlink" title="（2）操作的类型"></a>（2）操作的类型</h3><p>如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。<br>线性就是 for&#x2F;while 迭代为代表，⾮线性就是递归为代表。再具体⼀步，⽆⾮以下⼏种框架  ：</p>
<p>A，数组遍历框架（典型的线性迭代结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        <span class="comment">//访问并操作arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，链表遍历框架，兼具迭代和递归结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != <span class="keyword">null</span>;p = p.next)&#123;</span><br><span class="line">        <span class="comment">//访问并操作p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，二叉树遍历框架，典型的非线性递归遍历结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D,二叉树框架扩展为N叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E，N叉树遍历扩展为图的遍历</p>
<p>与N叉树类似，但是要避免出现环型的遍历，所以要添加一个布尔类型的Visited来标记是否遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArcNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Boolean visited;<span class="comment">//这里图中的每个节点的visited初始值为false</span></span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历有好几种，深度优先，广度优先，以及非递归，这里类似于N叉树，写深度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ArcNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.visited == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//访问并操作root.val</span></span><br><span class="line">     	root.visited = <span class="keyword">true</span>;</span><br><span class="line">   	 	<span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        	traverse(child);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-算法刷题指南"><a href="#3-算法刷题指南" class="headerlink" title="3,算法刷题指南"></a>3,算法刷题指南</h2><p>首先，<strong>数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法</strong>  ，所以在刷算法之前，应该了解常用的数据结构以及它们的基本操作和优缺点（散列表、栈、队列、堆、树、图等等）</p>
<p>然后，<strong>先刷⼆叉树，</strong>因为二叉树是最容易帮助人建立起框架思维的，对于一道二叉树相关的题，可以分为几个阶段：1，认识出这是一个能通过二叉树解决的问题；2，能写出答题的总体步骤（前序，中序，还是后序？），之中的一些细节就算写错，也不会错到哪儿去；3，扩展到解决其他问题（动态规划，回溯算法等等）</p>
<p><strong>注：</strong>这里我的理解是，二叉树作为一个在整个算法系统中的中间位置，能够很高的起到锻炼的作用，熟悉了二叉树后，简单的题目中的思路可以从二叉树中提取，复杂的题目可以从二叉树中扩展。</p>
<h1 id="二，计算机算法的本质"><a href="#二，计算机算法的本质" class="headerlink" title="二，计算机算法的本质"></a>二，计算机算法的本质</h1><h2 id="1，核心"><a href="#1，核心" class="headerlink" title="1，核心"></a>1，核心</h2><p>算法的本质就是穷举。(当然，某些问题可以通过总结规律解决，某些问题可以通过数学算法解决，但是绝大多数问题都是穷举)</p>
<p>但是此处的穷举并不是指暴力破解那样的寻找，因为一个问题的答案往往有很多条路，所以“穷举”思维，是包含两个层次的含义，如何穷举<strong>和</strong>如何聪明的穷举**，每道题的难点是不一样的</p>
<h3 id="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"><a href="#（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。" class="headerlink" title="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"></a>（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</h3><blockquote>
<p>（P19）前⽂ 动态规划核⼼套路 阐述了动态规划系列问题的核⼼原理，⽆⾮就是先写出暴⼒穷举解法（状态转移⽅程），加个备忘录就成⾃顶向下的动态规划解法了，再改⼀改就成⾃底向上的迭代解法了，动态规划的降维打击 ⾥也讲过如何分析优化动态规划算法的空间复杂度  </p>
<p>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧⼀听就会<br>了。但很多读者留⾔说明⽩了这些原理，遇到动态规划题⽬还是不会做，因为第⼀步的暴⼒解法都写不出<br>来。</p>
<p>这很正常，因为动态规划类型的题⽬可以千奇百怪，找状态转移⽅程才是难点，所以才有了 动态规划设计⽅<br>法：最⻓递增⼦序列 这篇⽂章，告诉你递归穷举的核⼼是数学归纳法，明确函数的定义，然后利⽤这个定义<br>写递归函数，就可以穷举出所有可⾏解。  </p>
</blockquote>
<h3 id="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"><a href="#（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。" class="headerlink" title="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"></a>（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</h3><blockquote>
<p>（p19）⽐如前⽂ Union Find 并查集算法详解 告诉你⼀种⾼效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我⽤ DFS&#x2F;BFS 暴⼒搜索（穷举）肯定可以做到，但⼈家 Union Find 算法硬是⽤数组模拟树结构，给你把连通性相关的操作复杂度给⼲到 O(1) 了。这就属于聪明地穷举，你学过就会⽤，没学过恐怕很难想出这种思路。</p>
<p>再⽐如贪⼼算法技巧，前⽂ 当⽼司机学会贪⼼算法 就告诉你，所谓贪⼼算法就是在题⽬中发现⼀些规律（专业点叫贪⼼选择性质），使得你不⽤完整穷举所有解就可以得出答案。</p>
<p>⼈家动态规划好⽍是⽆冗余地穷举所有解，然后找⼀个最值，你贪⼼算法可好，都不⽤穷举所有解就可以找<br>到答案，所以前⽂ 贪⼼算法解决跳跃游戏 中贪⼼算法的效率⽐动态规划还⾼。</p>
<p>再⽐如⼤名鼎鼎的 KMP 算法，你写个字符串暴⼒匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复⽤⼀些信息，减少了冗余计算，前⽂ KMP 字符匹配算法 就是使⽤状态机的思路实现<br>的 KMP 算法。  </p>
</blockquote>
<h1 id="三，基础数据结构"><a href="#三，基础数据结构" class="headerlink" title="三，基础数据结构"></a>三，基础数据结构</h1><h2 id="1，数组-x2F-链表"><a href="#1，数组-x2F-链表" class="headerlink" title="1，数组&#x2F;链表"></a>1，数组&#x2F;链表</h2><h3 id="（1）前缀和数组"><a href="#（1）前缀和数组" class="headerlink" title="（1）前缀和数组"></a>（1）前缀和数组</h3><p>前缀和，指的是在在计算中，如果要频繁的读取一段区间内的值，那么设定一个基准点，将该基准点以及到各个索引之间的值先计算出来并记录，这样再进行新区间值的计算的时候，能够避免重复计算。</p>
<p><u><strong>力扣303题——区域和检索-数组不可变</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png" alt="sf-1-1"></p>
<p>如果是不考虑时间复杂度，那么每次计算两个索引范围之间的和，都会进行一次数组的遍历，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.nums = nums;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		res += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目要求降低时间复杂度，那么我们要尽量避免同样的操作，前缀和数组就能帮助我们解决这样的问题，主要思路是，建立一个新的数组preSum，然后对于原来的数组nums，以0位基准，将不同范围的nums数组和存储在preSum中，也就是preSum[1]-&gt;sum[0]，preSum[4]-&gt;sum[0] + sum[1]+sum[2] + preSum[3]，那么求索引1~3之间的和，即可用preSum[3+1] - preSum[1]即可。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前缀和数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">	<span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">			preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣304题——二维区域和检索-矩阵不可变</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png" alt="sf-1-2"></p>
<p>此题和上一题类似，还是需要先计算矩阵的前缀和，只是此处的前缀和和上题不同，那么在这里我们需要什么样的前缀和呢？基准点是哪个呢?我们先看一下下面的计算过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png" alt="sf-1-3"></p>
<p>​    要计算红框里的数组和（坐标：2,1,4,3），它的值就等于黄框（0,0,4,3）减去粉框（0,0,1,3）减去绿框（0,0,4,0）最后加上紫框（0,0,1,0），这样我们就将基准点设置好了，同时我们也知道，需要计算的前缀和为坐标为（0,0,x,y）的框的和（x，y为不同的坐标点），利用这些坐标和，就可以算出所有的小框里的数字和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] preSum;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">			preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i- <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ⽬标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">		<span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] +preSum[x1][y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣560——和为k的子数组</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png" alt="sf-1-4"></p>
<p>这道题基础的做法是采用穷举所有子数组的做法，并检查他们是否和为K。但是这种做法太简单了，我们可以尝试用前缀和，有了前缀和在穷举子数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// 构造前缀和</span></span><br><span class="line">	<span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 穷举所有⼦数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)	</span><br><span class="line">			<span class="comment">// ⼦数组 nums[j..i-1] 的元素和</span></span><br><span class="line">			<span class="keyword">if</span> (preSum[i] - preSum[j] == k)</span><br><span class="line">				res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这里的时间复杂度还是o(N^2)，空间复杂度是o(N)（空间复杂度都挺高了时间复杂度没降下来说不过去），那么我们需要进行进一步的改良，一个思路是，我们能不能在计算前缀和的同时，判断该前缀和是否存在一个对应的相差为K的前缀和，如果有则统计次数加1，如果没有则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class="line">	HashMap&lt;Integer, Integer&gt;</span><br><span class="line">		preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// base case	</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum0_i += nums[i];</span><br><span class="line">		<span class="comment">// 这是我们想找的前缀和 nums[0..j]</span></span><br><span class="line">		<span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">		<span class="comment">// 如果前⾯有这个前缀和，则直接更新答案</span></span><br><span class="line">		<span class="keyword">if</span> (preSum.containsKey(sum0_j))</span><br><span class="line">			res += preSum.get(sum0_j);</span><br><span class="line">		<span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数</span></span><br><span class="line">		preSum.put(sum0_i,</span><br><span class="line">			preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）差分数组"><a href="#（2）差分数组" class="headerlink" title="（2）差分数组"></a>（2）差分数组</h3><p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和 。本节与前缀和数组类似，讲的是差分数组，指的是频繁对原始数组的某个区间的元素进⾏增减，最后的数组内容发生了改变。</p>
<p>**<u>引例</u>**：⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给…  最后的数组是什么样的呢？一般情况下，我们不断的循环遍历修改数组就行，但这样每次的时间复杂度都是O(n)，效率不高</p>
<p>所以我们需要使用<strong>差分数组</strong>，差分数组指的是构造一个新的数组diff[]，diff[i] &#x3D; nums[i] - nums[i - 1]（如图）,并且根据差分数组可以反推出原数组（设一个数组res[]，res[0] &#x3D; diff[0]，这样的话原数组res[i] &#x3D; res[i - 1] + diff[i]，其中i &gt;&#x3D; 1），</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png" alt="sf-1-5"></p>
<p>差分数组在频繁的修改某个区间的值中能够降低复杂度，比如要将区间 i ~ j 中的所有数都加3，那么可以将差分数组diff[i] +&#x3D; 3，diff[j] -&#x3D; 3，这样恢复为原数组的时候就可以实现这样的效果。原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -&#x3D; 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 。</p>
<p>差分数组的这些初始化操作，变化操作，以及恢复操作可以抽象为一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;<span class="comment">//assert对一个boolean表达式进行检查，一个正确运行的程序保证boolean值为true，若为false，则说明程序不正确，系统需要提供警告信息并且退出程序。</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] -nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处val可以是负数，另外如果j大于diff.length的话，就表明i之后的数组都要增加val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    	diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">        	diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣370——区间加法</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png" alt="sf-1-6"></p>
<p>这道题使用引例中实现的类即可。代码如下（省略了类的定义）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length,<span class="keyword">int</span>[][] updates)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    Difference difference = <span class="keyword">new</span> Difference(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] update : updates)&#123;</span><br><span class="line">        difference.increment(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1109——航班预订统计</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png" alt="sf-1-7"></p>
<p>本体也就是差分数组的变体，写法与上题大致相同，但是这里注意，航班的编号是1 ~ n！，对应数组中的0 ~ n-1!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Different different = <span class="keyword">new</span> Different(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] booking : bookings)&#123;</span><br><span class="line">        different.increment(booking[<span class="number">0</span>] - <span class="number">1</span>,booking[<span class="number">1</span>] - <span class="number">1</span>,booking[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> different.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1094——拼车</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png" alt="sf-1-8"></p>
<p>本题同样是差分数组的扩展，对于这种明显的问题，我们需要明确的是我们在模板中的nums[]，[i，j，val]数组，以及res[]数组的含义。在本题中，明显能发现trip[a,b,c]这个三维数组对应的是变化的标记，那么nums[]数组就是每站车上的人数（初始为0），最后的res[]就是车开了一遍后每站都有多少人。<u>我们判断能否一次性把顾客运送完，就先假设容量无限大，计算出res[],最后遍历res[]看途中是否有不符合条件的情况即可。</u>本题中没有直接说有多少车站，但是说明了车站的范围在0~1000之间，那么可设nums[1001]（初试值为0），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    Difference df = <span class="keyword">new</span> Difference(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] trip : trips)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = trip[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里注意，j站的时候已经下车啦</span></span><br><span class="line">        <span class="keyword">int</span> j = trip[<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = df.result();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h3><p><strong>引入：</strong>指的是一类问题，通过维护⼀个窗⼝，不断滑动，然后更新答案  。该算法时间复杂度为O（N），比字符串暴利算法高效很多。但是该思路存在很多细节问题：⽐如说如何向窗⼝中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果 …除此之外，出现了Bug调试也很困难。</p>
<p>所以根据labuladong笔记，其中总结了一个框架（包含了debug的输出提示），遇到相关类型，默写该框架，修改三个地方即可解决大部分滑动窗口题。(后面会有几道力扣的题进行使用展示)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need ,window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">//右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">        <span class="comment">//下面更新窗口数据</span></span><br><span class="line">        ...update...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面是debug输出的位置    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>,left,right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">           <span class="comment">//d 是将移出窗口的字符</span></span><br><span class="line">           <span class="keyword">char</span> d = s[left];</span><br><span class="line">           <span class="comment">//左移窗口</span></span><br><span class="line">           left++;</span><br><span class="line">           <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">           ...update...</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>滑动窗⼝很多时候都是在处理字符串相关的问题，Java 处理字符串不⽅便，所以本⽂代码为 C++ 实<br>现。不会⽤到什么编程⽅⾯的奇技淫巧，但是还是简单介绍⼀下⼀些⽤到的数据结构，以免有的读者因为语<br>⾔的细节问题阻碍对算法思想的理解：  </p>
<p>unordered_map 就是哈希表（字典），它的⼀个⽅法 count(key) 相当于 Java 的 containsKey(key)<br>可以判断键 key 是否存在。<br>        可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个<br>key，并把 map[key] 赋值为 0。<br>        所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) +1)。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingWindow</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组/字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量统计 子数组/子区间 是否有效</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量保存结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右指针遍历到数组尾</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">//增加当前右指针对应的数值</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">//当在该区间内 sum 超出定义范围</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                <span class="comment">//移动左指针并调整值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到 while 结束时，我们找到了一个符合题意要求的 子数组/子串，更新结果</span></span><br><span class="line">            res = </span><br><span class="line">            <span class="comment">//移动右指针，去探索下一个区间</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：ren-feiye</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subarray-product-less-than-k/solution/jian-dan-yi-dong-xiang-xi-zhu-jie-shuang-jvy3/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣76——最小覆盖子串</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png" alt="sf-1-9"></p>
<p>这道题我们将代码先贴在下面，然后结合图片观察滑动窗口实现的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,先更新start和len的值，然后左移窗口，取left处的字符d，然后自增1。更新操作：判断need中是否有字符d，存在的话（如果window中的d的次数和need中的一样，则valid自减1，）则window中的d的出现次数自减1。若字符d导致了valid自减1，start记录的位置是将其包含在内的。</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若跳出了上面的循环，则取s的子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，本题中的代码的运行流程应该是下面这样，读者可以自己手动过一遍，加强印象</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png" alt="sf-1-10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png" alt="sf-1-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png" alt="sf-1-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png" alt="sf-1-13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png" alt="sf-1-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png" alt="sf-1-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png" alt="sf-1-16"></p>
<blockquote>
<p>使⽤ Java 的读者要尤其警惕语⾔特性的陷阱。Java 的 Integer，String 等类型判定相等应该⽤<br>equals ⽅法⽽不能直接⽤等号 &#x3D;&#x3D;，这是 Java包装类的⼀个隐晦细节。所以在左移窗⼝更新数据的时<br>候，不能直接改写为 window.get(d) &#x3D;&#x3D; need.get(d)，⽽要⽤window.get(d).equals(need.get(d))，之后的题⽬代码同理。  </p>
</blockquote>
<p><strong><u>力扣567——字符串排列</u></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png" alt="sf-1-17" style="zoom:67%;" />

<p>说明：本题第目的就是给你⼀个 s1 和⼀个 s2，请问你 s2中是否存在⼀个⼦串，包含 s1 中所有字符且不包含其他字符？  这里注意，s1中可以包含相同的字符串。</p>
<p>这道题应用在框架中要注意几点：1）窗口在往右扩大时，是一样的，将对应的字母都要包含的窗口中。2）收缩窗口时便有所不同，首先窗口的关闭条件应该是，while（right - left &gt;&#x3D; t.size()），这样才能保证及时缩小窗口。3）在缩小的过程中，一旦valid &#x3D;&#x3D; need.size()  ，便表明找到了最后的答案。    具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,这里窗口收缩的条件不同，right和left限制了一个与目标字符串相同大小的窗口，并且本题不需要记录该字符串的位置，所以也不需要start和len</span></span><br><span class="line">        <span class="comment">// while(valid == need.size())</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">		   <span class="comment">//这里注意，valid值如果与need的值相同，则表明当前窗口下的size个字符都是我们需要的字符</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的循环没有返回true，那就一定是false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣438——找到字符串中所有字母异位词</strong></u></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png" alt="sf-1-18" style="zoom:67%;" />

<p>说明：本题扩大窗口没有特殊的地方，收缩窗口时注意记录子串的起始索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣3——最长不重复子串</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png" alt="sf-1-19"></p>
<p>说明：本题没有固定的字符串对应，所以不需要need数组，也不需要valid来记录情况，但是需要window数组来记录窗口中字符的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">char</span> d = s[left];</span><br><span class="line">             left++;</span><br><span class="line">			window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）二分搜索框架"><a href="#（4）二分搜索框架" class="headerlink" title="（4）二分搜索框架"></a>（4）二分搜索框架</h3><p><strong>引入</strong>：⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。⽽且，我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的⼆分查找算法  。下面是二分查找的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">     	<span class="keyword">int</span> mid = left + (right - left)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚，读者理解后可⾃⾏简化。<br>    其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样的变化。<br>    另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) &#x2F; 2 就和 (left +right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。  </p>
<p>接下来说明几个二分搜索的应用场景：</p>
<p><strong><u>寻找一个数（基本的二分搜索）</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left =  mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该算法有几个注意的地方：    1）while判断条件是（left &lt;&#x3D; right），而不是（left &lt; right），我们使用的闭区间搜索（因为right赋值为nums.length - 1)，若此时left和right都是2的话，while(left &lt; right)这个判断语句就会错过2这个下标所代表的位置；      2）当判断过mid位置的数字后，left和right的更新就对应的+1和-1；      3）该算法无法处理有多个结果的情况，比如在数组nums &#x3D; [1,2,2,2,3]中搜索数字2，只能得到索引2，无法得到左侧的索引1和右侧的索引2.</p>
<p><strong><u>寻找左侧边界的二分搜索</u></strong></p>
<p>下面的算法是左右都是闭区间检查，那么rigth的初试值就是nums.length - 1，while的终止条件就是left &#x3D; right + 1。这里要注意，循环的退出条件既然变成了left &#x3D; right + 1，那么如果一个数组中的左右元素都比target小，left就会比right大，所以最后那里需要进行判读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_boud</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.lenght - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>寻找右侧边界的二分查找</u></strong></p>
<p>下面是两边闭区间的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; taeget)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是左侧还是右侧边界的搜索，其实可以抽象为一定范围内的找极值的行为，比如对于nums &#x3D; [1,2,3,3,3,5,7]，想搜索target &#x3D; 3，搜索左侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-20.png" alt="sf-1-20"></p>
<p>搜索右侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-21.png" alt="sf-1-21"></p>
<p>是不是有一种做函数题的感觉</p>
<h3 id="（5）二分搜索题型"><a href="#（5）二分搜索题型" class="headerlink" title="（5）二分搜索题型"></a>（5）二分搜索题型</h3><p>⽂总结的⼆分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够⽤到⼆分搜索 。所以接下来需要一套二分搜索算法应用的套路（思路）</p>
<p><strong>首先</strong>，什么样的题可以使用二分搜索的技巧呢？一般是符合以下条件的题：</p>
<p>可以从题目中抽象出一个自变量x，关于x的函数f(x)，以及一个目标值target，同时x，f(x)，target需要满足以下条件</p>
<p>1，f(x)必须是在x上的单调函数（单增单减都可以）</p>
<p>2，题目要求计算f(x) &#x3D;&#x3D; target时的x的值</p>
<p>对于上一节的例子（就是nums &#x3D; [1,2,3,3,3,5,7]，搜索左侧target &#x3D; 3），可以抽象为下面这样的形式（虽然没必要）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid, nums) == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || f(left, nums) != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，对于一个需要二分搜索解决的问题，我们的思考点应该是几个方面，具体见下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1,根据题意确定x的最小值是多少</span></span><br><span class="line">    <span class="keyword">int</span> left = ...;</span><br><span class="line">    <span class="comment">//2,根据题意确定x的最小值是多少（这个是闭区间写法）</span></span><br><span class="line">    <span class="keyword">int</span> right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= rigth)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//3,怎么让f(x)大一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//4,怎么让f(x)小一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//5,题目求的左边界还是右边界（注意是闭区间写法）</span></span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6,闭区间需要判断是都超出范围</span></span><br><span class="line">    <span class="keyword">if</span> ...;</span><br><span class="line">    <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，想用二分搜索来解决问题的话，主要有以下几步：</p>
<ul>
<li>确定 x, f(x), target 分别是什么，并写出函数 f 的代码  </li>
<li>找到 x 的取值范围作为⼆分搜索的搜索区间，初始化 left 和 right 变量。  </li>
<li>根据题⽬的要求，确定应该使⽤搜索左侧还是搜索右侧的⼆分搜索算法，写出解法代码</li>
</ul>
<p><strong>力扣875——爱吃香蕉的珂珂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</span><br><span class="line"></span><br><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        Tool tool  = <span class="keyword">new</span> Tool();</span><br><span class="line">        <span class="keyword">int</span>[] res = tool.getMaxandMin(piles);</span><br><span class="line">        <span class="keyword">int</span> min = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = res[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getTime(piles,mid) &lt; h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) == h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] getMaxandMin(<span class="keyword">int</span>[] piles)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &gt; max)&#123;</span><br><span class="line">                max = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &lt; min)&#123;</span><br><span class="line">                min = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = min;</span><br><span class="line">        res[<span class="number">1</span>] = max;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            res += (pile % speed == <span class="number">0</span>) ? (pile / speed) : (pile / speed + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1011——在D天内送达包裹的能力</u></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line">返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= days &lt;= weights.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= weights[i] &lt;= 500</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">5000000</span>;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights,mid) == -<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights, mid) &lt; days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights, mid) &gt; days)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights,mid) == days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">5000000</span>) <span class="keyword">return</span> <span class="number">5000000</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &gt; capacity)&#123;</span><br><span class="line">                loc = -<span class="number">1</span>;</span><br><span class="line">                day = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp + weights[i] &gt; capacity)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                loc = i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt; weights.length &amp;&amp; loc != -<span class="number">1</span>)&#123;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）优势洗牌"><a href="#（6）优势洗牌" class="headerlink" title="（6）优势洗牌"></a>（6）优势洗牌</h3><p>该点与双指针关联，这里暂时不添加</p>
<h3 id="（7）原地修改数组"><a href="#（7）原地修改数组" class="headerlink" title="（7）原地修改数组"></a>（7）原地修改数组</h3><p><u><strong>力扣26——删除排序数组中的重复项</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-22.png" alt="sf-1-22"></p>
<p><strong>说明</strong>：由于不能新建数组，所以只能通过指针去探测并记录，在此基础上更新。一个指针无法确定新的元素和应该插入的位置，所以这里需要使用双指针，一个记录插入的位置，一个进行探测，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">           slow ++;</span><br><span class="line">           nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣83——删除排序链表中的重复元素</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-23.png" alt="sf-1-23"></p>
<p><strong>说明</strong>：本题和上一题（力扣26）其实是一样的，只是把数据结构换成了链表，并且多了删除链表的操作，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.val != slow.val)&#123;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣27——移除元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-24.png" alt="sf-1-24"></p>
<p>说明：此题和前面是类似的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣283——移动零)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-25.png" alt="sf-1-25"></p>
<p><strong>说明</strong>：同样用快慢指针就可以了，两种方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,可以使用快慢指针，首先将low指针定位打0的位置出，然后移动fast指针寻找非0的元素进行调换即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] != <span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; nums.length &amp;&amp; nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                nums[fast] = <span class="number">0</span>;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2, 将问题转化，将所有非零元素往前移，然后再将后面多出的元素设为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = removeElement(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(; p &lt; nums.length; p++)&#123;</span><br><span class="line">        nums[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）单链表解题技巧总结"><a href="#（8）单链表解题技巧总结" class="headerlink" title="（8）单链表解题技巧总结"></a>（8）单链表解题技巧总结</h3><p>单链表中，比较常用的操作有：1）合并两个有序链表    2）合并 k 个有序链表    3）寻找单链表的倒数第 k 个节点    4）寻找单链表的中点    5）寻找单链表的中点    6）寻找单链表的中点 。这些解法都⽤到了双指针技巧  ，下面以具体的题来说明</p>
<p><strong>（力扣21——合并两个有序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-26.png" alt="sf-1-26"></p>
<p><strong>说明</strong>：本题可以实现只遍历一次（开辟新的空间），需要使用三个指针，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(list1 == null || list2 == null)&#123;</span></span><br><span class="line">        <span class="comment">//     if(list1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list1;</span></span><br><span class="line">        <span class="comment">//     &#125;else if(list2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list2;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ListNode p1 = list1;</span></span><br><span class="line">        <span class="comment">// ListNode p2 = list2;</span></span><br><span class="line">        <span class="comment">// ListNode head = null;</span></span><br><span class="line">        <span class="comment">// ListNode p = null;</span></span><br><span class="line">        <span class="comment">//if(p1.val &lt;= p2.val)&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p1;</span></span><br><span class="line">        <span class="comment">//    p1 = p1.next;</span></span><br><span class="line">        <span class="comment">//&#125;else&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p2;</span></span><br><span class="line">        <span class="comment">//    p2 = p2.next;</span></span><br><span class="line">        <span class="comment">//&#125;  </span></span><br><span class="line">	  ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">	  ListNode p1 = list1, p2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &lt;= p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣23——合并K个升序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-27.png" alt="sf-1-27"></p>
<p><strong>说明</strong>：本题和上题类似，关键是快速找到不同链表指针指向位置的最小值，我在自己做的时候，每次挑选最小的节点都要遍历一遍当前节点，如下，时间复杂度（on2）空间复杂度都很高，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        ListNode[] plist = <span class="keyword">new</span> ListNode[lists.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            plist[i] = lists[i];</span><br><span class="line">            <span class="keyword">if</span>(lists[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; plist.length - <span class="number">1</span>)&#123;</span><br><span class="line">            min = tool.getMin(plist);</span><br><span class="line">            p.next = plist[min];</span><br><span class="line">            p = p.next;</span><br><span class="line">            plist[min] = plist[min].next;</span><br><span class="line">            <span class="keyword">if</span>(plist[min] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode temp : plist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(ListNode[] comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; comp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( comp[i] != <span class="keyword">null</span> &amp;&amp; min == -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(comp[i] != <span class="keyword">null</span> &amp;&amp;  (comp[i].val &lt; comp[min].val) &amp;&amp; min != -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题解用了<strong>优先级队列（二叉堆）</strong>这种数据结构，时间复杂度仅有O(Nlogk)，其中 k 是链表的条数，N 是这些链表<br>的节点总数。代码如下：（这里使用了java的类，如果题目要求实现一个优先级队列，java有相关的实现类，原理的话<a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">看这篇文章</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, lists)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1，设置虚拟头结点，统一操作</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">//2，使用了java的PriorityQueue（优先级队列），第二个参数是lamda表达式，表明现在是按升序排列</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, (a,b)-&gt;(a.val - b.val))</span><br><span class="line">    <span class="comment">//3，将K个链表的头结点加入pq这个最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//pq的poll()方法可以提取出堆头元素</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p指针推进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣19——删除链表的倒数第N个节点）</strong></p>
<p><strong>前言</strong>：链表不同于数组，可以快速定位到特定的位置。如果要定位某些特殊的位置（比如倒数第k个节点），最高效的方式也至少需要一次遍历中找到对应位置（采用双指针），一般思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的倒数第K个节点</span></span><br><span class="line"><span class="function">ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">//p1先走k步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">//p1和p2同时走n - k步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p2现在指向第n - k个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>—————————————————————我是分割线————————————————————————</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-28.png" alt="sf-1-28"></p>
<p>说明：本题采用上面的思路进行啦，不过要删除倒数第N个节点，我们需要找到的是倒数第N+1个节点，那么就把前一个指针往前放一位就可以了（第6行中的p1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode p1 = dummy,p2 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣876——链表的中间节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-29.png" alt="sf-1-29"></p>
<p><strong>说明</strong>：其实这题和上一道题类似，都是用双指针，只是这道题比较含蓄，需要找中点，其实也就是两个指针，快的那个比慢的多走一倍即可，这样慢的那个就在中间的位置。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">//这里的思路挺有意思，你必须保证fast能走两步，你的slow才能走一步，fast走两步可以落在null上，但是不能第一步就在null上</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣141——相交链表）</strong><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-30.png" alt="sf-1-30"></p>
<p><strong>说明</strong>：<u>判断链表是否包含环</u>也是链表题型中的一个重要的课题，参考上面的代码，其实也可以用快慢指针来寻找，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，快慢指针初始化指向head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">//2，快指针走到末尾时停止（它也可能没末尾）</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3，走的步伐不一样</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">//4，两个指针相遇，那就说明有换</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这儿那就是没环了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣——剑指offer——链表中环的入口节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-31.png" alt="sf-1-31"></p>
<p><strong>说明</strong>：此题可以转化一下，类比于上面的一题的思路，我们让slow和fast两个速率不同的指针移动，如果fast指针最终指向了null，那么说明没有环；反之，如果存在环，两个指针进入环后，必定会在起点相遇</p>
<p>为什么不是在其他地方相遇呢？这个就很有意思了，类似于小学学的行程问题，这里我就不画图了，直接用labuladong公众号中的图说明，分为几个步骤：1)当两个指针在C点相遇时，假设走了slow指针走了k步，那么fast走了2k步，<strong>多走的k就是环长度的整数倍</strong>（考虑环只有一个元素的特殊情况便可理解）；2）将slow重新放到A点，那么slow走到B点需要k-m步，此时fast指针就和slow指针<strong>同样的速度</strong>走，就会在B点相遇。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-32.png" alt="sf-1-32"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lpublic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head,fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>力扣160——两个链表是否相交</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-33.png" alt="sf-1-33"></p>
<p><strong>说明</strong>：本题多种思路，首先利用上一题的判断环入口可以实现，也就是将第一条链表的尾接在第二条链表的头上。</p>
<p>第二种思路，统计长度，然后将两个链表的指针放在相同的起始点上，进而进行比较。下面是这种思路的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;p2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)&#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（9）递归操作链表"><a href="#（9）递归操作链表" class="headerlink" title="（9）递归操作链表"></a>（9）递归操作链表</h3><p><strong>（力扣——206）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-34.png" alt="sf-1-34"></p>
<p><strong>说明</strong>：本题有两种做法，非递归和递归方法，先说比较简单但不是重点的非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归解法，这里比较好理解就不多解释了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p1 = head, p2 = head.next, p3 = head.next.next;</span><br><span class="line">        p1.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            <span class="keyword">if</span>(p3 == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归解法，看下面的补充进行理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：整个reverse函数的目标是——输⼊⼀个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点，我们可以根据以下几个图来理解整个步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-35.png" alt="sf-1-35"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-36.png" alt="sf-1-36"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-37.png" alt="sf-1-37"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-38.png" alt="sf-1-38"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-40.png" alt="sf-1-40"></p>
<p><strong>（反转链表的前N个节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-39.png" alt="sf-1-39"></p>
<p>说明：这个似乎在力扣上没有对应的题，这里在上题的基础上，可以写出下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode successor = <span class="keyword">null</span>;<span class="comment">//这里设计一个后驱节点</span></span><br><span class="line"><span class="comment">//反转以head为起点的n个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseN</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//记录第n + 1个节点（也处理了一个节点的情况）</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以head.next为起点，需要反转前n - 1个节点</span></span><br><span class="line">    ListNode last = reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反转完过后，将节点指向互换，并将head指向后一个节点（就像图中的1指向4）</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣92——反转链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-41.png" alt="sf-1-41"></p>
<p><strong>说明</strong>：此题在使用前面函数的基础上，用递归的思想能够很快写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，如果left为1，其实就是上题的反转形式</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，我们要想办法把left变为1，那么也就是把head的位置往后移动，head每往后移动一个位置，其实反转的区间的相对位置就会减1.</span></span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，队列-x2F-栈（不知道为啥就跳到3了）"><a href="#3，队列-x2F-栈（不知道为啥就跳到3了）" class="headerlink" title="3，队列&#x2F;栈（不知道为啥就跳到3了）"></a>3，队列&#x2F;栈（不知道为啥就跳到3了）</h2><h3 id="（1）队列实现栈，以及栈实现队列"><a href="#（1）队列实现栈，以及栈实现队列" class="headerlink" title="（1）队列实现栈，以及栈实现队列"></a>（1）队列实现栈，以及栈实现队列</h3><p><strong>（力扣232——用栈实现队列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-42.png" alt="sf-1-42"></p>
<p><strong>说明</strong>：实现和这个代码，我们需要使用到java中的Stack类，这是一个Vector的子类，它的方法有：1）boolean empty()，判断栈是否为空，空返回true；2）Object peek()，返回栈顶元素，但不删除；3）Object pop(Object element)，返回栈顶元素，并删除；4）Object push(Object element)，将元素入栈并返回元素；5）int search(Object element)，寻找某元素并返回到栈顶的偏移量。了解了这个，那这道题就好办了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> Stack&lt;Integer&gt; s1, s2;</span><br><span class="line">    <span class="comment">//先在构造器中初始化两个栈，栈需要用泛型来制定存储的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入队列就直接进入s1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出队列，先调用peek将s1中的元素放到s2,s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶，那就需要先把s1的元素放到s2，s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty()) s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣225——用队列实现栈）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-43.png" alt="sf-1-43"></p>
<p><strong>说明</strong>：这里需要使用到java中的Queue这个类，它的方法有：1）offer()，从队尾压入元素，返回压入的那个元素；2）poll()，删除并返回对队头被删除的那个元素；3）peek()，获取并返回队头元素。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> top_elem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列中新添加的元素在队尾，其实就是栈顶元素，所以用top_elem记录一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.offer(x);</span><br><span class="line">        top_elem = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈顶元素直接返回top_elem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top_elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//想要出栈，直接把队尾之前的元素统统出队再入队，最后队头就是栈顶元素，但是我们出的时候不要一次性出完，还得     //更新一下top_elem的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        top_elem = q.peek();</span><br><span class="line">        q.offer(q.poll());</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接判断队是不是空就行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（2）括号匹配问题"><a href="#（2）括号匹配问题" class="headerlink" title="（2）括号匹配问题"></a>（2）括号匹配问题</h3><p><strong>（力扣20——有效的括号）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-44.png" alt="sf-1-44"></p>
<p><strong>说明</strong>：单纯的统计左括号和有括号的数量是否相同是不行滴，因为位置有可能对不上，既然出现了位置，那么就能使用栈的特性来进行括号的匹配，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意两点：1）java中Stack的泛型指定只能使用包装类，不过由于自动装箱和自动转换，这个倒是影响不大；2）Stack类的方法要记清楚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; left = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                left.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!left.empty() &amp;&amp; leftOf(c) == left.peek())&#123;</span><br><span class="line">                    left.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣921——使括号有效的最小添加）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-45.png" alt="sf-1-45"></p>
<p><strong>说明</strong>：原题还说了字符串中只包含’(‘和’)’两种字符。其实和上一题类似，只是这里要设置一个计数器，我们遇到左括号入栈，遇到有括号则检查是不是有对应的左括号（没有的话，计数器加一），最后当遍历完字符串后，计数器再加上栈剩余的元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使用栈来解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) stack.push(c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2，不使用栈,以左括号为基准，通过维护对右括号的需求数 need，来计算最⼩的插⼊次数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) need++;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            	need--;</span><br><span class="line">                <span class="comment">//当need为-1的时候，意味着需要插入左括号了</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1541——平衡括号字符串的最好插入次数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-46.png" alt="sf-1-46"></p>
<p><strong>说明</strong>：如果按照上一题的维护res和need变量的话，要考虑几个特殊情况：1）一个左括号对应两个右括号，那么遇到左括号，need值应该+2；2）如果need值为-1的话，那么多了一个右括号，此时res应该+1，表明需要一个左括号，并且need重设为1；3）反观第1）步，如果对有括号的需求为奇数，那么只需要插入一个右括号，所以这里需要进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                need += <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//res其实对应了右括号的插入，这里need为奇数，表明前面需要一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                need--;</span><br><span class="line">                <span class="comment">//这里res表明了需要一个左括号的插入，同时需要多对应一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）单调栈"><a href="#（3）单调栈" class="headerlink" title="（3）单调栈"></a>（3）单调栈</h3><p><strong>引入</strong>：单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈后，栈内的元素都保持有序（单调<br>递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型的问题，叫做 Next Greater Element。本⽂⽤讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略  </p>
<p><strong>模板</strong>：给你⼀个数组 nums，请你返回⼀个等⻓的结果数组，结果数组中对应索引存储着下⼀个更⼤元素，如果没有<br>更⼤的元素，就存 -1  。（比如输入nums &#x3D; [2,1,2,4,3]，返回[4,2,4,-1,-1]，也就是第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1 ）</p>
<p>其实没那么复杂，把这一串数字的每一个从后往前放到栈中，然后新的数字来了以后，看栈中的数字大小怎么样，如果比当前的数字小就出栈，否则，你就是它要找的那个数字呀！（这里注意栈空就是表明应该是-1）</p>
<p>倒着⼊栈，其实是正着出栈。while 循环是把两个「个⼦⾼」元素之间的元素排除，因为他们的存在没有意义，前⾯挡着个「更⾼」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">find</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek())&#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">           stack.push(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣739——每日温度)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-47.png" alt="sf-1-47"></p>
<p>这里我们把栈里记录的信息改为下标，就可以实现算出气温高的天数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temperatures.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt;= temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = stack.isEmpty() ? <span class="number">0</span> : stack.peek() - i;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣503——处理环形数组）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-48.png" alt="sf-1-48"></p>
<p><strong>说明</strong>：这题在之前的基础上又麻烦了，两个思路：一个是将数组翻倍，这样的话可以直接套用上面的模板；另一个思路是通过%运算符来实现环形效果。两种方式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，扩展数组的写法，这个还比较简单好理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] numsEx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            numsEx[i] = nums[i];</span><br><span class="line">            numsEx[i + nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numsEx.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; numsEx[i] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(numsEx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2，使用循环数组模拟扩展的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % n] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i % n] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）单调队列解决滑动窗口"><a href="#（4）单调队列解决滑动窗口" class="headerlink" title="（4）单调队列解决滑动窗口"></a>（4）单调队列解决滑动窗口</h3><p><strong>引入</strong>：这里只讲一道题，<strong>力扣239——滑动窗口最大值</strong>，这道题需要使用单调队列来解决，单调队列指的是：一个队列，其中的元素全都是单调递增（或递减）的。</p>
<p><strong>题目</strong>：给你输⼊⼀个数组 nums 和⼀个正整数 k，有⼀个⼤⼩为 k 的窗⼝在 nums 上从左⾄右滑动，请你输出每次<br>窗⼝中 k 个元素的最⼤值。  示例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-50.png" alt="sf-1-50"></p>
<p><strong>步骤</strong>：</p>
<p><u>A，搭建解题框架</u></p>
<p>本题的难点在于如何在 O(1) 时间算出每个「窗⼝」中的最⼤值，使得整个算法在线性时间完成。这种问题的⼀个特殊点在于，「窗⼝」是不断滑动的，也就是你得动态地计算窗⼝中的最⼤值。</p>
<p>假设我们已经有一个单调队列 MonotonicQueue类，有添加元素（push），返回当前最大元素（max），删除元素（pop）方法，并且时间复杂度都是O(1)，使用这个类可以搭出框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;<span class="comment">//两个参数，一个是数组，一个是我们要扫描的窗口</span></span><br><span class="line">    MonotonicQueue window = <span class="keyword">new</span> MononicQueue();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先在窗口中预备好k - 1个元素</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//进入了这个分支就意味着要开始滑动了，先进入一个</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            <span class="comment">//然后找到当前窗口最大值</span></span><br><span class="line">            res.add(window.max());</span><br><span class="line">            <span class="comment">//最后退出一个（注意这里是退出指定的元素哦）</span></span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            arr[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-51.png" alt="sf-1-51" style="zoom:67%;" />

<p><u>B，实现单调队列数据结构</u></p>
<p>「单调队列」的核⼼思路和「单调栈」类似：1）push ()⽅法依然在队尾添加元素，但是要把前⾯⽐⾃⼰⼩的元素<br>都删掉，这样这窗口中的元素入队后，队头始终是最大的按个元素（如果队头和新来新来的元素一样大，那可就千万别动了）；2）max()方法的话，就直接取队头咯；3）pop()方法的话，先判断一下队头元素是不是和之前插入的元素一样，一样再出队，不然可能早就没了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.getLast() &lt; n)&#123;</span><br><span class="line">            q.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        a.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == q.getFirst())&#123;</span><br><span class="line">            q.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，实现 MonotonicQueue 时，我们使⽤了 Java 的 LinkedList，因为链表结构⽀持在头部和尾部快速增删元素；⽽在解法代码中的 res 则使⽤的 ArrayList 结构，因为后续会按照索引取元素，所以数组结构更合适</p>
<h3 id="（5）数组去重"><a href="#（5）数组去重" class="headerlink" title="（5）数组去重"></a>（5）数组去重</h3><p>数组去重其实前面已经练习过，这里是两道增强的题，加上前面的题，应该可以解决大部分问题</p>
<p><strong>（力扣316——去除重复字母）</strong></p>
<p>本题与力扣1081题解法相同</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-52.png" alt="sf-1-52" style="zoom:80%;" />

<p><strong>说明</strong>：本题有两个难点：1）去重字符串中的字符串顺序不能打乱s中字符出现的相对顺序；2）在符合上一条的去重字符串中，字典序最小的为输出（比如示例1，bca和abc都是去重的，但是abc的字典序更小）</p>
<p>这里最好自己手动分析一下，值得注意的是，如果没有1,4，步骤，那么s &#x3D; “bcac”的结果就是ac</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">//1,新建一个数组来统计字符串中不同字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] instack = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//2，每个字符串在进行判断时，都需要将次数-1，这样剩下的数字才能准确反映还有多少，如果这个字母已经在instack数组中了，那么就不用检查了</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span>(instack[c]) <span class="keyword">continue</span>;</span><br><span class="line">		   <span class="comment">//3,要保证字典序，那么入栈的时候，尽量要将小的放底下</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; stk.peek() &gt; c)&#123;</span><br><span class="line">                <span class="comment">//4，对于栈中更大的元素，如果以后还有这个元素，则可以出栈，但是如果没有就别出了，这里也不是continue嗷，因为这个元素是确实需要的去重的一份子</span></span><br><span class="line">                <span class="keyword">if</span>(count[stk.peek()] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//5，出栈了就变为false</span></span><br><span class="line">                instack[stk.pop()] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            instack[c] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6，最终栈中的元素出栈，顺序是反的，还得翻转一下</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，数据结构设计"><a href="#4，数据结构设计" class="headerlink" title="4，数据结构设计"></a>4，数据结构设计</h2><p>数据结构设计题主要就是给你提需求，让你实现 API，⽽且要求这些 API 的复杂度尽可能低 ，一般来说设计题中哈希表的出现频率很⾼，⼀般都是各类其他数据结构和哈希表组合，从⽽改善这些基本数据结构的特性。</p>
<h3 id="（1）实现LRU算法（最近最少使用算法）"><a href="#（1）实现LRU算法（最近最少使用算法）" class="headerlink" title="（1）实现LRU算法（最近最少使用算法）"></a>（1）实现LRU算法（<strong>最近最少使用算法</strong>）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-53.png" alt="sf-1-53"></p>
<p><strong>思路</strong>：</p>
<p>题目要求：1）put和get方法的时间复杂度为O(1)；2）该catch中的元素必须有时序；3）catch中需要快速找到某个key是否已经存在并得到对应的val；4）每次访问catch中的某个key，这个元素的时序要改为最近使用，也就是快速把这个元素抽出来换位置。为了实现这个目标，我们需要使用<strong>哈希链表（双向链表+哈希表）</strong>，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-54.png" alt="sf-1-54" style="zoom:50%;" />

<p>上面的数据结构中，如何满足上面的条件？1）默认从链表尾部添加元素的话，那么越靠近尾部是越近使用的（已经存在的可以先拆下来放到尾部去）；2）对于某个key，可以通过hash表快速定位到链表中对应的节点，免去遍历链表的时间；3）双向链表支持任意位置的插入和删除。</p>
<p>下面我们看看分步骤的代码实现：</p>
<p>A，构建双链表节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = k;</span><br><span class="line">         <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，使用Node构建双链表（该结构要有 表尾添加，删除，表头删除，返回长度等API），双链表可以不用记录前驱结点实现操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，需要有头结点来统一操作</span></span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="comment">//2，链表的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3，链表初始化</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，在链尾加入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.pre = x; </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，删除元素，注意这里能使用该方法表明一定要有x这个节点，判断不在这里判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.pre;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6，删除链头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7，返回链表大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，与哈希表进行结合（这里先是使用上面的数据结构把LRUCatch的数据结构搭建）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，上一步的get和put方法，如果直接写会很容易出现问题，我们应该先抽象几个要使用的方法出来，从而是的get和put不直接操作map和catch，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//4个要使用的方法</span></span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，综合C和D中的内容，写出get和put方法，put方法有点复杂，先画一个运行流程图</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-55.png" alt="sf-1-55" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//2，Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//3，最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，get 和 put方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.contiansKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            deleteKey(key);</span><br><span class="line">            addRecently(key, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        addRecently(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，几个抽象出来的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：1）分析需要使用的数据结构；2）实现基本数据结构和方法；3）实现目标数据结构和方法</p>
<h3 id="（2）实现LFU算法（最不经常使用）"><a href="#（2）实现LFU算法（最不经常使用）" class="headerlink" title="（2）实现LFU算法（最不经常使用）"></a>（2）实现LFU算法（最不经常使用）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-56.png" alt="sf-1-56"></p>
<p><strong>说明</strong>：从实现难度上来说，LFU 算法的难度⼤于 LRU 算法，LFU 算法相当于是把数据按照访问频次进⾏排序，这个需求恐怕没有那么简单，⽽且还有⼀种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插⼊的那个数据。也就是说 <strong>LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据</strong>。  </p>
<p>可以看到LFU 算法是要复杂很多的，⽽且经常出现在⾯试中，因为 LFU 缓存淘汰算法在⼯程实践中经常使⽤，<br>也有可能是应该 LRU 算法太简单了。不过话说回来，<strong><strong>这种著名的算法的套路都是固定的，关键是由于逻辑较</strong><br>复杂，不容易写出漂亮且没有 bug 的代码。</strong>  </p>
<p><strong>思路</strong>：</p>
<p><u>首先</u>，有几点我们需要注意：1）调⽤ get(key) ⽅法时，要返回该 key 对应的 val  ；2）只要⽤ get 或者 put ⽅法访问⼀次某个 key，该 key 的 freq 就要加⼀ ；3）如果在容量满了的时候进⾏插⼊，则需要将 freq 最⼩的 key 删除，如果最⼩的 freq 对应多个 key，则删除其中最旧的那⼀个。  </p>
<p><u>接着</u>，我们的目标是在O(1)的时间复杂度完成这些需求，我们可以使用下面的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使⽤⼀个 HashMap 存储 key 到 val 的映射，就可以快速计算 get(key)。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、使⽤⼀个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure>

<p><u>接着</u>，有一个核心需求，我们来看看步骤：</p>
<p>1）我们需要 freq 到 key 的映射，⽤来找到 freq 最⼩的 key；</p>
<p>2）将 freq 最⼩的 key 删除，那你就得快速得到当前所有 key 最⼩的 freq 是多少。想要时间复杂度O(1) 的话，肯定不能遍历⼀遍去找，那就⽤⼀个变量 minFreq 来记录当前最⼩的 freq 吧；</p>
<p>3）可能有多个 key 拥有相同的 freq，所以 freq 对 key 是<strong>⼀对多</strong>的关系，即⼀个 freq 对应⼀个 key 的列表；</p>
<p>4）希望 freq 对应的 key 的列表是<strong>存在时序的</strong>，便于快速查找并删除最旧的 key；</p>
<p>5）希望能够快速删除 key 列表中的任何⼀个 key，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 freq+1，就应该从 freq 对应的 key 列表中删除，加到 freq+1 对应的 key 的列表中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkedHashSet，它满⾜我们 3.3，3.4，3.5 这⼏个要求。你会发现普通的链表LinkedList 能够满⾜ 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某⼀个节点，所以⽆法满⾜ 3.5 的要求。</span></span><br><span class="line"><span class="comment">//LinkedHashSet 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插⼊元素具有时序；哈希集合中的元素⽆序，但是可以对元素进⾏快速的访问和删除。</span></span><br><span class="line"><span class="comment">//那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，⼜可以保持插⼊的时序，⾼效实现 3.5 这个需求。</span></span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="keyword">int</span> minFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>最后，LFU算法的基本数据结构就浮现出来啦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line">    <span class="comment">//key到val的映射，简称KV表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">//key到freq的映射，简称KF表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFre;</span><br><span class="line">    <span class="comment">//freq到key的映射，简称FK表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">//记录当前的最小频次数量</span></span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="comment">//记录LFU缓存的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyToFre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码框架</strong>：</p>
<p>A，指导思想</p>
<p><strong>1、</strong>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。<strong>2、</strong>搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。<strong>3、</strong>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p>
<p>B，get方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!keyToVal.containsKey(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加key对应的val</span></span><br><span class="line">    increaseFreq(key);<span class="comment">//这是一个核心方法，抽象为函数看起来比较简介</span></span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，put方法</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-57.png" alt="sf-1-57" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//若key已经存在，则修改对应的val值</span></span><br><span class="line">    <span class="keyword">if</span>(keyToVal.containsKey(key))&#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若key不存在，则需要插入，首先判断容量是不是满了，满了就淘汰一个Freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= keyToVal.size())&#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入key和val，手相放到KV表里去</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">//插入KF表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//插入FK表</span></span><br><span class="line">    freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">//freq更新为最小，就是1</span></span><br><span class="line">    <span class="keyword">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，两个核心函数</p>
<p>可以从上面看出，最核心的两个函数就是removeMinFreqKey()和increaseFreq()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除某个键key肯定是要同时修改三个映射表的，借助minFreq参数可以从FK表中找到freq最小的keyList，根据时序，其中第一个元素就是要被淘汰的deletedKey，操作三个映射表删除这个key即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里有个问题，如果keyList中只有一个元素，那么删除之后minFreq对应的key列表就为空了，也就是minFreq变量需要被更新。如何计算当前的minFreq是多少呢？（其实只能遍历更新），我们这里不考虑这个情况，因为该方法只有put方法中插入新key时可能调用。而你回头看put的代码，插入新key时一定会把minFreq更新成 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="keyword">this</span>.minFreq);</span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="keyword">int</span> deletedKey = keyList.iterator().next();</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    keyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="keyword">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和之前类似，当FK表中freq对应的列表被删空后，需要删除FK表中freq这个映射。如果这个freq恰好是minFreq，说明minFreq变量需要更新。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能不能快速找到当前的minFreq呢？这里是可以的，因为我们刚才把key的freq加了 1 嘛，所以minFreq也加 1 就行了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = keyToFreq.get(key);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="keyword">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）常数时间查找-x2F-删除数组中任意元素"><a href="#（3）常数时间查找-x2F-删除数组中任意元素" class="headerlink" title="（3）常数时间查找&#x2F;删除数组中任意元素"></a>（3）常数时间查找&#x2F;删除数组中任意元素</h3><p><strong>（力扣380——常数时间插入，删除和获取随机元素）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-58.png" alt="sf-1-58" style="zoom: 67%;" />

<p><strong>思路</strong>：</p>
<p>本题的难点有两个：1）插入，删除，获取随机元素这三个操作的时间复杂度必须为o(1)；2）getRadom方法必须以等概率返回元素。</p>
<p>对于第一个要求，我们熟悉的数据结构中，想到了HashSet，哈希集合的底层原理就是⼀个⼤数组，我们把元素通过哈希函数映射到⼀个索引上；如果⽤拉链法解决哈希冲突，那么这个索引可能连着⼀个链表或者红⿊树。  它能满足常数时间插入，删除。然而问题是，元素是被哈希函数「分散」到整个数组⾥⾯的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素  </p>
<p>那么哈希链表 LinkedHashSet呢？，我们前⽂讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中 ，然而这依然⽆法按要求实现我们的 getRandom 函数，因为底层⽤链表结构存储元素的话，是⽆法在 O(1) 的时间内访问某⼀个元素的。  </p>
<p>所以我们必须用数组，数组最困难的要实现插入和删除的时间复杂度是O(1)，我们只能在尾部进行插入和删除。删除数组中的某⼀个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。交换两个元素必须通过索引进⾏交换对吧，那么我们需要⼀个哈希表 valToIndex 来记录每个元素值对应的索引。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; dict;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list.size(),val);<span class="comment">//这里ArrayList.put(index,val)表示在index位置放入val</span></span><br><span class="line">        dict.put(val, list.size() - <span class="number">1</span>);<span class="comment">//val作为key，这样好查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//</span></span><br><span class="line">        <span class="comment">//将最后一个元素覆盖到val的位置，表示val已经去除，然后就在list和dict删除多余的元素即可</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> last = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lastIdx = dict.get(val);</span><br><span class="line">        list.set(lastIdx, last);</span><br><span class="line">        dict.put(last,lastIdx);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        dict.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣710——黑名单中的随机数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-59.png" alt="sf-1-59"></p>
<p><strong>思路</strong>：我们不能简单的不断去random直到获得一个不是黑名单的数字，那样调用次数非常多。我们发现，题中数组的数字范围和数组大小相同，那么我们是不是可以把黑名单数字全部移到最后，然后把后面的合法数字移到前面来。</p>
<p>当然，移动数字的话是一种思路，我们下面是将黑名单数字映射到合法数字，比如长度为6的数组，遇到了3是一个黑名单数，它的下标是2，如果下标为5的数字6不是黑名单数，那么我们就用map存储&lt;2,6&gt;，表示2这个下标对应的是6，不是黑名单数3啦。之后再随机取的话就好办了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        mapping = <span class="keyword">new</span> HashMap();</span><br><span class="line">        sz = n - blacklist.length;</span><br><span class="line">        <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : blacklist)&#123;</span><br><span class="line">            mapping.put(a,<span class="number">9527</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1，我们的目标是将黑名单的数映射到一个正确的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : blacklist)&#123;</span><br><span class="line">            <span class="comment">//2,如果temp本身就在这个区间里面，就别设置它了</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= sz) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3,如果last指向的位置已经在map中，那么这个last不行</span></span><br><span class="line">            <span class="keyword">while</span>(mapping.containsKey(last))&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping.put(temp,last);</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = rand.nextInt(sz);</span><br><span class="line">        <span class="keyword">if</span>(mapping.containsKey(k)) <span class="keyword">return</span> mapping.get(k);</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）中位数"><a href="#（4）中位数" class="headerlink" title="（4）中位数"></a>（4）中位数</h3><p><strong>（力扣295——数据流的中位数）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-60.png" alt="sf-1-60" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>首先，我们需要回顾一下以往的手段，以及它们的是否能使用：1）普通数组，查找很快，但是插入不行，log（n）的时间复杂度；2）普通链表，也不行，查找慢；3）java的TreeSet，是一种平衡二叉树的实现，底层是红黑树，但是它是一个set不能输入重复元素，其次它并没有实现一个通过排名快速计算元素的 API。假设我想找到<code>TreeSet</code>中第 5 大的元素，并没有一个现成可用的方法实现这个需求；4）优先级队列（二叉堆），也不太行，它是一种受限的数据结构，只能从堆顶添加&#x2F;删除元素，我们的<code>addNum</code>方法可以从堆顶插入元素，但是<code>findMedian</code>函数需要从数据中间取，这个功能优先级队列是没办法提供的。</p>
<p>我们必须要使用有序数据结构，本题核心是，使用两个优先级队列，优先级队列前面用过，能够使插入的元素按顺序排列，看看下面这个图，我们就知道原理了</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-61.png" alt="sf-1-61"  />

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这个优先级队列默认从小到大排列，所以small使用lamda表达式调整对从大到小</span></span><br><span class="line">        large = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small.size() &gt;= large.size())&#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四，进阶数据结构"><a href="#四，进阶数据结构" class="headerlink" title="四，进阶数据结构"></a>四，进阶数据结构</h1><h2 id="1，二叉树"><a href="#1，二叉树" class="headerlink" title="1，二叉树"></a>1，二叉树</h2><p><strong>二叉树非常重要，</strong>这是因为二叉树的思想在很多算法题中都有出现，何以见得？看看快速排序和归并排序。</p>
<p>快速排序其实就是一个前序遍历的思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">	<span class="comment">/************************/</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lo;</span><br><span class="line">    <span class="keyword">int</span> index = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[p])&#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, p, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序则是一个后序遍历的思想（先对左右子数组排序，再进行合并）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">	sort(nums, lo, mid);</span><br><span class="line">	<span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">	sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">	<span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">	<span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">	merge(nums, lo, mid, hi);</span><br><span class="line">	<span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树中的递归算法</strong>，</p>
<p>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节。  </p>
<p>⽐如说让你计算⼀棵⼆叉树共有⼏个节点：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ⾃⼰加上⼦树的节点数就是整棵树的节点数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个问题⾮常简单，⼤家应该都会写这段代码，root 本身就是⼀个节点，加上左右⼦树的节点数就是以</span><br><span class="line">root 为根的树的节点总数。</span><br><span class="line">左右⼦树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，</span><br><span class="line">递归调⽤ count 函数即可算出来</span><br></pre></td></tr></table></figure>

<p>简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调⽤⼦节点，递归调⽤会让孩⼦节点做相同的事情。  </p>
<h3 id="（1）二叉树——1"><a href="#（1）二叉树——1" class="headerlink" title="（1）二叉树——1"></a>（1）二叉树——1</h3><p><strong>（力扣226——翻转二叉树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-62.png" alt="sf-1-62" style="zoom:67%;" />

<p><strong>思路</strong>：本题代码简单，但是要想清楚，到底用哪种遍历呢？其实前序和后序都可以，但是中序不行，中序遍历换节点 根据左根右的遍历顺序 相当于左侧节点交换了两次 右侧节点没换  因为遍历根的时候交换了左右节点 遍历右侧的时候还是之前那个左节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode left = root.left, right = root.right;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        invertTree(left);</span><br><span class="line">        invertTree(right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣116——填充每个节点的下一个右侧节点指针）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-63.png" alt="sf-1-63" style="zoom: 80%;" />

<p><strong>思路</strong>：这里需要高度抽象，别想太多，对于一个节点的左子树和右子树，应该先递归连接它们的孩子，然后把左子树的右指针，连到右子树的左指针。还是看代码吧（一看就会，一作就废）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        connectTwoNode(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键就是这里，我们要同时递归操作两个节点（或者是两个子树），所以需要这个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node node1, Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        connectTwoNode(node1.left, node1.right);</span><br><span class="line">        connectTwoNode(node2.left, node2.right);</span><br><span class="line">        <span class="comment">//这里就是将两个分开的字数连在一起的操作，别去想为什么</span></span><br><span class="line">        connectTwoNode(node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣114——将二叉树展开为链表)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-64.png" alt="sf-1-64"></p>
<p><strong>说明</strong>：左子树和右子树操作完应该按照链来处理，不再是树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==  <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">		<span class="comment">//经过上面的递归，左子树和右子树都变为链，此时进行连接操作。</span></span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line"></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;   </span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉树——2"><a href="#（2）二叉树——2" class="headerlink" title="（2）二叉树——2"></a>（2）二叉树——2</h3><p><strong>（力扣654——最大二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-65.png" alt="sf-1-65"></p>
<p><strong>思路</strong>：这道题就是，找到最大值作为根节点，然后构建左子树，构建右子树，然后根节点接上左子树和右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CreateTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>,maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">        root.left = CreateTree(nums, begin, maxIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = CreateTree(nums, maxIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣105——通过前序和中序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-66.png" alt="sf-1-66"></p>
<p><strong>思路</strong>：这是经典问题了，关键是每次都要传入两个数组，并且限定好两个数组的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span> <span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize = index - inStart; </span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftsize,</span><br><span class="line">            inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, preStart + leftsize + <span class="number">1</span>, preEnd,</span><br><span class="line">            inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣106——利用中序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-67.png" alt="sf-1-67"></p>
<p><strong>思路</strong>：类似于上一题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postStart &gt; postEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSize = rootIndex - inStart;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        root.left = build(inorder, inStart, rootIndex - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, rootIndex + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣889——根据前序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-68.png" alt="sf-1-68"></p>
<p><strong>思路</strong>：这里是无法确一颗二叉树的，只需要返回一种可能的情况就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//！！！这里其实对应的是特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="keyword">int</span> nextRIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postStart; i &lt;= postEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] == preorder[preStart + <span class="number">1</span>])&#123;</span><br><span class="line">                nextRIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = nextRIdx - postStart;</span><br><span class="line">		<span class="comment">//!!!这里的nextRIdx不要换成leftsize</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize + <span class="number">1</span>, postorder, postStart, nextRIdx);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">2</span>, preEnd, postorder, nextRIdx + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉树——3"><a href="#（3）二叉树——3" class="headerlink" title="（3）二叉树——3"></a>（3）二叉树——3</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-69.png" alt="sf-1-69" style="zoom:80%;" />

<p><strong>思路</strong>：这题在判断子树的结构时，需要将子树序列化成一个String，这样方便比较，然后再把子树的String进行存储和比较，具体看代码比较清晰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; subTree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String left = traverse(root.left);</span><br><span class="line">        String right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        String sub = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time = subTree.getOrDefault(sub, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>) res.add(root);</span><br><span class="line">        subTree.put(sub, time + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）二叉树序列化，多种框架"><a href="#（4）二叉树序列化，多种框架" class="headerlink" title="（4）二叉树序列化，多种框架"></a>（4）二叉树序列化，多种框架</h3><p><strong>（力扣297——二叉树序列化和反序列化）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-70.png" alt="sf-1-70"  />

<p><strong>思路</strong>：本题可以用前序遍历，后序遍历，中序遍历，层次遍历解决，这里按顺序来展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 前序遍历 将二叉树转换为字符串，比如例子会转换为[1,2,#,#,3,4,#,#,5,#,#]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于上面的字符串中有空指针信息，那么便可以根据前序遍历结构，前序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果字符是#表示空指针，返回空指针</span></span><br><span class="line">        String first = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(first.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(first));</span><br><span class="line"></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 后序遍历 将二叉树转换为字符串，比如例子会转换为[2,#,#,4,#,#,5,#,#,3,1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以[2,#,#,4,#,#,5,#,#,3,1]为基础后序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String last = nodes.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(last.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(last));</span><br><span class="line">        <span class="comment">//从后往前在 nodes 列表中取元素，一定要先构造 root.right 子树，后构造 root.left 子树</span></span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历实现不了</span></span><br><span class="line">想实现反序列方法，首先要构造 root 节点。前序遍历得到的 nodes 列表中，第一个元素是 root 节点的值；后序遍历得到的 nodes 列表中，最后一个元素是 root 节点的值。</span><br><span class="line"></span><br><span class="line">你看上面这段中序遍历的代码，root 的值被夹在两棵子树的中间，也就是在 nodes 列表的中间，我们不知道确切的索引位置，所以无法找到 root 节点，也就无法进行反序列化。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">//1,标准的层次遍历框架（重要）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1，初始化队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,实现序列化实现，题中的序列化结果为[1,2,3,#,#,4,5,#,#,#,#]</span></span><br><span class="line">String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val).append(spe);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，这里并不会判断是不是NULL，因为就算是，也需要加入到String的信息中去</span></span><br><span class="line">        q.offer(cur.left);</span><br><span class="line">        q.offer(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,实现反序列化,将[1,2,3,#,#,4,5,#,#,#,#]变为数，可以看到，1对应2和3,2对应#和#，3对应4和5，以此类推</span></span><br><span class="line"><span class="comment">//下面代码中的结构和层次遍历的逻辑非常相似，都是将节点存入队列，然后左孩子进队列，右孩子进队列</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] nodes = data.split(spe);</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)&#123;</span><br><span class="line">        TreeNode parent = q.poll;</span><br><span class="line">        </span><br><span class="line">        String left = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!left.equals(NULL))&#123;</span><br><span class="line">            parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">            q.offer(parent.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String right = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!right.equals(NULL))&#123;</span><br><span class="line">            parent = right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">            q.offer(parent.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）后序遍历"><a href="#（5）后序遍历" class="headerlink" title="（5）后序遍历"></a>（5）后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-71.png" alt="sf-1-71"></p>
<p><strong>思路</strong>：</p>
<p>不管是什么遍历，最关键的就是梳理思路，明确要记录的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-72.png" alt="sf-1-72"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] traverse(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">		<span class="comment">//res[0]代表这个子树是不是二叉搜索树,res[1]树的最大值,res[2]树的最小值 ,res[3]整个树的和</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>])&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><h2 id="2，二叉搜索树"><a href="#2，二叉搜索树" class="headerlink" title="2，二叉搜索树"></a>2，二叉搜索树</h2><h3 id="（1）二叉搜索树——1"><a href="#（1）二叉搜索树——1" class="headerlink" title="（1）二叉搜索树——1"></a>（1）二叉搜索树——1</h3><p><strong>(力扣230——二叉搜索树中第K小的元素)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-73.png" alt="sf-1-73" style="zoom: 80%;" />

<p><strong>思路</strong>：二叉搜索树的中序遍历就是从小到大排序的，所以这里进行一个简单的中序遍历就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,简单的遍历方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       preTraverse(root,k);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            res =  root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2，如果说TreeNode中，每个节点包含自己的排序信息，那么这里的时间复杂度可以降低到O(logN),</span></span><br><span class="line"><span class="comment">//如果节点中有以自己为根的子树的节点数信息，那么排名 = root.val - root.left.val</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么中序遍历的算法中,就可以直接计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val - root.left.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣538——把二叉搜索树转化为累加树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-74.png" alt="sf-1-74"></p>
<p><strong>思路</strong>：原本的二叉搜索树，中序遍历是按照从左往右，升序打印。如果这里我们能从右往左，降序打印，便可解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉搜索树——2-检查，搜索，插入，删除"><a href="#（2）二叉搜索树——2-检查，搜索，插入，删除" class="headerlink" title="（2）二叉搜索树——2   (检查，搜索，插入，删除)"></a>（2）二叉搜索树——2   (检查，搜索，插入，删除)</h3><p><strong>（判断搜索二叉树的合法性）</strong></p>
<p><strong>思路</strong>：给了你一个二叉树，如何判断是不是搜索二叉树？可以尝试在前序遍历的时候，对于一个节点，它&gt;左孩子的值并且&lt;右孩子的值，如果有不满足这个条件的，那不是二叉搜索树。</p>
<p>但是上面的方法并不能完全满足（比如10,5,15,#,#,6,20），因为规则有漏洞，对于一个节点，我们应该比较它与左子树的最大值，和右子树的最小值，以此来判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//相等也是不行的</span></span><br><span class="line">    <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; root.val &gt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; root.val &lt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValid(root.left, min, root) &amp;&amp; isValid(root.right, root, max);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣700——二叉搜索树中搜索）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-%2076.png" alt="sf-1- 76" style="zoom:80%;" />

<p><strong>思路</strong>：这个简单，但是还是时间复杂度的问题，我们可以采取剪枝的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        preTraverse(root, val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            preTraverse(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            preTraverse(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（在BST中插入一个数）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        return insertBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode insertBST(TreeNode root, int val)&#123;</span><br><span class="line">        if(root == null) return new TreeNode(val);</span><br><span class="line"></span><br><span class="line">        if(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertBST(root.left, val);</span><br><span class="line">        &#125;else if(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣450——删除二叉搜索树中的节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-75.png" alt="sf-1-75"></p>
<p><strong>思路</strong>：整体上的思路是，前序遍历，如果该节点需要删除，则删除，如果不是的话，那么该节点链接删除了的左子树，链接删除了的右子树。也就是上面这个框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，简单框架</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，加入删除操作，删除节点有三种情况，每种的解决方式不一样</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//这里包含了root节点没有左右孩子，or有左无右，or有右无左的三种情况</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">//最麻烦的是root节点左右孩子都有的情况，此时只能将右子树接在左子树最大的节点，或者将左子树接在右子树最小的节点来进行处理，这里我们采用第二种</span></span><br><span class="line">        TreeNode midNode = getMin(root.right);</span><br><span class="line">        root.right = deleteNode(root.right, midNode.val);</span><br><span class="line">        minNode.left = root.left;</span><br><span class="line">        minNode.right = root.right;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// BST 最左边的就是最⼩的</span></span><br><span class="line">	<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉搜索树——3"><a href="#（3）二叉搜索树——3" class="headerlink" title="（3）二叉搜索树——3"></a>（3）二叉搜索树——3</h3><p><strong>（力扣96——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-77.png" alt="sf-1-77"></p>
<p><strong>思路</strong>：对于一个数字N，由于二叉搜索树的性质是进行中序遍历后是一个有序的数组，那么假设遍历后为一个大小为N的数组[1,2,3….,N]，对于中间的某个数字x，它所构成的树的形状应该是：（左边1<del>x-1个节点树的形状数）* （右边x+ 1</del>n个节点树的形状数），当左右两边的树的数量为0和1的时候，应该返回1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,下面这种方式时间复杂度非常高，为什么呢？假设我们已经计算出了数量为区间1~3的树的结构数量，我们不应该再计算类似于区间2~4，但是下面的算法会不断计算。所以我们应该将已经计算的存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++分割线+++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,那么我们加入一个memo去记录某个数量能形成的不同子树就行啦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res[end - start + <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> res[end - start + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        res[end - start + <span class="number">1</span>] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣95——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-78.png" alt="sf-1-78"></p>
<p><strong>思路</strong>：此题总体上的思路和上一题类似，但是注意，这里要存储树的结构，我们需要在获得左子树和右子树的情况后，遍历所有的情况并接在根节点上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> getTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">getTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>); </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = getTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = getTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftNode : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightNode : right)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = leftNode;</span><br><span class="line">                    root.right = rightNode;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="3，图论"><a href="#3，图论" class="headerlink" title="3，图论"></a>3，图论</h2><blockquote>
<p>图论在实际笔试中考的不多，但它的经典算法⽐较多，⽐如什么最⼩⽣成树，最短路径，拓扑排序，⼆分图<br>判定之类的。<br>        所以本章围绕图论的经典算法展开，太难的图论算法我觉得咱是没多⼤必要掌握的。  </p>
</blockquote>
<h3 id="（1）图论基础"><a href="#（1）图论基础" class="headerlink" title="（1）图论基础"></a>（1）图论基础</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-79.png" alt="sf-1-79" style="zoom:50%;" />

<p><strong>(图的逻辑结构)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图结点的逻辑结构，存储值id，以及连接的节点存在neighbors中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（图的常用存储方式）</strong></p>
<p>在实际应用中，我们很少用上面的节点的方式来对图进行操作，我们更常用的是邻接表和邻接矩阵</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-80.png" alt="sf-1-80" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="comment">//graph[x]存储x的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="comment">//matrix[x][y]记录x是否有一条指向y的边</span></span><br><span class="line"><span class="keyword">boolean</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">邻接表：</span><br><span class="line">    优势：占用空间少</span><br><span class="line">    劣势：⽆法快速判断两个节点是否相邻，需要遍历该节点连接的所有节点才能判断</span><br><span class="line">邻接矩阵：</span><br><span class="line">    优势：占用空间多</span><br><span class="line">    劣势：能快速判断，比如<span class="number">3</span>和<span class="number">1</span>是否相连，我们只需判断[<span class="number">3</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>(度的概念)</strong></p>
<p>在无向图中，一个节点的度就是该节点的相连的边的数量。</p>
<p>在有向图中，一个节点的度分为出度（该节点指向别的节点）和入度（别的节点指向该节点）。</p>
<p>在此基础上，还有权值的概念。</p>
<p><strong>（图的遍历）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图遍历框架,采用的是邻接表的遍历框架</span></span><br><span class="line"><span class="comment">//注意visited和onPath的功能是不一样的，visited用来防止重复遍历，onPath是在当前遍历是否在目前这个路径中</span></span><br><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">boolean</span>[] onPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graphTraverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//前序遍历位置，这里将s标记为已读，并将s加入路径中</span></span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : gragh.neighbors(s))&#123;</span><br><span class="line">        traverse(gragh, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历代码位置，退出路径</span></span><br><span class="line">    onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣797——所有可能的路径）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-81.png" alt="sf-1-81" style="zoom:80%;" />

<p><strong>思路</strong>：使用深度遍历该图时，如果当前的点为n-1，则要在结果中添加当前的path，然后递归遍历每个相邻节点，在递归后要移除加入的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS深度遍历解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在路径中添加该节点值，添加到最后</span></span><br><span class="line">        path.addLast(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">if</span>(s == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果已经到了最后一个节点，那么此时path中已经存在一个从0到n-1的路径，复制并存储到res中去</span></span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[s])&#123;</span><br><span class="line">            traverse(graph, v, path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS广度搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//存结果</span></span><br><span class="line">        <span class="keyword">int</span> n=graph.length;</span><br><span class="line">        Queue&lt;List&lt;Integer&gt;&gt; myque=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//广度优先搜索队列</span></span><br><span class="line"></span><br><span class="line">        myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        myque.peek().add(<span class="number">0</span>);<span class="comment">//队列中的第一个路径添加起始节点</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp;<span class="comment">//在bfs过程中接收临时路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为是有向无环图所以不需要记录是否已经访问过当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(myque.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=myque.remove();<span class="comment">//取出队头元素</span></span><br><span class="line">            Integer temp_int=temp.get(temp.size()-<span class="number">1</span>);<span class="comment">//拿到当前路径的最后一站</span></span><br><span class="line">            <span class="keyword">if</span>(temp_int==n-<span class="number">1</span>)</span><br><span class="line">            &#123;<span class="comment">//是否到达指定终点，到达终点则将当前路径加入ret</span></span><br><span class="line">                ret.add(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Integer i:graph[temp_int])</span><br><span class="line">            &#123;<span class="comment">//从当前路径向后走，因为是有向无环图，所以不用担心重复访问，不用担心走不到终点。</span></span><br><span class="line">                temp.add(i);</span><br><span class="line">                myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));<span class="comment">//一定是深拷贝</span></span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯一下</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：huann-jun</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/all-paths-from-source-to-target/solution/bfs10mssi-lu-qing-xi-xie-zhu-shi-de-du-s-hfdc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h3 id="（2）拓扑排序"><a href="#（2）拓扑排序" class="headerlink" title="（2）拓扑排序"></a>（2）拓扑排序</h3><p><strong>（力扣207——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-82.png" alt="sf-1-82"></p>
<p><strong>思路</strong>：首先我们要建立一个有向图，这里采用邻接表的方式，然后我们可以用深度优先算法来遍历，并想办法判断是否是成环的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,构建邻接表，我们注意返回的是数组，数组的索引对应了元素的值，数组中存储了一个list，表示元素指向的元素</span></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//这里用有向图表示完成from才能进行to</span></span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//2，主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">		<span class="comment">//要遍历所有的课程，保证每个课程完成都没有环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !hasCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3，遍历函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这个onPath加深了我们对路径的理解，它之所以和isVisited不一样，是应为它表示了当前节点是不是在当前路径中，退出了这个路径就会设置为false，而isVisited只是表示当前节点遍历过没有，设置为true就变不回来</span></span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是满足任一条件就要退出来</span></span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣210——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-83.png" alt="sf-1-83"></p>
<p><strong>思路</strong>：</p>
<p>首先，这个题就是需要找出拓扑排序，拓扑排序的顺序就是本题的答案。拓扑排序构造方式是：1）从有向图中选择一个没有前驱（即入度为0）的顶点并且输出它；2）从图中删去该顶点，并且删去从该顶点发出的所有边；3）重复上述步骤1）和2），直到当前有向图中不存在没有前驱结点的顶点为止，或者当前有向图中的所有结点均已输出为止。</p>
<p>其次，拓扑排序的前提是没有环，有换无法形成拓扑结果，所以，我们应该先判断这个里面有没有环。</p>
<p>最后，本题如何得到拓扑排序？本题就是将后序遍历的结果进行反转（当然也可以不反转，但是我们这里构建图的时候，和题中的顺序是不一样的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">    List&lt;Integer&gt; postOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(postOrder);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            res[i] = postOrder.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder.add(s);</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（BFS算法解答）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS算法判断是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment">//BFS算法判断是否能输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer(indgree[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录拓扑排序结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">   <span class="keyword">if</span>(count == numCourses)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二分图判定"><a href="#（3）二分图判定" class="headerlink" title="（3）二分图判定"></a>（3）二分图判定</h3><p><strong>（二分图简介）</strong></p>
<p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且两个⼦集内的顶点不相邻。  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-84.png" alt="sf-1-84" style="zoom: 50%;" />

<p><strong>例子：</strong>其实就是一个图的双色问题，给你⼀幅「图」，请你⽤两种颜⾊将图中的所有顶点着⾊，且使得任意⼀条边的两个端点的颜⾊都不相同，你能做到吗？  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-85.png" alt="sf-1-85" style="zoom:50%;" />

<p><strong>框架：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//遍历节点v的所有相邻节点neighbor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.neighbors(v))&#123;</span><br><span class="line">        <span class="comment">//这里把判断是否visited的逻辑放到了这里，和之前的框架有些许不同，但是我们只要保证没被访问过再进行访问就行</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor])&#123;</span><br><span class="line">            <span class="comment">//相邻节点neighbor没有被访问过</span></span><br><span class="line">            <span class="comment">//那么应该给节点neighbor和v涂上不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果相邻节点neighbor已经被访问过了</span></span><br><span class="line">            <span class="comment">//那么应该比较neighbor和节点v的颜色</span></span><br><span class="line">            <span class="comment">//若相同，则不是二分图</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣785——判断二分图）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-86.png" alt="sf-1-86"></p>
<p><strong>思路</strong>：按照上面的思路就行，但是这里注意，题中说了这可能不是一个连通图，那么在13行那里，我们要判断当前节点是不是新的图的开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一维数组paint，paint[0]= 0表示0还未着色，paint[0] = -1表示0黑，paint[0] = 1表示0白</span></span><br><span class="line">    <span class="comment">//初试化visited数组</span></span><br><span class="line">    <span class="keyword">int</span>[] paint;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        paint[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.length; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = <span class="number">1</span>;</span><br><span class="line">                canDivide(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">canDivide</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k : graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[k] != <span class="number">1</span>)&#123;</span><br><span class="line">                paint[k] = -paint[v];</span><br><span class="line">                canDivide(graph, k);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[k] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[k] == paint[v])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上面的canDivide方法，我们也可以采用BFS的方式来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Gragh[][] graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	visited[start] = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; !flag)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = q.poll();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v ; graph[k])&#123;</span><br><span class="line">        	<span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = -paint[k];</span><br><span class="line">                visited[v] == <span class="number">1</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag == <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣886——可能的二分法)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-87.png" alt="sf-1-87"></p>
<p><strong>思路</strong>：dislikes就是一个图的数组，但是这里还没有建好图，需要先自己建图，然后进行遍历和判断，如果可以的话，输出数组，否则输出false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;[] graph;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] paint; </span><br><span class="line">    <span class="keyword">boolean</span>[] visited; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1注意，这里没有节点0，所以初始化和赋值都别加</span></span><br><span class="line">        graph = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dislike : dislikes)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = dislike[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = dislike[<span class="number">1</span>];</span><br><span class="line">            graph[from].add(to);</span><br><span class="line">            graph[to].add(from);</span><br><span class="line">        &#125;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2不是联通图的情况还是要判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] graph, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[k] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[k])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                paint[v] = !paint[k];</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）并查集算法详解"><a href="#（4）并查集算法详解" class="headerlink" title="（4）并查集算法详解"></a>（4）并查集算法详解</h3><p><strong>（认识Union-Find算法——并查集算法）</strong></p>
<p><strong>简介</strong>：所谓的Union-Find算法，目标是将节点进行连接，并且能判断当前的连通分量的情况，以及两个节点是否连通，API如下，可以看出，该算法需要提高union 和 connected 函数的效率。⽤什么模型来表示这幅图的连通状态呢？⽤什么数据结构来实现代码呢 ？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里的连通有三个需要注意的点：1）自反性：节点p和q是连通的；2）对称性：如果p和q是连通的，q和p也是连通的；3）传递性：如果p和q连通，q和r连通，则p和r是连通的。</span></span><br><span class="line"><span class="comment">//对于一个图（1,2,3,4,5,6,7,8,9,10），调用union(1,2),则变为（1&lt;-&gt;2,3,4,5,6,7,8,9,10）,连通分量为9个</span></span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：我们使⽤森林（若⼲棵树）来表示图的动态连通性，⽤数组来具体实现这个森林。  具体见下面代码</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-88.png" alt="sf-1-88" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的⾼度。我们可能习惯性地认为树的⾼度就是 logN，但这并不⼀定。logN 的⾼度只存在于平衡⼆叉树，对于⼀般的树可能出现极端不平衡的情况，使得「树」⼏乎退化成「链表」，树的⾼度最坏情况下可能变成 N。  </p>
<p>具体是在哪一步当中出现了树往坏的方向发展呢？答案是在Union当中，将p 所在的树接到 q 所在的树的根节点下⾯，那么这⾥就可能出现「头重脚轻」的不平衡状况，⽐如下⾯这种局⾯：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-89.png" alt="sf-1-89" style="zoom:67%;" />

<p>在之前的操作中，树可能⽣⻓得很不平衡。我们其实是希望，⼩⼀些的树接到⼤⼀些的树下⾯，这样就能避免头重脚轻，更平衡⼀些。解决⽅法是额外使⽤⼀个 size 数组，记录每棵树包含的节点数，也可以称之为树的「重量」  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//小树接到大树下面，会比较平衡一些</span></span><br><span class="line">    <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">    count--;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径压缩</strong>：我们能不能进⼀步压缩每棵树的⾼度，使树⾼始终保持为常数 ？可以，在find方法中顺便将路径进行压缩就可以了.调⽤ find 函数每次向树根遍历的同时，顺⼿将树⾼缩短了，最终所有树⾼都不会超过 3（union 的时候树⾼可能达到 3），树⾼为常数，那么所有⽅法的复杂度也就都是 O(1)。</p>
<p>如果树非常高，最终的树高不就超过3了吗？不是的，只要是正常建树，在建树的过程中就会不断压缩，不会超过3。用了路径压缩的方法，也就不用记录size了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">	<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		parent[x] = parent[parent[x]]</span><br><span class="line">            x = parent[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终的常用的UF类如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]]</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣323——无向连通图中连通分量的数目）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-90.png" alt="sf-1-90" style="zoom:80%;" />

<p><strong>思路</strong>：直接使用UF类即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">	UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">	<span class="comment">// 将每个节点进⾏连通</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">		uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回连通分量的个数</span></span><br><span class="line">	<span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣130——被围绕的区域)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-91.png" alt="sf-1-91"></p>
<p><strong>思路</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//1，对于一个二维节点，我们映射到x * n + y一维坐标(m为行,n为列)，m*n留着给dummy节点</span></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//2，这里使用了d这个方向数组，对(i,j)的上下左右进行了遍历和判断，如果也是O的话，则进行连接</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                            uf.connect(i * n + j, x * n + y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果说某个O是与dummy相连接的话，肯定不是被围起来的，反之就是，需要修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!uf.connected(i * n + j, dummy))&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣990——等式方程的可满足性）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-92.png" alt="sf-1-92" style="zoom:80%;" />

<p><strong>思路</strong>：本题思路还是比较清晰的，对于两个是等式的字母，我们将其链接在一个树上，遇到不等式，我们判断他们在并查集中是不是有同一个根，如果是则返回false，遍历完后，返回true；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; letterToN = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            letterToN.put((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(letterToN.get(c1),letterToN.get(c2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uf.isConnected(letterToN.get(c1), letterToN.get(c2)))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootQ == rootP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（5）Kruskal最小生成树算法"><a href="#（5）Kruskal最小生成树算法" class="headerlink" title="（5）Kruskal最小生成树算法"></a>（5）Kruskal最小生成树算法</h3><p><strong>（介绍）</strong>：最小生成树就是一个图中所有可能的⽣成树中，权重和最⼩的那棵⽣成树就叫「最⼩⽣成树」  PS：<u>⼀般来说，我们都是在⽆向加权图中计算最⼩⽣成树的，所以使⽤最⼩⽣成树算法的现实场景中，图的边权重⼀般代表成本、距离这样的标量。</u>  </p>
<p><strong>（加入size的并查集算法）</strong></p>
<p>为了保证在生成最小生成树的过程中没有生成环，我们需要UF算法的协助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法引入：力扣261——以图判树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-93.png" alt="sf-1-93" style="zoom:67%;" />

<p><strong>思路</strong>：本题的判断逻辑只有一个，对于一个边的两个顶点，如果它俩在一个连通分量里面，就表明有环了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化有n个节点</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="comment">//遍历每一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//如果这条边的两条节点已经在同一个连通分量中，这条边就会导致产生环</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnect(u,v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这条边不会产生环，可能是树的一部分，也可能是一个单独的连通分量</span></span><br><span class="line">        uf.connect(u,v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有最后连通分量为1，才表明生成了一棵树</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//same as before   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法实现）</strong></p>
<p>一个图的最小生成树，必须满足：1）包含图中的所有节点；2）形成的结构是树结构；3）权重和最小</p>
<p>如何保证这个树的权重是最小的呢？我们需要用到贪心思路：<em>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和<code>mst</code>中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入<code>mst</code>集合；否则，这条边不是最小生成树的一部分，不要把它加入<code>mst</code>集合</em></p>
<p>具体实现看两道题：</p>
<p><strong>（力扣1135——最低成本连通所有城市）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-94.png" alt="sf-1-94" style="zoom:67%;" />

<p><strong>思路</strong>：类似于上一道题，只是这里需要先将路径值进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mininumCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span></span>&#123;</span><br><span class="line">    <span class="comment">//nodes range form 1 ~ n,so we need put n+1 in UF&#x27;s constructor</span></span><br><span class="line">    Uf uf = <span class="keyword">new</span> UF(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对connections数组进行升序排序</span></span><br><span class="line">    Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//用mst进行路径值的记录</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : connections)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//添加了这条边就会出现环，所以跳过操作</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnected(u, v))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.connect(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里用2是因为0这个连通分量一定是单独的。</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//same as before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣1584——连接所有点的最小费用）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-95.png" alt="sf-1-95" style="zoom:80%;" />

<p><strong>思路</strong>：这里需要注意，点与点的关系要转换出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points.length;</span><br><span class="line">    <span class="comment">// 生成所有边及权重</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xi = points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> xj = points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用坐标点在 points 中的索引表示坐标点</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Collections.sort(edges, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行 Kruskal 算法</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)&#123;</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];            </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（算法复杂度）</strong>：</p>
<p>最后说下 Kruskal 算法的复杂度分析：</p>
<p>假设一幅图的节点个数为<code>V</code>，边的条数为<code>E</code>，首先需要<code>O(E)</code>的空间装所有边，而且 Union-Find 算法也需要<code>O(V)</code>的空间，所以 Kruskal 算法总的空间复杂度就是<code>O(V + E)</code>。</p>
<p>时间复杂度主要耗费在排序，需要<code>O(ElogE)</code>的时间，Union-Find 算法所有操作的复杂度都是<code>O(1)</code>，套一个 for 循环也不过是<code>O(E)</code>，所以总的时间复杂度为<code>O(ElogE)</code>。</p>
<h3 id="（6）Dijistra算法"><a href="#（6）Dijistra算法" class="headerlink" title="（6）Dijistra算法"></a>（6）Dijistra算法</h3><p><strong>（所需API）</strong></p>
<p>一般情况下，我们使用邻接表来实现算法，接着对于图的问题，我们需要能一个能够找到相邻节点的API，最后我们还需要一个能够获取两个节点之间权重的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使用邻接表存储图</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,获取某个节点的相邻节点</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> graph[s];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3,获取权重，具体的方式应该根据题意来获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>（图的BFS算法）</strong></p>
<p>从二叉树，到多叉树，到图的BFS算法大体上是一样的 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，二叉树BFS遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,多叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">			<span class="keyword">for</span>(TreeNode child : children)&#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,图的BFS（广度优先搜索）框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用q来存储遍历的对象，用visited来判断是否遍历了</span></span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="comment">//记录搜索的步数（在无权图中，就是1，在有权图中，则为边的权值）</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    	<span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//和之前类似，但是要记录是否被遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">		   <span class="keyword">for</span>(Node x : cur.adj)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!visited.contains(x))&#123;</span><br><span class="line">                   q.offer(x);</span><br><span class="line">                   visited.add(x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在上面的代码中，我们发现这些都是对无权图的遍历操作，无权图意味着每条路径的权值都可以是1，那么start到cur的最短路径就是step的数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到了有权图，最短路径可不是这简单了，在有权图中，start节点到cur的最短路径并是不是简单的step的值，而是要考虑权值。我们的目标是基于上面的算法，计算加权图中的最短路径。此时step步数并不是一个有意义的值了，路径的权重和才有意义，那么for循环中的遍历，我们便不再需要，可以去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//怎么去掉呢？这里先以二叉树为例，去掉for循环，但是还想知道depth的值，我们可以新建一个结构体，其中保存depth的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> State(root, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        State cur = q.poll();</span><br><span class="line">        TreeNode cur_node = cur.node;</span><br><span class="line">        <span class="keyword">int</span> cur_depth = cur.depth;</span><br><span class="line">        System.out.print(cur_node.val + <span class="string">&quot;节点在第&quot;</span> + cur_depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur_node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(Sijkstra算法框架)</strong></p>
<p>迪杰斯特拉算法对于一个输入的图和起点start，能够返回start到其他所有节点的最短距离。根据 BFS 的逻辑和⽆权图的特点，第⼀次遇到某个节点所⾛的步数就是最短距离，所以⽤⼀个 visited 数组防⽌⾛回头路，每个节点只会经过⼀次。<br>        加权图中的 Dijkstra 算法和⽆权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第⼀次经过某个节点时的路径权重，不⻅得就是最⼩的，所以对于同⼀个节点，我们可能会经过多次，⽽且每次的 distFromStart可能都不⼀样，⽐如下图：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-96.png" alt="sf-1-96" style="zoom:67%;" />

<p>下面是该算法的伪代码框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，记录节点数据的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="comment">//用来记录节点的id</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//从Start节点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2，获取两个节点权重的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>;</span><br><span class="line"><span class="comment">//3，获取某个节点相邻节点的方法</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> start, List&lt;Integer&gt;[] graph)&#123;</span><br><span class="line">    <span class="comment">//图中节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> V = graph.length;</span><br><span class="line">    <span class="comment">//起点到每个节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="comment">//先把distTo数组全部赋上最大值</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">//其实节点到自己的距离是1</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//4，用优先级队列来存移入的节点，其实用普通队列也可以，只是这里能保证取出来的节点就是当前最小的那个路径</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列初试化</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> State(start, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//5，担心这个while循环无法结束？放入节点的条件很苛刻啦，队列中没有元素的时候，就是值已经赋完的时候</span></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        State curState = pd.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">        <span class="keyword">int</span> curDistFromStart = curState.distFromStart;</span><br><span class="line">        <span class="comment">//注：要求开始节点到某一个节点的最小值，则只需要在函数参数中加一个end，然后加入下面的判断语句就行</span></span><br><span class="line">        <span class="comment">//if(curNodeId == end)&#123;</span></span><br><span class="line">        <span class="comment">//	return curDistFromStart;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(curDistFromeStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于相邻节点，更新开始节点到自己的最小值，并把自己放进队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nextNodeId : adj(curNodeId))&#123;</span><br><span class="line">            <span class="keyword">int</span> distToNextNode = distTo[curNodeId] + weight(curNodeId, nextNodeId);</span><br><span class="line">            <span class="keyword">if</span>(distTo[nextNodeId] &gt; distToNextNode)&#123;</span><br><span class="line">                distTo[nextNodeId] = distToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> State(nextNodeId, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该算法的时间复杂度是O(Elogv),E是边数，V是节点个数</span></span><br></pre></td></tr></table></figure>

<p><strong>（力扣743——网络延迟时间）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-97.png" alt="sf-1-97" style="zoom: 67%;" />

<p><strong>思路</strong>：如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，节点是从1开始的，所以我们构建的图也从1开始</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt;[] gragh = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : times)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">            gragh[from].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;to, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,开始使用迪杰斯特拉算法进行最短路径计算</span></span><br><span class="line">        <span class="keyword">int</span>[] distTo = Dijkstra(k, gragh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distTo.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distTo[i] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="comment">//3,有节点连接不上，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, distTo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] Dijkstra(<span class="keyword">int</span> start, List&lt;<span class="keyword">int</span>[]&gt;[] gragh)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = gragh.length;</span><br><span class="line">        <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">        Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">        distTo[start] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State cur = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = cur.id;</span><br><span class="line">            <span class="keyword">int</span> curDistFromStart = cur.distFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curDistFromStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : gragh[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> disToNextNode = distTo[curNodeId] + neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( distTo[nextNodeId] &gt; disToNextNode)&#123;</span><br><span class="line">                    distTo[nextNodeId] = disToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, disToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distTo;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1631——最小体力消耗路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-98.png" alt="sf-1-98"></p>
<p><strong>思路</strong>：具体都是套框架，但是这里有一点比较重要，在44~49行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; adj(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; neighbor = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span> &amp;&amp; k &lt; m &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n)&#123;</span><br><span class="line">                neighbor.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;k, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] effortTo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m; i++)&#123;</span><br><span class="line">            Arrays.fill(effortTo[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effortTo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a.effortFromStart - b.effortFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curNode = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curx = curNode.x;</span><br><span class="line">            <span class="keyword">int</span> cury = curNode.y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curx == m - <span class="number">1</span> &amp;&amp; cury == n - <span class="number">1</span>) <span class="keyword">return</span> curNode.effortFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNode.effortFromStart &gt; effortTo[curx][cury])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : adj(curx, cury, heights))&#123;</span><br><span class="line">                <span class="keyword">int</span> nextx = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nexty = neighbor[<span class="number">1</span>];</span><br><span class="line">			   <span class="comment">//下一个node的effort，应该是当前遇到的最大值，才能反映出来这条路径的消耗</span></span><br><span class="line">                <span class="keyword">int</span> effortToNextNode = Math.max(effortTo[curx][cury], Math.abs(heights[curx][cury] - heights[nextx][nexty]));</span><br><span class="line">                <span class="comment">//但是要添加到efforTo数组中的话，就需要这条路径的最大值都比目前就记录的小，才能添加</span></span><br><span class="line">                <span class="keyword">if</span>(effortToNextNode &lt; effortTo[nextx][nexty])&#123;</span><br><span class="line">                    effortTo[nextx][nexty] = effortToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextx, nexty, effortToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> x, y;</span><br><span class="line">     <span class="keyword">int</span> effortFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> effortFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.effortFromStart = effortFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1514——概率最大的路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-99.png" alt="sf-1-99"></p>
<p><strong>思路</strong>：本题与之前的题明显有两个不同点：1）图是无向图；2）这里需要计算的不是最短路径，而是最大值。我们解决的办法也是两个点：1）无向图就是双向图，在建图的时候要添加边；2）dijkstra算法计算的是最优值，那么最大值也是可以的，只是需要进行一点小的变化。</p>
<p>最后说一下，标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？因为 Dijkstra 计算最短路径的正确性依赖⼀个前提：路径中每增加⼀条边，路径的总权重就会增加（或减少）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">double</span>[] succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">double</span>[]&gt;[] graph = <span class="keyword">new</span> LinkedList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> weight = succProb[i];</span><br><span class="line">            <span class="comment">//1,建图的时候，注意统一为double，并且这里是无向图，按照双向图来建图</span></span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) to, weight&#125;);</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) from, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dijkstra(start, end, graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;<span class="keyword">double</span>[]&gt;[] graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] probTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.length];</span><br><span class="line">        Arrays.fill(probTo, - <span class="number">1</span>);</span><br><span class="line">        probTo[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2,此处我们调整为probFromStart值较大的在前面</span></span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(b.probFromStart, a.probFromStart);</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curState = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">            <span class="keyword">double</span> curProbFromStart = curState.probFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNodeId == end) <span class="keyword">return</span> curProbFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curProbFromStart &lt; probTo[curNodeId]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">double</span>[] neighbor : graph[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = (<span class="keyword">int</span>)neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">double</span> probToNextNode = probTo[curNodeId] * neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(probTo[nextNodeId] &lt; probToNextNode)&#123;</span><br><span class="line">                    probTo[nextNodeId] = probToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, probToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">double</span> probFromStart;</span><br><span class="line">    State(<span class="keyword">int</span> id, <span class="keyword">double</span> probFromStart)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.probFromStart = probFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）名流问题"><a href="#（7）名流问题" class="headerlink" title="（7）名流问题"></a>（7）名流问题</h3><p><strong>（引入）</strong>：</p>
<p>名流问题，指的是给你n个人的社交关系（你知道两个人之间是否认识），尝试寻找其中的名人，名人必须满足条件：1）所有其他人都认识名人；2）名人不认识其他任何人。</p>
<p>该问题其实就是一个图结构的问题，抽象为图我们可以这么理解，对于一个有向图(有n个节点)，若a-&gt;b，则表明a认识b（如果是邻接矩阵就是，若graph[i][j] &#x3D; 1，则表明第i个人认识第j个人），那么一个节点如果是名人，则该节点没有出度，且入度为n-1。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-100.png" alt="sf-1-100" style="zoom:80%;" />

<p><strong>（力扣227——搜寻名人）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-1.png" alt="sf-2-1" style="zoom:80%;" />

<p><strong>思路</strong>：本题由浅入深，可以探讨3种不同的思路，对于逻辑很有帮助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，暴利解决（由于knows底层是访问邻接矩阵，所以该算法时间复杂度高达O(n^2)）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cand = <span class="number">0</span>; cand &lt; n; cand++)&#123;</span><br><span class="line">        <span class="keyword">int</span> other;</span><br><span class="line">        <span class="keyword">for</span>(other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cand == other) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果名人候选人cand认识其他人，或者其他人不认识名人，那么该cand无法继续下去</span></span><br><span class="line">            <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(other == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> cand;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,优化，由于名人不认识其他人，其他人都认识名人，那么就决定了n中至多只有一个名人。</span></span><br><span class="line"><span class="comment">//那么对于两个候选人，我一定能排除一个不是名人的人选项，因为两个人的关系只有四种</span></span><br><span class="line"><span class="comment">//（1），cand认识other，cand肯定不是名人，排除cand</span></span><br><span class="line"><span class="comment">//（2），other认识cand，other肯定不是名人，排除other</span></span><br><span class="line"><span class="comment">//（3），两人互相认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"><span class="comment">//（4），两人互相不认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度为O(n),但空间复杂度变为了O(n).PS：LinkedList 的作⽤只是充当⼀个容器把候选⼈装起来，每次找出两个进⾏⽐较和淘汰，但⾄于具体找出哪两个，都是⽆所谓的，也就是说候选⼈归队的顺序⽆所谓，我们⽤的是 addFirst 只是⽅便后续的优化，你完全可以⽤ addLast，结果都是⼀样的。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//放入候选队列中</span></span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q.addLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">int</span> other = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">            <span class="comment">//cand肯定不是候选人，other还有可能</span></span><br><span class="line">            q.addFirst(other);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other肯定不是候选人，cand还有可能</span></span><br><span class="line">            q.addFirst(cand);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只剩一个了，看它是不是名副其实</span></span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3,其实不需要额外的空间，解法时间复杂度为 O(N)，空间复杂度为 O(1)。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设cand为0</span></span><br><span class="line">    <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">1</span>; other &lt; n; other++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!knows(other, cand) || knows(cand, other))&#123;</span><br><span class="line">            <span class="comment">//other有可能是候选者</span></span><br><span class="line">            cand = other;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other不会是名人，直接进入下一次循环</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在确认一下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五，暴力搜索算法"><a href="#五，暴力搜索算法" class="headerlink" title="五，暴力搜索算法"></a>五，暴力搜索算法</h1><h2 id="1，DFS算法-x2F-回溯算法"><a href="#1，DFS算法-x2F-回溯算法" class="headerlink" title="1，DFS算法&#x2F;回溯算法"></a>1，DFS算法&#x2F;回溯算法</h2><p>回溯算法总体框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">	<span class="keyword">if</span> 满⾜结束条件:</span><br><span class="line">		result.add(路径)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">		做选择</span><br><span class="line">		backtrack(路径, 选择列表)</span><br><span class="line">		撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="（1）回溯算法框架"><a href="#（1）回溯算法框架" class="headerlink" title="（1）回溯算法框架"></a>（1）回溯算法框架</h3><p><strong>（引入）</strong>：</p>
<p>解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。你只需要思考3 个问题：<br>            1、路径：也就是已经做出的选择。<br>            2、选择列表：也就是你当前可以做的选择。<br>            3、结束条件：也就是到达决策树底层，⽆法再做选择的条件。  </p>
<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-2.png" alt="sf-2-2" style="zoom:80%;" />

<p><strong>思路</strong>：对于这样一个全排列问题，我们可以得到下面这样一棵树，也就是在遍历的过程中，我们需要在某个节点进行路径和选择列表的更新操作，比如下图的最右边的蓝色节点，我们的路径中添加了[3]，选择列表值变为[1,2]。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-3.png" alt="sf-2-3" style="zoom:67%;" />

<p>之前算法框架中的backtrack()函数就像是一个指针，指向某个节点，在这个节点之前和之后要进行相关操作，正如树的前序和后序遍历一样。所以回溯算法的核心就是，在进入backtrack()函数之前做出正确的操作，进入之后进行操作</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-4.png" alt="sf-2-4" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，在选择列表里面做选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//4，做出选择</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            backtrack(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5，撤销选择</span></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣51——N皇后）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-5.png" alt="sf-2-5" style="zoom: 80%;" />

<p><strong>思路</strong>：皇后所在的位置，要保证上下左右线，对角线没有其他的皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c : board)&#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res.add(charToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            BackTrace(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">charToList</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] c : board) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）集合划分问题"><a href="#（2）集合划分问题" class="headerlink" title="（2）集合划分问题"></a>（2）集合划分问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-7.png" alt="sf-2-7" style="zoom:80%;" />

<p><strong>思路</strong>：本题很符合回溯的思想，需要多种结果，我们也需要进行暴利的遍历尝试来找到答案。但是使用回溯算法的每一道题都有自己的特点，比如这道题，我们在套用框架的过程中，也需要先找到规律。</p>
<p>题中是一个经典的排列组合问题，对于排列组合都可以抽象为球盒模型，本题中我们可以有两种视角：1）对于nums[]中的数字以及最终要放进k个桶，每个数字需要去选择自己应该进哪个桶，最终把每个桶都装满；2）确定要用k个桶去装nums[]数组的数字，由桶来选择要的数字；下面看看代码，注意带数字的注释，带星号的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,以数字视角</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v :nums) sum += v;</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化，将大的数字放到前面去，这样更容易进入*所标记的剪枝语句中去</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>; i &lt; j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//K个桶（集合），记录每个桶装的数字之和</span></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">//理论上每个桶（集合）中的数字和</span></span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        <span class="comment">//穷举，看nums是否能分为k个和为target的数组</span></span><br><span class="line">        <span class="keyword">return</span> backtrace(nums, <span class="number">0</span>, bucket, target);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归穷举nums中的每个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span>[] bucket, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="comment">//1，如果index==nums的长度，表明每个数字似乎都找到了去处，要检查一下是不是合理的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucket[i] != target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于nums[index]，我们要看看他能装进哪个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">            <span class="comment">//*放不进去这个桶</span></span><br><span class="line">            <span class="keyword">if</span>(bucket[i] + nums[index] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放进i这个桶去试一下</span></span><br><span class="line">            bucket[i] += nums[index];</span><br><span class="line">            <span class="comment">//如果说已经满足所有条件了，返回</span></span><br><span class="line">            <span class="keyword">if</span>(backtrace(nums, index + <span class="number">1</span>, bucket, target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">//放进i去是不行的，回溯</span></span><br><span class="line">            bucket[i] -= nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,以桶的视角，k桶在测试nums[start]这个数字是否装进去，k桶目前的装的容量为bucket，如果装了used就要标记，target是每个桶应该装的大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 排除⼀些基本情况</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : nums) sum += v;</span><br><span class="line">	<span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//使用位图技巧来记录使用过得数字</span></span><br><span class="line">	<span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> target = sum / k;</span><br><span class="line">	<span class="comment">// k 号桶初始什么都没装，从 nums[0] 开始做选择</span></span><br><span class="line">	<span class="keyword">return</span> backtrake(k, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1，创建一个备忘录，对于桶中添加数据的组合是有记录的，其实就是used中的数据的出现情况，当某个情况不满足后，新的情况桶选择数字的情况很可能和之前一样。比如[1,1,1,1,0,0]失败和[1,1,1,1,0,0]失败，可能这四个1添加的时机不同，但他们都会失败。</span></span><br><span class="line">HashMap&lt;Integer, Boolean&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">backtrake</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bucket, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> used, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在这个used非常长，就需要使用String来转换处理</span></span><br><span class="line">    <span class="comment">//String state = Arrays.toString(used);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bucket == target)&#123;</span><br><span class="line">        <span class="comment">//装满了当前桶，递归穷举下一个桶的选择，从nums[0]开始</span></span><br><span class="line">        <span class="keyword">boolean</span> res = backtrake(k - <span class="number">1</span>, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">        <span class="comment">//缓存目前的结果</span></span><br><span class="line">        memo.put(used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(used))&#123;</span><br><span class="line">        <span class="comment">//避免重复计算</span></span><br><span class="line">        <span class="keyword">return</span> memo.get(used);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i位是不是1，是的话表明nums[i]已经装到了别的桶里面去了，就不要判断这数字了</span></span><br><span class="line">        <span class="keyword">if</span>(((used &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] + bucket &gt; target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择当前的数字，并记录</span></span><br><span class="line">        used |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket += nums[i];</span><br><span class="line">        <span class="comment">//递归穷举下一个数字是不是可以被加入</span></span><br><span class="line">        <span class="keyword">if</span>(backtrake(k, bucket, nums, i + <span class="number">1</span>, used, target))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）排列-x2F-组合-x2F-子集问题"><a href="#（3）排列-x2F-组合-x2F-子集问题" class="headerlink" title="（3）排列&#x2F;组合&#x2F;子集问题"></a>（3）排列&#x2F;组合&#x2F;子集问题</h3><p><strong>（引入）</strong></p>
<p>这个部分主要有三种基本形式：</p>
<p>形式⼀、元素⽆重不可复选，即 nums 中的元素都是唯⼀的，每个元素最多只能被使⽤⼀次，这也是最基本<br>的形式。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该只有 [7]。<br>        形式⼆、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使⽤⼀次。以组合为例，如果输⼊ nums &#x3D; [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。<br>        形式三、元素⽆重可复选，即 nums 中的元素都是唯⼀的，每个元素可以被使⽤若⼲次。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]  <strong>（元素可重复可复选，其实就是元素去重的可复选）</strong></p>
<p>上⾯⽤组合问题举的例⼦，但排列、组合、⼦集问题都可以有这三种基本形式，所以共有 9 种变化。除此之外，题⽬也可以再添加各种限制条件，⽐如让你求和为 target 且元素个数为 k 的组合，那这么⼀来⼜可以衍⽣出⼀堆变体，怪不得⾯试笔试中经常考到排列组合这种基本题型。  </p>
<p>但⽆论形式怎么变化，其本质就是穷举所有解，⽽这些解呈现树形结构，所以合理使⽤回溯算法框架，稍改代码框架即可把这些问题⼀⽹打尽  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-9.png" alt="sf-2-9" style="zoom:67%;" />

<p><strong>（力扣78——子集）元素无重复不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-8.png" alt="sf-2-8" style="zoom: 80%;" />

<p>​    <strong>思路</strong>：对于这道题，我们采用树的形式来表示的话，可以得到下面这样的树结构</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-10.png" alt="sf-2-10" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		traceback(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="comment">//由于start会与nums.length比较，所以这里不用再添加额外的return条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(res));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;  nums.length; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line">            </span><br><span class="line">            traceback(nunms, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣77——组合）元素无重不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-11.png" alt="sf-2-11" style="zoom: 80%;" />

<p><strong>思路</strong>：与上一题类似，不过这里我们发现，res只需要添加trace的大小为k的时候的情况</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-12.png" alt="sf-2-12" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        traceback(n,<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line"></span><br><span class="line">            traceback(n, i + <span class="number">1</span>, k);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-13.png" alt="sf-2-13" style="zoom:80%;" />

<p><strong>思路</strong>：这里的选择列表不像上一题，所以这里的选择是考used来做出的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            backtrace(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣90——子集2)元素可重不可复选</strong>  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-14.png" alt="sf-2-14" style="zoom:80%;" />

<p><strong>思路</strong>：这道题的剪枝策略，就是避免进入到同一层中的相同元素</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-15.png" alt="sf-2-15" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrace(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(nums[i]);</span><br><span class="line">            backtrace(nums, i + <span class="number">1</span>);</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(力扣40——组合总和)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-16.png" alt="sf-2-16"></p>
<p><strong>思路</strong>：本题和上一题类似，都有重复元素，但是这里需要计算一下总和值与target的关系，并且多了一个剪枝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrace(candidates, target, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start,<span class="keyword">int</span> tracksum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracksum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tracksum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(candidates[i]);</span><br><span class="line">            tracksum += candidates[i];</span><br><span class="line">            backtrace(candidates, target, i + <span class="number">1</span>,tracksum);</span><br><span class="line">            tracksum -= candidates[i];</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣39——组合总和）元素无重复可复选</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-17.png" alt="sf-2-17"></p>
<p><strong>思路</strong>：这道题不是找组合，而是找子集，并且这道题可以复选，那么我们在进行下一个元素选择的时候，范围就不能增加了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        trackback(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackback</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> tracesum,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracesum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tracesum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tracesum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(candidates[i]);</span><br><span class="line">            tracesum += candidates[i];</span><br><span class="line">            <span class="comment">//这里我们不能输入i+1，而是输入i</span></span><br><span class="line">            trackback(candidates, target, tracesum,i);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            tracesum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元素无重复可复选的排列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-18.png" alt="sf-2-18"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteRepeat(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	backtrack(nums);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回溯算法核⼼函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case，到达叶⼦节点</span></span><br><span class="line">	<span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">		<span class="comment">// 收集叶⼦节点上的值</span></span><br><span class="line">		res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 回溯算法标准框架</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 做选择</span></span><br><span class="line">		track.add(nums[i]);</span><br><span class="line">		<span class="comment">// 进⼊下⼀层回溯树</span></span><br><span class="line">		backtrack(nums);</span><br><span class="line">		<span class="comment">// 取消选择</span></span><br><span class="line">		track.removeLast();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）岛屿问题"><a href="#（4）岛屿问题" class="headerlink" title="（4）岛屿问题"></a>（4）岛屿问题</h3><p>岛屿系列题⽬的核⼼考点就是⽤ DFS&#x2F;BFS 算法遍历⼆维数组。这里主要讲使用DFS解决岛屿问题。岛屿问题一般是用二维矩阵来解决，矩阵中的每个位置可以看做一个节点，其上下左右位置就是相邻节点，整个矩阵就可以以此抽象为图结构</p>
<p>岛屿问题的框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.rigth);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//二维矩阵遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="comment">//超出索引啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visited[i][j])&#123;</span><br><span class="line">        <span class="comment">//已经遍历过啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入节点i，j（这里也可以使用方向数组的技巧，都一样）</span></span><br><span class="line">    visited[i][j];</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, visited);<span class="comment">//上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, visited);<span class="comment">//下</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, visited);<span class="comment">//左</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, visited);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣200——岛屿数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-19.png" alt="sf-2-19" style="zoom:80%;" />

<p><strong>思路</strong>：我们遍历这个grid，如果发现了陆地，那么计数器加一，并且使用DFS算法把这块地以及相邻的陆地都变成海水</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    DFS(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用DFS将传进来的索引的相连接的陆地，都变成海水</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        DFS(grid, i - <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i + <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        DFS(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1254——统计封闭岛屿的数目）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-20.png" alt="sf-2-20"></p>
<p><strong>思路</strong>：如果一个岛屿靠边，那肯定是不封闭岛屿，所以可以用DFS将靠边的岛屿先淹了。那剩下的部分，和上题是一样的吗？当然是，因为靠边的部分已经变成了海水，那中间只要有陆地，如果上下左右没有相连，那至少是一个陆地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计边淹不靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1020——飞地的数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-21.png" alt="sf-2-21" style="zoom:80%;" />

<p><strong>思路</strong>：和上一题类似，只是统计res的时候不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣695——岛屿的最大面积）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-22.png" alt="sf-2-22" style="zoom:80%;" />

<p><strong>思路</strong>：还是遇到岛屿要淹没，但是要记录此次淹没的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.max(res, dfs(grid, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dfs(grid, i + <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>) + </span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1905——统计子岛屿）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-23.png" alt="sf-2-23"></p>
<p><strong>思路</strong>：如果grid2中的陆地，对应了grid1中的海洋，那grid2中该陆地所在的岛屿肯定都不是子岛。grid2中剩下的岛屿，必然是对应了grid1中的陆地（也就是grid1中的岛屿）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="keyword">int</span>[][] grid1, <span class="keyword">int</span>[][] grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid1.length, n = grid1[<span class="number">0</span>].length;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid1[i][j] == <span class="number">0</span> &amp;&amp; grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣694——不同岛屿的数量)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-24.png" alt="sf-2-24" style="zoom:67%;" />

<p><strong>思路</strong>：为了判别形状，需要将形状转换成一个序列，然后判断序列的相似性。对于同一个起点进行的遍历，我们最后这个能得到的遍历顺序肯定是相同的，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-25.png" alt="sf-2-25" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="comment">// 记录所有岛屿的序列化结果</span></span><br><span class="line">	HashSet&lt;String&gt; islands = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 淹掉这个岛屿，同时存储岛屿的序列化结果</span></span><br><span class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">			<span class="comment">// 初始的⽅向可以随便写，不影响正确性</span></span><br><span class="line">			dfs(grid, i, j, sb, <span class="number">666</span>);</span><br><span class="line">			islands.add(sb.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不相同的岛屿数量</span></span><br><span class="line">	<span class="keyword">return</span> islands.size();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, StringBuilder sb, <span class="keyword">int</span> dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    sb.append(dir).apped(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, sb, <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, sb, <span class="number">2</span>);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, sb, <span class="number">3</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, sb, <span class="number">4</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="2，BFS算法"><a href="#2，BFS算法" class="headerlink" title="2，BFS算法"></a>2，BFS算法</h2><p>BFS 算法使用队列来实现，常⻅于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达⽬标时的代价是最⼩的。  </p>
<h3 id="（1）BFS算法框架"><a href="#（1）BFS算法框架" class="headerlink" title="（1）BFS算法框架"></a>（1）BFS算法框架</h3><p><strong>（两个点之间的最近距离——框架引入）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start, Node end)</span></span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//这里存储了一层的node</span></span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            <span class="keyword">for</span>(Node node : cur.adj())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node not in cur)&#123;</span><br><span class="line">                    q.offer(node);</span><br><span class="line">                    visited.add(node);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一层为一个step</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。以处理⼆叉树问题的例⼦（下一题），假设给你的这个⼆叉树是满⼆叉树，节点数为 N，对于 DFS 算法来说，空间复杂度⽆⾮就是递归堆栈，最坏情况下顶多就是树的⾼度，也就是 O(logN)。但是你想想 BFS 算法，队列中每次都会储存着⼆叉树⼀层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，⽤ Big O 表示的话也就是 O(N)。由此观之，BFS 还是有代价的，⼀般来说在找最短路径的时候使⽤ BFS，其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣111——二叉树的最小深度）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-26.png" alt="sf-2-26" style="zoom:67%;" />

<p><strong>思路</strong>：套用上面的模板，在某一层的节点中，如果发现某个节点是叶节点，则返回step即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣752——打开轮盘锁）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-27.png" alt="sf-2-27"></p>
<p><strong>思路</strong>：这个题分的思路分为三个阶段：1）使用图的思想进行穷举所有密码；2）在穷举所有密码的基础上，对当前情况进行判断；3）双向BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,如何用BFS的思想对密码进行穷举呢？对于一个初试密码0000，每一个位置都可以up和down，也就是每个位置有2中情况，4个位置就是8种情况，其实也就是0000这个节点有8个子节点</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	ch[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        in sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">//这里进行判断</span></span><br><span class="line">           	System.out.println(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里增加步数 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,1中的代码中我们已经可以列举出所有的密码组合，接下来我们就需要结合题意来进行目标的寻找。我们需要明确三个点：1）target就是我们需要找的目标；2）0000的一个子节点为1000，但1000中又会把0000加进去，造成了死循环；3）遇到死亡代码时，我们的不对其进行操作，因为我们尝试不遇到这种情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(target))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，使用双向BFS来进行优化，也就是同时设置两个起点，当然使用这个必须知道当前情况中的起点和终点，像二叉树找最短深度就用不了。但是在这道题中，我们发现起点就是&quot;0000&quot;，终点就是target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    q1.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String cur : q1)&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q2.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    temp.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）BFS解决智力题"><a href="#（2）BFS解决智力题" class="headerlink" title="（2）BFS解决智力题"></a>（2）BFS解决智力题</h3><p><strong>(力扣773——滑动谜题)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-28.png" alt="sf-2-28"></p>
<p><strong>思路</strong>：对于0来说，它可以走上下左右等位置，进而基于一个情况，可以衍生出子情况，这样就转化成了图的问题。但是本题的关键在于，如何去获取某种情况的子情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//1，目标字符串</span></span><br><span class="line">        String target = <span class="string">&quot;123450&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，获取初始的start</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                sb.append(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String start = sb.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3，这个数组能够获取某个位置相邻的位置，我们将2x3的数组抽象为长度为6的一维数组，那么下标为0的位置在原来的二位数组中对应下标为1，和3的元素</span></span><br><span class="line">        <span class="keyword">int</span>[][] neighbor = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">2</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4，BFS的核心逻辑</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz =q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                String cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(target.equals(cur)) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">//5，找到当前0所在的位置</span></span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(; cur.charAt(idx) != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">                <span class="comment">//将0和周围的元素进行交换，获得新的字符串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> adj : neighbor[idx])&#123;</span><br><span class="line">                    String new_board = swap(cur.toCharArray(), adj, idx);</span><br><span class="line">                    <span class="comment">//避免走回头路</span></span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(new_board))&#123;</span><br><span class="line">                        q.offer(new_board);</span><br><span class="line">                        visited.add(new_board);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">        chars[i] = chars[j];</span><br><span class="line">        chars[j] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六，动态规划"><a href="#六，动态规划" class="headerlink" title="六，动态规划"></a>六，动态规划</h1><h2 id="1，动态规划核心原理"><a href="#1，动态规划核心原理" class="headerlink" title="1，动态规划核心原理"></a>1，动态规划核心原理</h2><h3 id="（1）动态规划解题核心框架"><a href="#（1）动态规划解题核心框架" class="headerlink" title="（1）动态规划解题核心框架"></a>（1）动态规划解题核心框架</h3><p>动态规划问题的一般形式就是求最值，它其实是运筹学的⼀种最优化⽅法，只不过在计算机问题上应⽤⽐较多，⽐如说让你求最⻓递增⼦序列呀，最⼩编辑距离等等。</p>
<p>求最值的核心一般就是穷举，但是动态规划中，存在<strong>“重叠子问题”</strong>这种特殊情况，所以需要<strong>“备忘录”</strong>或“DP table”来优化穷举过程，避免不必要的计算。此外，动态规划问题中一定具备<strong>“最优子结构”</strong>，这样才能通过子问题的最值得到原问题的最值。寻找最优子结构，就需要在穷举的过程中，获取正确的<strong>“状态转移方程”</strong>。</p>
<p>这几个步骤中，最难的就是找状态转移方程，一般我们遵循以下步骤来寻找状态转移方程：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组&#x2F;函数的含义</strong> 。照此可以得到下面的框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初试化base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base;</span><br><span class="line"><span class="comment">//对不同的状态state，进行状态的转移</span></span><br><span class="line"><span class="keyword">for</span>  state1 in state1All:</span><br><span class="line">	<span class="keyword">for</span> state2 in state2All:</span><br><span class="line">		<span class="keyword">for</span>...</span><br><span class="line">            dp[state1][state2][...] = getMaxOrMin(choice1, choice2,...)</span><br></pre></td></tr></table></figure>

<p><strong>（力扣509——斐波那契数列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-29.png" alt="sf-2-29"></p>
<p><strong>思路</strong>：</p>
<p>a，这是一道认识动态规划的入门题。该算法可以使用传统的递归方法，但是其中存在大量的重复操作，效率比较低。这里我们直接看讲义中的分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-30.png" alt="sf-2-30"> </p>
<p>b，想要对上面的递归过程进行效率上的提升，我们可以引入「备忘录」，每次算出某个⼦问题的答案后别急着返回，先记到「备忘录」⾥再返回；每次遇到⼀个⼦问题先去「备忘录」⾥查⼀查，如果发现之前已经解决过这个问题了，直接把答案拿出来⽤，不要再耗时去计算了。  </p>
<p>备忘录其实协助进行了一个剪枝操作，下面这两张图就能看出其中的原理，左边表明了剪枝的情况，右边则说明了递归是自顶向下进行的。此时算法的时间复杂度是 O(n)，⽐起上面的暴⼒算法，是降维打击  。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-31.png" alt="sf-2-31" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-32.png" alt="sf-2-32" style="zoom:67%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">//设定备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里是base case</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">//如果备忘录中已经有值，就别再计算啦</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    </span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>c，DP数组迭代（递推）解法</p>
<p>这里我们可以把这个「备忘录」独⽴出来成为⼀张表，通常叫做 DP table，在这张表上完成「⾃底向上」的推算 （左图）；这⾥，引出「状态转移⽅程」这个名词，实际上就是描述问题结构的数学形式（右图）；</p>
<p>f(n) 的函数参数会不断变化，所以你把参数 n 想做⼀个状态，这个状态 n 是由状态 n - 1 和状态 n - 2转移（相加）⽽来，这就叫状态转移，仅此⽽已。你会发现，上⾯的⼏种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] &#x3D; dp[i -1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个⽅程式的不同表现形式。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-33.png" alt="sf-2-33" style="zoom: 50%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-34.png" alt="sf-2-34" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据斐波那契数列的状态转移⽅程，当前状态只和之前的两个状态有关，其实并不需要那么⻓的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就⾏了.</span></span><br><span class="line"><span class="comment">//这⼀般是动态规划问题的最后⼀步优化，如果我们发现每次状态转移只需要 DP table 中的⼀部分，那么可以尝试缩⼩ DP table 的⼤⼩，只记录必要的数据，从⽽降低空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分别代表 dp[i - 1] 和 dp[i - 2]</span></span><br><span class="line">	<span class="keyword">int</span> dp_i_1 = <span class="number">1</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">// dp[i] = dp[i - 1] + dp[i - 2];</span></span><br><span class="line">		<span class="keyword">int</span> dp_i = dp_i_1 + dp_i_2;</span><br><span class="line">		<span class="comment">// 滚动更新</span></span><br><span class="line">		dp_i_2 = dp_i_1;</span><br><span class="line">		dp_i_1 = dp_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣322——零钱兑换)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-35.png" alt="sf-2-35" style="zoom:80%;" />

<p><strong>思路</strong>：首先明确，该问题具有<strong>最优子结构</strong>（也就是硬币用的数量之间不能有互相的影响，而是每个面额都可以随便用），具体来看就是<strong>原问题</strong>为amount &#x3D; 11时的最小子硬币数，<strong>子问题</strong>为amount &#x3D; 10时的最小子硬币数，那么原问题 &#x3D; 子问题 + 1个硬币即可。确定了最优子结构以后，我们按照三个步骤来完成本题：</p>
<p>A，<u>明确dp数组的含义</u>：当目标金额为i时，至少要dp[i]个硬币才能凑出来</p>
<p>B，<u>状态转移方程</u>：dp[i] &#x3D; dp[i - coin] + 1，由于是要找最小且coin的情况有三种，所以这里应该是min{dp[i] &#x3D; dp[i - coin] + 1, dp[i]}</p>
<p>C,<u>确定初始值</u>：dp[0] &#x3D; 0;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - coin &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）base-case和备忘录的初试值怎么定"><a href="#（2）base-case和备忘录的初试值怎么定" class="headerlink" title="（2）base case和备忘录的初试值怎么定"></a>（2）base case和备忘录的初试值怎么定</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-36.png" alt="sf-2-36"></p>
<p><strong>思路</strong>：</p>
<p><u>A，首先是定义DP数组的含义</u>：int dp(int[][] matrix, int i, int j);  这里其实是个一个特殊的dp数组，表示从第一行的任意位置落下，到i和j位置所需要的最小路径。</p>
<p><u>B，明确状态转移方程</u>；对于matrix[i][j]，它的值的状态是由matrix[i-1][j]，matrix[i-1][j-1]，matrix[i-1][j+1]这三个值来确定的，也就是其中的最小值+matrix[i][j]本身的值。</p>
<p><u>C，确定初始值</u>：第一个行的每个值都是其本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，下面是没有进行剪枝的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(res, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//进行某个点的计算</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i，j位置的值有三个状态确定</span></span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,可以加上备忘录来减少运算</span></span><br><span class="line"><span class="keyword">int</span> memo[][];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        Arrays.fill(memo[j], <span class="number">66666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(matrix, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != <span class="number">66666</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line">本题中的base <span class="keyword">case</span>比较隐蔽，但是只要抓住题中描述，第一行到最后一行的最小值，我们就可以发现，如果只有第一行，那就是当前位置的值，所以base <span class="keyword">case</span>就是<span class="number">0</span>行时的情况</span><br><span class="line">对于备忘录，我们设置了<span class="number">66666</span>的特殊值，这个只要比题意中要求的最大路径还要大就行，那样就不影响结果啦</span><br></pre></td></tr></table></figure>



<h3 id="（3）最优子结构和dp数组的遍历方向怎么定"><a href="#（3）最优子结构和dp数组的遍历方向怎么定" class="headerlink" title="（3）最优子结构和dp数组的遍历方向怎么定"></a>（3）最优子结构和dp数组的遍历方向怎么定</h3><p><strong>最优子结构</strong>：动态规划基于最优子结构，最优子结构意味着题目中的情况有重复子问题。（没有重复子问题不就是递归吗？），在重复子问题的基础上，要求一个最值！（其实有动态子结构就可以写暴力解，然后能优化重复子问题再优化，就是动态规划的一般形式了）</p>
<p>越是困难的动态规划题，最优子结构往往越是隐蔽，这里很好理解，如果一个学校有十个班，每个班的最高分我们可以计算，那么要求全校的最高分我们也能够通过每个班的最高分这个子问题来计算；但是，如果知道每个班的最大分差（最高分 - 最低分），我们并不一定能够知晓全校的最大分差。</p>
<p>那怎么办呢？只能<strong>改造问题</strong>，比如假设最低分基数为0，这样就知道了每个班最高分是多少，然后就可以把问题转换为求最高分。</p>
<p><strong>重叠子问题</strong>：最简单的方式就是把递归树画出来看有没有重叠的子问题（前面的斐波那契数列已经讲过了）</p>
<p>另外就是对于递归部分的代码进行检查，观察从一个状态到另一个状态到底有几种可能，如果有多种可能，那就说明有重复子问题，比如上一节中的matrix[i][j]的转移情况</p>
<p><strong>数组的遍历方向</strong>：有时数组从上往下遍历，有时从下往上，甚至斜着遍历，把握两点，1）遍历的过程中，所需的状态必须是已经计算出来的 ；2）遍历结束后，存储结果的那个位置必须已经被计算出来 </p>
<h3 id="（4）提高刷题幸福感的小技巧"><a href="#（4）提高刷题幸福感的小技巧" class="headerlink" title="（4）提高刷题幸福感的小技巧"></a>（4）提高刷题幸福感的小技巧</h3><h2 id="2，经典动态规划"><a href="#2，经典动态规划" class="headerlink" title="2，经典动态规划"></a>2，经典动态规划</h2><h3 id="（1）最长递增子序列问题"><a href="#（1）最长递增子序列问题" class="headerlink" title="（1）最长递增子序列问题"></a>（1）最长递增子序列问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-37.png" alt="sf-2-37"></p>
<p><strong>思路</strong>：</p>
<p>第一种：数学归纳法</p>
<p><u>A，DP数组的定义</u>：dp[i] 表示以 nums[i] 这个数结尾的最⻓递增⼦序列的⻓度。  （最终的结果就是dp数组中的最大值）</p>
<p><u>B，确定初试值</u>：dp[i]最开始是1，因为子序列肯定有一个自己</p>
<p><u>C，状态转移方程</u>：如果我知道了dp[0~4]的值，我如何计算dp[5]的值？？？</p>
<p>比如下图，我们nums[5]的值为3，那么我们需要找到前⾯那些结尾⽐ 3 ⼩的⼦序列，然后把 3 接到最后，就可以形成⼀个新的递增⼦序列，⽽且这个新的⼦序列⻓度加⼀。  </p>
<p>当然，可能形成很多种新的⼦序列，但是我们只选择最⻓的那⼀个，把最⻓⼦序列的⻓度作为 dp[5] 的值即可。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-38.png" alt="sf-2-38" style="zoom: 33%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-39.png" alt="sf-2-39" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//时间复杂度为O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）最大子数组和问题"><a href="#（2）最大子数组和问题" class="headerlink" title="（2）最大子数组和问题"></a>（2）最大子数组和问题</h3><p><strong>（力扣53——最大子数组和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-40.png" alt="sf-2-40"></p>
<p><strong>思路</strong>：此题无法使用滑动窗口，因为有负数，窗口中值的变化不利于判断窗口如何改变</p>
<p>A，<u>明确dp数组的含义</u>：以 nums[i] 为结尾的「最⼤⼦数组和」为 dp[i]。</p>
<p>B，<u>确定初始值</u>：dp[i] &#x3D; nums[i]</p>
<p>C，<u>确定状态转移方程</u>：假设已经算出了 dp[i-1]，那么dp[i]有两种选择，dp[i-1] + nums[i]或者就是dp[i - 1]，看谁打就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）最长公共子序列问题"><a href="#（3）最长公共子序列问题" class="headerlink" title="（3）最长公共子序列问题"></a>（3）最长公共子序列问题</h3><p><strong>（力扣1143——最长公共子序列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-41.png" alt="sf-2-41"></p>
<p><strong>思路</strong>：两种思路，一种是自顶向下（递归），一种所以自底向上（迭代），下面是按顺序来说明</p>
<p>A，<u>明确dp函数</u>：dp(s1,i,s2,j)计算<code>s1[i..]</code>和<code>s2[j..]</code>的最长公共子序列长度。那么最后的答案就是i和j为0的时候</p>
<p>B，<u>初始状态</u>：也即是i为s1的长度，j为s2的长度，此时计算的是两个空串的公共子序列长度，那此时dp的值就是0</p>
<p>C，<u>转移方程</u>：如果s1[i]与s2[j]是相等的，那么这两个字符一定在LCS当中（左图）；<code>s1[i] != s2[j]</code>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中（右图），此时需要把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度（这里还有一个优化，情况3中的结果肯定比情况1和2短，所以可以不算，一定程度上就是被包含了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-42.png" alt="sf-2-42" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-43.png" alt="sf-2-43" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(text1, <span class="number">0</span>, text2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length() || j == s2.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] =  Math.max(dp(s1, i + <span class="number">1</span>, s2, j), dp(s1, i, s2, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[i][j]表示s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度，我们的目标是求dp[m][n]的lcs的值</p>
<p>B，<u>确定初始状态</u>：dp[0][0]的值为0</p>
<p>C，确定状态转移方程：这里直接看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣583——两个字符串的删除操作）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-44.png" alt="sf-2-44" style="zoom:80%;" />

<p><strong>思路</strong>：计算出最长子序列即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助上一题的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣712——两个字符串的最小ASCII删除和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-45.png" alt="sf-2-45" style="zoom:80%;" />

<p><strong>思路</strong>：采用自顶向下的方式（递归）</p>
<p>A，<u>定义dp函数</u>：dp(s1, i, s2, j)表示将串删除为s1[i…]和s2[j…]这样时所需要的最小ASCII和。我们的目标是得到dp(s1,0,s2,0)</p>
<p>B，<u>确定初始值</u>：如果i的值为s1.length(),那么结果中是删除s2剩下元素的总和，反之亦然。</p>
<p>C，<u>确定状态转移方程</u>：如果i和j位置的字符相同，那么从当前状态来看，就不要删除。如果不同，则需要从其他的状态中找最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] mm : memo)&#123;</span><br><span class="line">            Arrays.fill(mm, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; s2.length(); j++)&#123;</span><br><span class="line">                res += s2.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == s2.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; s1.length(); i++)&#123;</span><br><span class="line">                res += s1.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">                memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j +<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这里的意思是，继续去找s1.i和s2.j+1对比 以及 s1.i+1和s2.j对比所需要的删除的最小值。所以其实不存在示例2中出错的情况</span></span><br><span class="line">                memo[i][j] = Math.min(dp(s1, i, s2, j +<span class="number">1</span>) + s2.charAt(j), dp(s1, i + <span class="number">1</span>, s2, j) + s1.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代，base case需要设置好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case，</span></span><br><span class="line">        <span class="comment">//如果s2为空，那么s1对应每个位置的需要删除的值就是自己字符串中的值相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + s1.charAt(i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + s2.charAt(j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>), dp[i - <span class="number">1</span>][j] + s1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）编辑距离问题"><a href="#（4）编辑距离问题" class="headerlink" title="（4）编辑距离问题"></a>（4）编辑距离问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-46.png" alt="sf-2-46" style="zoom:80%;" />

<p><strong>思路</strong>：还是分为递归和迭代</p>
<p>A，<u>定义DP函数</u>：对于两个字符串，我们可以从字符串尾开始，如下图，尝试将是b变为s2，我们发现对于i和j指针所指向的字符，包含了三种操作：插入，删除，替换（图中的流程是上帝视角），在这个位置我们到底选择哪种操作，其实是不知道的，必须去找其中最小的那个值；还有一个操作，就是相同的时候啥也别做，减少操作次数。   所以我们可以定义一个DP(s1, i, s2, j)，该函数返回 s1[0..i] 和 s2[0..j] 的最⼩编辑距离 。当i或j为0的时候，就返回另一个字符剩下的长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.gif" alt="sf-2-47" style="zoom: 50%;" />  <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.png" alt="sf-2-47" style="zoom:50%;" /></p>
<p>B，<u>明确初始值</u>：DP函数中的Base，当任意一个字符创到结尾时，返回另一个字符串剩下的长度即可。</p>
<p>C，<u>状态转移方程</u>：DP(s1, i, s2, j) 的值取决于i和j位置处的字符是不是相等的，如果不相等，那就是看插入，删除，还是替换哪种值最小，min(DP(s1, i, s2, j - 1) + 1, DP(s1, i - 1, s2, j) + 1, DP(s1, i - 1 , s2, j - 1) + 1)这三种情况是根据图中以s2位基础修改s1得来的；如果相等，则DP(s1, i, s2, j) &#x3D; DP(s1, i - 1, s2, j - 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP(word1, m - <span class="number">1</span>, word2, n - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(String s1, <span class="keyword">int</span> m, String s2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[m][n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(m) == s2.charAt(n))&#123;</span><br><span class="line">            memo[m][n] = DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[m][n] = Math.min(DP(s1, m, s2, n - <span class="number">1</span>) + <span class="number">1</span>, Math.min(DP(s1, m - <span class="number">1</span>, s2, n) + <span class="number">1</span>,DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>明确dp含义</u>：s1[0..i] 和 s2[0..j] 的最⼩编辑距离是 dp[i-1][j-1]  </p>
<p>B，<u>明确初始值</u>：DP[i][0] &#x3D; i ,DP[0][j] &#x3D; j  </p>
<p>C，<u>状态转移方程</u>：如果说i - 1和j - 1处的字符相同，那么DP[i][j] &#x3D; DP[i - 1][j - 1]。如果不同，则也是分三种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] DP = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) DP[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) DP[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    DP[i][j] = DP[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    DP[i][j] = Math.min(DP[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(DP[i][j - <span class="number">1</span>] +<span class="number">1</span>, DP[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>：</p>
<p>A，字符创比较类问题都可以抽象为下面的图，并且可以看到只有三个状态可以降低空间复杂度</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-48.png" alt="sf-2-48" style="zoom:67%;" /> 

<img src="C:\Users\zhao\Desktop\sf-2-49.png" alt="sf-2-49" style="zoom: 80%;" />

<p>B，可以输出路径</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-50.png" alt="sf-2-50" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-51.png" alt="sf-2-51" style="zoom:80%;" />

<h3 id="（5）正则表达式问题"><a href="#（5）正则表达式问题" class="headerlink" title="（5）正则表达式问题"></a>（5）正则表达式问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-52.png" alt="sf-2-52"></p>
<p><strong>思路</strong>：这个匹配的过程要想清楚，我们用两个指针来指向s和p字符串，如果字符串中没有*号的话，那么对于两个指针指向的字符，只要相同或者p中一个 . 我们就认为匹配。比如abbbc和a…c是匹配的</p>
<p>加入了*号后，稍微有点复杂，p中的某个字符是* ,那么p之前的那个字符，到底匹配了几次呢？或者说，它能够消耗s中的字符吗？消耗1次？n次？还是0次？</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-53.png" alt="sf-2-53" style="zoom:67%;" />

<p>所以本题中的状态就是i和j中指针的位置，选择就是p[j]选择匹配几个字符</p>
<p>A，<u>定义的dp函数</u>：bool dp(String s, int i, String p, int j)，该函数返回<code>s[i..]</code>是否可以匹配<code>p[j..]</code>，我们的目标就是找到i和j为0的结果</p>
<p>B，<u>确定初始值</u>：一个 base case 是<code>j == p.size()</code>时，按照<code>dp</code>函数的定义，这意味着模式串<code>p</code>已经被匹配完了，那么应该看看文本串<code>s</code>匹配到哪里了，如果<code>s</code>也恰好被匹配完，则说明匹配成功：另一个比较特殊，下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-54.png" alt="sf-2-54" style="zoom:67%;" />

<p>C，<u>状态转移</u>：其实就是上面的情况中的翻译，先看代码再看解释</p>
<p><strong>TNND做了三四个小时了，受不了了，就是跑不对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j == p.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>((p.length() - j) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; p.length(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j + <span class="number">1</span>)  != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">            memo[i][j] = Math.max(dp(s, i, p, j + <span class="number">2</span>) ,dp(s, i + <span class="number">1</span>, p, j));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            memo[i][j] = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>妥协了，cv大法好</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-55.png" alt="sf-2-55" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//&quot;&quot; 和p的匹配关系初始化，a*a*a*a*a*这种能够匹配空串，其他的是都是false。</span></span><br><span class="line">        <span class="comment">//  奇数位不管什么字符都是false，偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i+= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> sc = s.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> pc = p.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sc == pc || pc == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j - <span class="number">2</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3，背包问题"><a href="#3，背包问题" class="headerlink" title="3，背包问题"></a>3，背包问题</h2><p>背包问题本质上还是动态规划问题，接下来是一些应用于该问题的标准套路和规则</p>
<p>首先，问题中的状态和选择，状态有两个，就是「背包的容量」和「可选择的物品」。  对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」  </p>
<p>接着，dp数组的含义，由于状态有两个，那么dp数组也是二维的。dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最⼤价值是 dp[i][w]。  如果 dp[3][5] &#x3D; 6，其含义为：对于给定的⼀系列物品中，若只对前 3 个物品进⾏选择，当背包<br>容量为 5 时，最多可以装下的价值为 6。  (base case 就是 dp[0][..] &#x3D; dp[..][0] &#x3D; 0，因为没有物品或者背包没有空间的时候，能装的最⼤价值就是 0 )</p>
<p>最后，就是根据选择来进行状态转移</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-56.png" alt="sf-2-56" style="zoom:67%;" /> 

<p>代码框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] wt, <span class="keyword">int</span>[] val)</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(itn w = <span class="number">1</span>; w &lt;= W; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w - wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//第i个物品的重量是wt[i - 1]，这里发现，放不进去啦，就和前面一样就行</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//第i个物品的价值是val[i - 1],占用的空间是wt[i - 1],所以试着装进去看一下</span></span><br><span class="line">                <span class="comment">//dp[i - 1][w - wt[i - 1]]表示的是，前i - 1个物品，容量预留了w - wt[i - 1]，此时的最大价值，这样才能将i个物品放进去咯</span></span><br><span class="line">                dp[i][w] = Math.max(dp[i - <span class="number">1</span>][w - wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（1）0-1背包问题"><a href="#（1）0-1背包问题" class="headerlink" title="（1）0-1背包问题"></a>（1）0-1背包问题</h3><p>同上</p>
<h3 id="（2）完全背包问题"><a href="#（2）完全背包问题" class="headerlink" title="（2）完全背包问题"></a>（2）完全背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-57.png" alt="sf-2-57" style="zoom: 80%;" /> 

<p><strong>思路</strong>：有⼀个背包，最⼤容量为 amount，有⼀系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量<br>⽆限。请问有多少种⽅法，能够把背包恰好装满  （要装满就是完全背包问题）</p>
<p>A，<u>明确状态和选择</u>：状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」</p>
<p>B，<u>明确dp数组的定义</u>：dp[i][j]表示使用前i个硬币，凑出总额为j的情况，有多少种凑法，这里不同于0-1背包</p>
<p>C，<u>明确初始值</u>：dp[0][..] &#x3D; 0， dp[..][0] &#x3D; 1  </p>
<p>D，<u>状态转移（怎么做选择？）</u>：如果你不把这第 i 个物品装⼊背包，也就是说你不使⽤ coins[i] 这个⾯值的硬币，那么凑出⾯额 j 的⽅法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。  如果你把这第 i 个物品装⼊了背包，也就是说你使⽤ coins[i] 这个⾯值的硬币，那么 dp[i][j] 应该等于dp[i][j-coins[i-1]] <strong>(这里很离谱，似乎是表现了只能放一个coins[i]硬币，但是嗷，很快嗷，很离谱嗷，这里第一个下标是i，根据定义来说，这个下标已经包含了使用coins[i]的其他情况)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - coins[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以压缩状态，进⼀步降低算法的空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> = coins.length;</span><br><span class="line">    <span class="comment">//dp数组表示在使用i个硬币的情况下，j金额需要多少硬币才能凑成</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0表示金额0，不管几枚硬币都是一种情况</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - coins[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//这里的状态转移就是包含了第i个硬币加进来，和没加进来的情况</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）子集背包问题"><a href="#（3）子集背包问题" class="headerlink" title="（3）子集背包问题"></a>（3）子集背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-58.png" alt="sf-2-58" style="zoom:80%;" />

<p><strong>思路</strong>：转化一下，给⼀个可装载重量为 sum &#x2F; 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在⼀种装法，能够恰好将背包装满？  </p>
<p>A，<u>dp[][]数组的定义</u>：dp[i][j] &#x3D; x 表示，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明有一种组合可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满 。如果 dp[4][9] &#x3D; true，其含义为：对于容量为 9 的背包，若只是⽤前 4 个物品，可以有⼀种⽅法把背包恰好装满 （也就是对于sum为9，前4个数字中有一种组合可以得到sum为9）</p>
<p>B，<u>确定初始值</u>：想求的最终答案就是 dp[N][sum&#x2F;2]，base case 就是 dp[..][0] &#x3D; true 和 dp[0][..] &#x3D; false，因为背包没有空间的时候，就相当于装满了，⽽当没有物品可选择的时候，肯定没办法装满背包 。</p>
<p>C，<u>状态转移</u>：如果不把 nums[i] 算⼊⼦集，或者说你不把这第 i 个物品装⼊背包，那么是否能够恰好装满背包，取决于上⼀个状态 dp[i-1][j]，继承之前的结果。如果把 nums[i] 算⼊⼦集，或者说你把这第 i 个物品装⼊了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4，用动态规划解决游戏类问题"><a href="#4，用动态规划解决游戏类问题" class="headerlink" title="4，用动态规划解决游戏类问题"></a>4，用动态规划解决游戏类问题</h2><h3 id="（1）股票买卖类问题"><a href="#（1）股票买卖类问题" class="headerlink" title="（1）股票买卖类问题"></a>（1）股票买卖类问题</h3><p><strong>(力扣118——买卖股票的最佳时机4)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-59.png" alt="sf-2-59"></p>
<p><strong>思路</strong>：首先明确状态和选择，本题中的<strong>选择</strong>有三个：买⼊、卖出、⽆操作，我们⽤ buy, sell, rest 表示这三种选<br>择 ，但是不是每天可以任意选择，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，⼀种是 buy 之后的 rest（持有了股票），⼀种是 sell 之后的rest（没有持有股票）。⽽且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。  <strong>状态</strong>有三个，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨⽤ 1 表示持有，0 表示没有持有）。然后我们⽤⼀个三维数组就可以装下这⼏种状态的全部组合 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n - <span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，⼤ K 为交易数的上限，<span class="number">0</span> 和 <span class="number">1</span> 代表是否持有股票。</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">			<span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">				dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。再⽐如 dp[2][3][0] 的含义：今天是第⼆天，我现在⼿上没有持有股票，⾄今最多进⾏ 3 次交易 。\\\我们的目标是求dp[n - 1][K][0]，即最后⼀天，最多允许 K 次交易，最多获得多少利润 (注意最后为0肯定比最后为1获得的利润多)</p>
<p>B，<u>状态转移</u>：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-60.png" alt="sf-2-60" style="zoom: 33%;" />    

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 sell )</span><br><span class="line"><span class="comment">//解释：今天我没有持有股票，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就没有持有，且截⾄昨天最⼤交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最⼤交易次数限制依然为 k。</span></span><br><span class="line"><span class="comment">//2、我昨天持有股票，且截⾄昨天最⼤交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最⼤交易次数限制依然为 k。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 buy )</span><br><span class="line"><span class="comment">//解释：今天我持有着股票，最⼤交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就持有着股票，且截⾄昨天最⼤交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最⼤交易次数限制依然为 k  </span></span><br><span class="line"><span class="comment">//2、我昨天本没有持有，且截⾄昨天最⼤交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最⼤交易次数限制为 k。(今天我要买股票了，消耗一次交易次数，所以昨天最大次数限制为k-1，今天我才能买股票)</span></span><br></pre></td></tr></table></figure>

<p>C，<u>明确初始值</u>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：还没开始的时候，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：不允许交易的情况下，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值</span></span><br></pre></td></tr></table></figure>

<p>总体上的框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base <span class="keyword">case</span>：<span class="comment">//这还有-1，当然实际做题的时候会有应对</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移⽅程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p><strong>（力扣121——买卖股票的最佳时机）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-61.png" alt="sf-2-61"></p>
<p><strong>思路</strong>：根据前面定定义的情况套就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">            = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -price[i])<span class="comment">//这里我们发现dp[i - 1][0][0] = 0</span></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">         = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + -price[i]);</span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> = -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 空间复杂度优化版本</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = prices.length;</span><br><span class="line">		<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">			dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">			dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp_i_0;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣309——股票买卖最佳时机含冷冻期)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-62.png" alt="sf-2-62" style="zoom:80%;" />

<p><strong>思路</strong>：交易次数是无线的；包含冷冻期，在购买股票的时候状态转移的位置要注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);<span class="comment">//这里i天购买股票，应该是i-2的参照</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间复杂度优化版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">		dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">		dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">		dp_pre_0 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣714——买卖股票的最佳时机含手续费)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-63.png" alt="sf-2-63" style="zoom:80%;" />

<p><strong>思路</strong>：k还是无限的，每次买的把手续费减了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i] - fee;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣123——买卖股票的最佳时机交易次数为2）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-64.png" alt="sf-2-64" style="zoom:80%;" />

<p><strong>思路</strong>：这里注意，根据框架来说，这里的k初始值为2，我们在进行状态选择的时候，要将k加进去遍历，k的初试值为2，最小值为1，是递减的情况，和i是反着来的，这是一种符合语义的方式（递增也可以得到正确答案），因为递减表示交易的机会在减少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣188——买卖股票的最佳时机4）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-65.png" alt="sf-2-65" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>如果直接是将上一题的2换成输入的值，是通不过不了的哦，因为测试用例k会故意给你一个很大的值，这样new数组的时候就超出内存限制了。</p>
<p>但是我们可以发现，如果k的值超过了n&#x2F;2，那就是交易次数没有限制的情况啦。</p>
<p>反之就是要限制的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_inf(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_k(prices, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_k</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = max;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算k为0的时候的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）打家劫舍类问题"><a href="#（2）打家劫舍类问题" class="headerlink" title="（2）打家劫舍类问题"></a>（2）打家劫舍类问题</h3><p><strong>（力扣198——打家劫舍）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-66.png" alt="sf-2-66" style="zoom:80%;" />

<p><strong>思路</strong>：明确状态和选择，对于一排房子，<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p>
<p>A，<u>明确dp函数的含义</u>：dp(int[] nums, int start)，表示从start位置抢，能获得的最大值</p>
<p>B，<u>明确初始值</u>：这里就是函数中的base case，当start为nums的长度的时候，dp函数应该返回0</p>
<p>C，<u>状态转移过程</u>：对于一个房子nums[i]，可以选择不抢（不抢就光顾下一家nums[i + 1]），也可以选择抢（那下一家就只能是nums[i + 2]，因为要隔着抢），从这两个里面选最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>), nums[start] + dp(nums, start + <span class="number">2</span>));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//1，dp[i]表示抢劫第i家房屋的时候，最大收益</span></span><br><span class="line">        <span class="comment">//2,base case就是抢劫第n + 1家房屋的时候，收益是0，没得抢了已经</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//3，对于第i个房屋的最大收益，取决于前一个状况的收益，和目前抢了这家，前两个情况的收益</span></span><br><span class="line">            dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣213——打家劫舍2）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-67.png" alt="sf-2-67"></p>
<p><strong>思路</strong>：这里再多加一个判断就行了，因为收尾两个位置不能同时选，所以演化出了下面的三种情况，也就是数组的长度被限制住了。这里显然，情况2和情况3比情况1要更好。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-68.png" alt="sf-2-68" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = dp(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res2 = dp(nums, <span class="number">1</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>, end), nums[start] + dp(nums, start + <span class="number">2</span>, end));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>), robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣337——打家劫舍3）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-69.png" alt="sf-2-69" style="zoom:67%;" />

<p><strong>思路</strong>：父节点处的值，应该和两个子节点有关，也就是在状态转移的时候，应该看当前节点的左右子节点的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> do_it = root.val  + </span><br><span class="line">            (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">            + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="keyword">int</span> not_do = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="keyword">int</span> res = Math.max(do_it, not_do);</span><br><span class="line"></span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）博弈问题"><a href="#（3）博弈问题" class="headerlink" title="（3）博弈问题"></a>（3）博弈问题</h3><p><strong>（力扣877——石子游戏）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-70.png" alt="sf-2-70"></p>
<p><strong>思路</strong>：先手必胜，因为可以控制自己选基数堆还是偶数堆，这里我们尝试用动态规划来解决</p>
<p>A，<u>定义DP数组</u></p>
<p>dp[i][j].fir &#x3D; x 表示，对于 piles[i…j] 这部分⽯头堆，先⼿能获得的最⾼分数为 x。<br>       dp[i][j].sec &#x3D; y 表示，对于 piles[i…j] 这部分⽯头堆，后⼿能获得的最⾼分数为 y。  </p>
<p>举例理解⼀下，假设 piles &#x3D; [2, 8, 3, 5]，索引从 0 开始，那么：<br>        dp[0][1].fir &#x3D; 8 意味着：⾯对⽯头堆 [2, 8]，先⼿最多能够获得 8 分；dp[1][3].sec &#x3D; 5 意味着：⾯对⽯头堆 [8, 3, 5]，后⼿最多能够获得 5 分。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-71.png" alt="sf-2-71" style="zoom:50%;" />

<p>我们想求的答案是先⼿和后⼿最终分数之差，按照这个定义也就是 dp[0][n-1].fir - dp[0][n- 1].sec，即⾯对整个 piles，先⼿的最优得分和后⼿的最优得分之差。  </p>
<p>B,<u>明确初试值</u></p>
<p>就是对角线的值，dp[i][i].fir &#x3D; piles[i],  dp[i][i].sec&#x3D; 0。因为只有一堆的时候，当然是先手大</p>
<p>C，<u>状态转移</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，状态：状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的⼈。</span></span><br><span class="line">dp[i][j][fir or sec]</span><br><span class="line">其中：</span><br><span class="line"><span class="number">0</span> &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，选择：选择有两个：选择最左边的那堆⽯头，或者选择最右边的那堆⽯头</span></span><br><span class="line">n = piles.length</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">	<span class="keyword">for</span> j &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> who in &#123;fir, sec&#125;:</span><br><span class="line">			dp[i][j][who] = max(left, right)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，状态转移方程</span></span><br><span class="line">dp[i][j].fir = max(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j-<span class="number">1</span>].sec)</span><br><span class="line">dp[i][j].fir = max( 选择最左边的⽯头堆 , 选择最右边的⽯头堆 )</span><br><span class="line"># 解释：我作为先⼿，⾯对 piles[i...j] 时，有两种选择：</span><br><span class="line"># 要么我选择最左边的那⼀堆⽯头，然后⾯对 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿；</span><br><span class="line"># 要么我选择最右边的那⼀堆⽯头，然后⾯对 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿。</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">if</span> 先⼿选择左边:</span><br><span class="line">dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir</span><br><span class="line"><span class="keyword">if</span> 先⼿选择右边:</span><br><span class="line">dp[i][j].sec = dp[i][j-<span class="number">1</span>].fir</span><br><span class="line"># 解释：我作为后⼿，要等先⼿先选择，有两种情况：</span><br><span class="line"># 如果先⼿选择了最左边那堆，给我剩下了 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 此时轮到我，我变成了先⼿；</span><br><span class="line"># 如果先⼿选择了最右边那堆，给我剩下了 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 此时轮到我，我变成了先⼿。</span><br><span class="line"></span><br><span class="line"><span class="comment">//4，base case</span></span><br><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-72.png" alt="sf-2-72" style="zoom:67%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.length;</span><br><span class="line">        Pair[][] dp = <span class="keyword">new</span> Pair[n][n];</span><br><span class="line">        <span class="comment">//1,先进行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,设置base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">            dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历的顺序是根据上图来的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = piles[i] + dp[i + <span class="number">1</span>][j].sec;</span><br><span class="line">                <span class="keyword">int</span> right = piles[j] + dp[i][j - <span class="number">1</span>].sec;</span><br><span class="line">                <span class="comment">//4,fir先进行选择，选完之后sec的状态也随之修改</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i + <span class="number">1</span>][j].fir;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j - <span class="number">1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Pair res = dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res.fir - res.sec &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个类中存放了先手和后手的最大值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fir, sec;</span><br><span class="line">    Pair(<span class="keyword">int</span> fir, <span class="keyword">int</span> sec) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fir = fir;</span><br><span class="line">        <span class="keyword">this</span>.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）最小路径和"><a href="#（4）最小路径和" class="headerlink" title="（4）最小路径和"></a>（4）最小路径和</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-73.png" alt="sf-2-73" style="zoom:67%;" />

<p><strong>思路</strong>：</p>
<p>A，<u>定义dp函数</u>：dp(int[][] grid, int i, int j)表示从(0, 0)到(i, j)需要的最小路径值</p>
<p>B，<u>明确初始值</u>：起点本身到自己的值就是0</p>
<p>C，<u>状态转移</u>：由于只能向右或向下，grid[i][j]取决于dp(grid,  i - 1,j)和dp(grid, i , int j - 1)中的小的那个加上自己</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(grid, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">        memo[i][j] = Math.min(dp(grid, i - <span class="number">1</span>, j), dp(grid, i, j -<span class="number">1</span>)) + grid[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.length;</span><br><span class="line">	<span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">	<span class="comment">/**** base case ****/</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">	<span class="comment">/*******************/</span></span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）高楼扔鸡蛋"><a href="#（5）高楼扔鸡蛋" class="headerlink" title="（5）高楼扔鸡蛋"></a>（5）高楼扔鸡蛋</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-74.png" alt="sf-2-74"></p>
<p><strong>思路</strong>：状态就是当前拥有的鸡蛋数量和需要测试的楼层N，选择就是选择那层去扔鸡蛋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少实验的次数</span></span><br><span class="line">        <span class="comment">// 注意：</span></span><br><span class="line">        <span class="comment">// 1、i 表示的是楼层的大小，不是第几层的意思，例如楼层区间 [8, 9, 10] 的大小为 3，这一点是在状态转移的过程中调整的定义</span></span><br><span class="line">        <span class="comment">// 2、j 表示可以使用的鸡蛋的个数，它是约束条件，我个人习惯放在后面的维度，表示消除后效性的意思</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 个楼层和 0 个鸡蛋的情况都需要算上去，虽然没有实际的意义，但是作为递推的起点，被其它状态值所参考</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于求的是最小值，因此初始化的时候赋值为一个较大的数，9999 或者 i 都可以</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：填写下标为 0、1 的行和下标为 0、1 的列</span></span><br><span class="line">        <span class="comment">// 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="comment">// 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度（想想复杂度的定义）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 行，第 2 列开始填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1</span></span><br><span class="line">                    <span class="comment">// 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少</span></span><br><span class="line">                    <span class="comment">// 两种情况都做了一次尝试，所以加 1</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（6）魔塔"><a href="#（6）魔塔" class="headerlink" title="（6）魔塔"></a>（6）魔塔</h3><p>困难</p>
<h3 id="（7）辐射"><a href="#（7）辐射" class="headerlink" title="（7）辐射"></a>（7）辐射</h3><p>困难</p>
<h3 id="（8）加权最短路径"><a href="#（8）加权最短路径" class="headerlink" title="（8）加权最短路径"></a>（8）加权最短路径</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-75.png" alt="sf-2-75"></p>
<p><strong>思路</strong>：对于无权图，可以用BFS来获得最短路径；有权图，可以用Dijkstra来获取最短路径，这里用动态规划</p>
<p>A，<u>定义dp函数</u>：int dp(int s, int k)，这个函数指的是，从起点src出发，k步之内到节点s的最小花费</p>
<p>B，<u>明确base case</u>：如果s &#x3D;&#x3D; src，那么返回0；如果k &#x3D;&#x3D; 0，那么就无解啦，返回-1</p>
<p>C，<u>状态转移</u>：对于重点o，我只需要知道和它相连的节点和权重a（weight 1），b（weight 2）……，这样就可以算出到o的最小花费,，算法是min(dp(a, k - 1) + weight1,  dp(b, k - 1) + weight2)，这里注意需要是k - 1步，留一步到o</p>
<p>注：这样进行状态转移，我们就得知道指向某个节点的全部节点，以及权重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,用来存储到某个节点的入度</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; indegree;</span><br><span class="line">    <span class="keyword">int</span> src,dst;</span><br><span class="line">    <span class="keyword">int</span> memo[][];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        indegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.dst = dst;</span><br><span class="line">        <span class="comment">//k表示节点数，步数应该+1</span></span><br><span class="line">        k++;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">888</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] flight : flights)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = flight[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> from = flight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> cost = flight[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//保存某个节点的入度</span></span><br><span class="line">            indegree.putIfAbsent(to, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            indegree.get(to).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;from, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(dst, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(s == src) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[s][k] != -<span class="number">888</span>) <span class="keyword">return</span> memo[s][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(indegree.containsKey(s))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] v : indegree.get(s))&#123;</span><br><span class="line">                <span class="keyword">int</span> from = v[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> cost = v[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//看看相邻的节点的花费怎么样</span></span><br><span class="line">                <span class="keyword">int</span> subProblem = dp(from, k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(subProblem != -<span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.min(res, subProblem + cost);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">            memo[s][k] = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[s][k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[s][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七，其他经典算法"><a href="#七，其他经典算法" class="headerlink" title="七，其他经典算法"></a>七，其他经典算法</h1><h2 id="1，数学算法"><a href="#1，数学算法" class="headerlink" title="1，数学算法"></a>1，数学算法</h2><h3 id="（1）如何高效寻找素数"><a href="#（1）如何高效寻找素数" class="headerlink" title="（1）如何高效寻找素数"></a>（1）如何高效寻找素数</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-76.png" alt="sf-2-76" style="zoom: 80%;" />

<p><strong>思路</strong>：普通做法当然是遍历啦，判断范围内每个数到底是不是素数。再进阶一点就是对于每个数，判断2~sqrt（这个数）这个范围就行。但是还不够高效</p>
<p>A，<u>反着来</u>：从2开始，我们知道2是素数，那么2的倍数肯定不是素数；3是素数，3的倍数肯定不是素数。这个方法也叫筛选法。</p>
<p>那么对于一个范围内的数，可以先假设都是素数，然后把它们的倍数都设置为非素数，漏下来的就都是素数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1,这里只需要遍历到sqrt(n)就行了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//避免重复标记</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; n; j += i)&#123;</span><br><span class="line">                    isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）两道常考的阶乘算法题"><a href="#（2）两道常考的阶乘算法题" class="headerlink" title="（2）两道常考的阶乘算法题"></a>（2）两道常考的阶乘算法题</h3><p><strong>（力扣172——阶乘后的零）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-77.png" alt="sf-2-77"></p>
<p><strong>思路</strong>：第一种思路就是统计每个数中5的个数，但是要遍历一遍；第二种思路就是统计特殊值的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span>(temp % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp = temp / <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣793——阶乘后k个零）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-78.png" alt="sf-2-78" style="zoom: 80%;" />

<p><strong>思路</strong>：转换一下，就是求有多少个x 满⾜ trailingZeroes(x) &#x3D;&#x3D; k，那么我们可以求满⾜条件的 x 最⼩是多少，最⼤是多少，最⼤值和最⼩值⼀减就是满足的个数。</p>
<p>上面就是一个二分法的思路，下边界是0（也就是0个满足），上边界呢？题目中给出的限制是x &lt;&#x3D; 10^9,Integer.MAX_VALUE不够，我们用Long.MAX_VALUE</p>
<p>所以，最后的问题就是在区间 [0, LONG_MAX] 中寻找满⾜ trailingZeroes(n) &#x3D;&#x3D; K 的左侧边界和右侧边界  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没通过，后面复习了二分查找可以再看看</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (<span class="keyword">int</span>)(rightBound(k) - leftBound(k) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= Long.MAX_VALUE || trailingZeroes(lo) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt; <span class="number">0</span> || trailingZeroes(hi) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（3）如何在无限序列中随机抽取元素"><a href="#（3）如何在无限序列中随机抽取元素" class="headerlink" title="（3）如何在无限序列中随机抽取元素"></a>（3）如何在无限序列中随机抽取元素</h3><p>如果让你只能遍历对象（特备是链表这种）一遍，并且同等概率的取出其中的一个或者k个元素，应该怎么办？</p>
<p>先说一个元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的一个随机节点，核心是：当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//这里在遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//生成一个[0,i)之间的随机整数，这个整数等于0的概率就是1/i,从而判断是否更新这个值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-79.png" alt="sf-2-79"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的K个随机节点，核心是：当如果要随机选择 k 个数，只要在第 i 个元素处以 k/i 的概率选择该元素，以 1 - k/i 的概率保持原有选择即可（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前k个元素默认选上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; p != <span class="keyword">null</span>; j++)&#123;</span><br><span class="line">        res[j] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//第一次生成一个[0,i)之间的整数</span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i);</span><br><span class="line">        <span class="comment">//这个整数⼩于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k)&#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-80.png" alt="sf-2-80"></p>
<p><strong>（力扣382——链表随机节点）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-81.png" alt="sf-2-81" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random r;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r = <span class="keyword">new</span> Random();</span><br><span class="line">        ListNode p = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">                res = p.val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣398——随机数索引）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-82.png" alt="sf-2-82" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里的k要从0开始，不然从1开始会出错，我也不知道为啥出错</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(k))&#123;</span><br><span class="line">                    res = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣528——权重随机选择）</strong></p>
<h3 id="（4）吃葡萄"><a href="#（4）吃葡萄" class="headerlink" title="（4）吃葡萄"></a>（4）吃葡萄</h3><p><strong><a href="https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada">（牛客——吃葡萄）</a></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-83.png" alt="sf-2-83" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>吃的最多的人要吃的最少—&gt;也就是尽量要平分这些葡萄。假设没有吃的种类的限制，那么（总数&#x2F;3）向上去整就能得到想要的结果。（<u>注：如果你想计算 M 除以 N，M &#x2F; N 会向下取整，你想向上取整的话，可以改成 (M+(N-1)) &#x2F; N</u>  ）</p>
<p>但是因为有了条件限制，那么三种葡萄构成了三条边a,b,c，这三条边可以对应三角形的组成的两种情况：</p>
<p>第一种：a + b &gt; c，此时可以组成三角形（&#x3D;的情况虽然不是三角形，但也是平均分最合理），此时可以通过(a + b + c + 2) &#x2F; 3来获取平均分配后的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-84.png" alt="sf-2-84" style="zoom:67%;" />

<p>第二种：a + b &lt;&#x3D; c &amp;&amp; c &lt;&#x3D;  2*(a+b) </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-86.png" alt="sf-2-86"></p>
<p>第二种：c &gt; 2*(a+b)  ，此时不能是三角形，尽量要平分的话，就是一个人吃完a + b两种葡萄，剩下两人平分c</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-85.png" alt="sf-2-85" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        <span class="keyword">long</span>[][] purples = <span class="keyword">new</span> <span class="keyword">long</span>[k][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            purples[i][<span class="number">0</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">1</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">2</span>] = sc.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            System.out.println(solution(purples[i]));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span>[] nums)</span></span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">long</span> sum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] &gt;= nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + <span class="number">2</span>) / <span class="number">3</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*(nums[<span class="number">0</span>] + nums[<span class="number">1</span>]) &lt; nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">2</span>] + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）同时寻找缺失和重复的元素"><a href="#（5）同时寻找缺失和重复的元素" class="headerlink" title="（5）同时寻找缺失和重复的元素"></a>（5）同时寻找缺失和重复的元素</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-87.png" alt="sf-2-87" style="zoom: 80%;" />

<p><strong>思路</strong>：对于遍历的一个数值，我们将对应的下标元素变为负数，如果遍历到的数值对应下标的值已经是负数，那么这个值就是重复的，下标就是缺失的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1，遍历数组，将遍历到的值对应下标的值变为负数，表示这个索引有对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> dup = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lost = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，在循环中把数字对应下标的值标记为负数，此时若发现对应下标已经被标记过，则这个数重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[a - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                dup = a;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[a - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历数据，如果发现还有没有标记的数，则对应下标就是确实的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                lost = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dup, lost&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2，面试必知必会"><a href="#2，面试必知必会" class="headerlink" title="2，面试必知必会"></a>2，面试必知必会</h2><h3 id="（1）nSum问题"><a href="#（1）nSum问题" class="headerlink" title="（1）nSum问题"></a>（1）nSum问题</h3><p><strong>（两数之和）</strong></p>
<p><strong>引入</strong>：就是一个数组中的两个元素的和是不是等于特定值，可以用哈希表的方式来解决；或者将数组排序使用双指针</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-89.png" alt="sf-2-89" style="zoom:80%;" />

<p><strong>思路</strong>：我们排序后使用双指针，由于有重复,那么当指针当前指向的两个元素能够组成目标值时，两个指针应该跳过所有相同的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] toRes = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] temp : res)&#123;</span><br><span class="line">        toRes[i] = temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣15——三数之和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-90.png" alt="sf-2-90" style="zoom:80%;" />

<p><strong>思路</strong>：同样还是对数组进行排序，然后遍历数组，对于某个位置上的数x，假设它在结果中，那我们就需要找两个数，满足target - x，问题得以转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; towSum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            towSum = twoSumTarget(nums, i + <span class="number">1</span>, <span class="number">0</span> -(nums[i]));</span><br><span class="line">            <span class="keyword">if</span>(towSum.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt;  two : towSum)&#123;</span><br><span class="line">                    two.add(nums[i]);</span><br><span class="line">                    res.add(two);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(left);</span><br><span class="line">                list.add(right);</span><br><span class="line">                res.add(list);</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣18——四数之和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-91.png" alt="sf-2-91"></p>
<p><strong>思路</strong>：到这里应该直接写一个nsum的通用算法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nSumTarget(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1,输入数组，求几个数的和，开始坐标，以及目标值</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; nSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,这是一个base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，2个数其实也是一个base case算法</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lo = start, hi = sz - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">                <span class="keyword">int</span> left = nums[lo],right = nums[hi];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(left);</span><br><span class="line">                    list.add(right);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//这里递归计算n - 1个数的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; sz; i++)&#123;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; temp_res = nSumTarget(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">                <span class="comment">//如果temp_res不为空，这里能加入进去</span></span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; temp : temp_res)&#123;</span><br><span class="line">                    temp.add(nums[i]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）区间问题"><a href="#（2）区间问题" class="headerlink" title="（2）区间问题"></a>（2）区间问题</h3><p>（力扣1288——删除被覆盖的区间）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-92.png" alt="sf-2-92"></p>
<p><strong>思路</strong>：对于这些区间，我们先排序，按照起点升序排序，终点降序排序（这样能确保起点相同的区间，是长的那个在上面）；排序结束后，便可遍历，会有三种情况，对于每种情况进行不同的处理。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-93.png" alt="sf-2-93" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这里按照起点升序，起点相同时终点降序排列。</span></span><br><span class="line">        Arrays.sort(intervals, (a, b)-&gt;&#123;<span class="comment">//返回值大于0，就是a大，返回值小于0，就是b大。sort默认从小到大排序</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,设置第一个值为起点</span></span><br><span class="line">        <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，开始遍历判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="comment">//第一种情况，包含第二个区间</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= left &amp;&amp; intervals[i][<span class="number">1</span>] &lt;= right)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二种情况，两个区间部分相交，需要扩大右边界</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= right)&#123;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三种情况，完全不相交</span></span><br><span class="line">            <span class="keyword">if</span>(right &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（）还有两道题，后面再来写</p>
<h3 id="（3）快速选择算法"><a href="#（3）快速选择算法" class="headerlink" title="（3）快速选择算法"></a>（3）快速选择算法</h3><p><strong>（力扣215——数组中第K个最大的元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-94.png" alt="sf-2-94"></p>
<p><strong>思路</strong>：两种方法，一个是二叉堆，一个是快速选择算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1），使用二叉堆的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,使用优先级队列，这里默认是小根堆，如果是大根堆，还需要处理一下</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于每个元素，先加进去，如果此时pq大小超过k，则要去除堆顶元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，剩下的就是我们要的第k大的元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2），使用快速选择算法，它的时间复杂度更低，是快速排序的简化版（参考3）</span></span><br><span class="line"><span class="comment">//:我们要找第K大的元素，partition 函数会返回p，那么我们可以把 p 和 k 进⾏⽐较，如果 p &lt; k 说明第 k ⼤的元素在 nums[p+1..hi] 中，如果 p &gt; k 说明第 k ⼤的元素在 nums[lo..p-1] 中。</span></span><br><span class="line"><span class="comment">//:题⽬要求的是「第 k 个最⼤元素」，这个元素其实就是 nums 升序排序后「索引」为 len(nums) - k 的这个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="comment">//这个p就是一个数字最终的位置</span></span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(p &lt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[p + 1] ~ nums[hi]之间</span></span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p &gt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[lo] ~ nums[p - 1]之间</span></span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）快速排序回顾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo , <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点索引 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line">	<span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo == hi) <span class="keyword">return</span> lo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1，将lo位置的元素作为基准比较元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里j要+1，因为后面要先自减</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//找一个比pivot大的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[++i] &lt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找一个比pivot小的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[--j] &gt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果走到这里，说明这两个元素需要换位置，确保lo~i的范围比pivot小，lo~j的范围比pivot大</span></span><br><span class="line">        swap(nums, i, j); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将pivot放到中间那个划分的位置</span></span><br><span class="line">    swap(nums, j , lo);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）分治法"><a href="#（4）分治法" class="headerlink" title="（4）分治法"></a>（4）分治法</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-95.png" alt="sf-2-95" style="zoom:67%;" />

<p><strong>思路</strong>：对于一个复杂问题的，但是可以划分为子问题（分），最后右子问题获取到总的结果（治），我们可以尝试使用分治法，这是递归的一个思想，对于本题我们可以从下面的思路中进行思考：</p>
<p>A，对于一个expression，我们可以获得一个运算符，并把它分为运算符左边的字符串和右边的字符串。</p>
<p>B，分别计算左边和右边字符串的结果，可能会返回很多值（前两步就是分）</p>
<p>C，那么A中这个运算符的结果就是由B中返回的值组合而成（治）</p>
<p>D，需要考虑Base Case</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; rigth = diffWaysToCompute(expression.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b : rigth)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a + b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a - b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a * b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Integer.parseInt(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="（5）扫描线（安排会议室）"><a href="#（5）扫描线（安排会议室）" class="headerlink" title="（5）扫描线（安排会议室）"></a>（5）扫描线（安排会议室）</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-96.png" alt="sf-2-96" style="zoom: 67%;" />

<p><strong>思路</strong>：如下图，将会议区间投影到时间线上，用一个蓝色的线去进行扫描，如果遇到红色的点，则计数+1，遇到蓝色的点，则计数-1，进而count的最大值就是我们要的到的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-97.png" alt="sf-2-97" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetignRooms</span><span class="params">(<span class="keyword">int</span>[][] meetings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = meetings.length;</span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//1,这里用start来保存起点，end来保存重点，并排序，模拟出上图中的点的排序情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        start[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(start);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里我们开始模拟扫描，过程中我们去记录当前重叠的会议，并将最大的情况赋给res</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i] &lt; end[j])&#123;</span><br><span class="line">            <span class="comment">//同一时间又有一个会议，所以count++</span></span><br><span class="line">            conut++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//同一时间有个会议结束了，count--</span></span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）贪心算法1"><a href="#（6）贪心算法1" class="headerlink" title="（6）贪心算法1"></a>（6）贪心算法1</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-98.png" alt="sf-2-98" style="zoom: 67%;" />

<p><strong>思路</strong>：两种算法，第一种是根据数据分析的做法（数学做法）；第二种是贪心思想</p>
<p>第一种：数据分析</p>
<p>这里有两个数组，我们可以将其归并为一个数组（油箱结余），然后画出变化图，我们发现，要找的起点是最低点（当然如果从最低点开始油箱中都会出现负数，那就是不行）</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-99.png" alt="sf-2-99" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,min记录此时的邮箱结余最小值，start记录起点，sum记录油量和花费的总差值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2，遍历数组，更新上面的这些值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; min)&#123;</span><br><span class="line">                min = sum;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,注意这里是环形数组</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start == gas.length ? <span class="number">0</span> : start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：如果从i到j恰好出现了油箱中的油为负数的情况，那么i ~ j中间的节点k都不会是起点。因为此时i ~ j-1油箱中的油肯定都是正数，j-1 ~ j的消耗太大。所以如果在遍历的过程中，sum值变为负数，那么就将起点设置为j</p>
<p>贪心的关键在于，如果找不到重复计算，那就通过问题中⼀些隐藏较深的规律，来减少冗余计算  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, n = gas.length;</span><br><span class="line">        <span class="comment">//1,先把不好弄的情况给排除了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2,开始贪心，注意这里start取新的起点应该是i + 1</span></span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>,start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start == n ? <span class="number">0</span> : start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）贪心算法2"><a href="#（7）贪心算法2" class="headerlink" title="（7）贪心算法2"></a>（7）贪心算法2</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-100.png" alt="sf-2-100"></p>
<p><strong>思路</strong>：这里和之前的区间问题类似，先将区间排序，然后采用下面的策略</p>
<p> 1、要⽤若⼲短视频凑出完成视频 [0, T]，⾄少得有⼀个短视频的起点是 0。<br>        2、如果有⼏个短视频的起点都相同，那么⼀定应该选择那个最⻓（终点最⼤）的视频。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(clips,(a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clips[<span class="number">0</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, curEnd = <span class="number">0</span>, nextEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">                nextEnd = Math.max(nextEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">            <span class="keyword">if</span>(curEnd &gt;= time)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>（8）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
</search>
