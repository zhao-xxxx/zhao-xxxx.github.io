<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js-mysql-1</title>
    <url>/2022/02/05/js-2-mysql/</url>
    <content><![CDATA[<p><strong>简介：</strong>MySQL的简介和安装</p>
<span id="more"></span>

<h1 id="一，MySQL介绍"><a href="#一，MySQL介绍" class="headerlink" title="一，MySQL介绍"></a>一，MySQL介绍</h1><p>​     MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>，由瑞典MySQL AB 公司开发，目前属于 <a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>之一，在 WEB 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<p>   MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>​    MySQL的优点有：1）成本低：开放源代码，一般可免费使用；2）性能高：执行很快；3）简单：容易安装和使用                                                                                                                                                                                                 </p>
<h1 id="二，Mysql安装（win系统，5-7版本）"><a href="#二，Mysql安装（win系统，5-7版本）" class="headerlink" title="二，Mysql安装（win系统，5.7版本）"></a>二，Mysql安装（win系统，5.7版本）</h1><p><strong>下载地址：</strong></p>
<p>官网下载(不推荐使用)：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br> 清华镜像站下载(推荐)：<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7">https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7</a></p>
<h2 id="1，软件安装版"><a href="#1，软件安装版" class="headerlink" title="1，软件安装版"></a>1，软件安装版</h2><p>软件安装版也就是后缀为.msi的安装包，进行有界面操作的安装，在安装的过程中对相关的属性进行设置，可参考这篇博客：<a href="https://blog.csdn.net/weixin_43790276/article/details/102090540">https://blog.csdn.net/weixin_43790276/article/details/102090540</a></p>
<h2 id="2，安装包解压版"><a href="#2，安装包解压版" class="headerlink" title="2，安装包解压版"></a>2，安装包解压版</h2><p>使用.zip后缀的安装包进行安装时，需要结合命令行和配置文件进行配置，适合有一定基础的使用，可参考博客：<a href="https://www.jianshu.com/p/ea4accd7afb4%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%EF%BC%9A">https://www.jianshu.com/p/ea4accd7afb4以及博客：</a></p>
<p><strong>总结：</strong>上面两种方式各有优点和缺点，选择适合自己的方法进行安装即可。我选择的是.mis安装方式，Windows中的服务名忘了设置，是默认的MySQL57，端口也是3306，用户名和密码都是root（自己学习用就设置简单一点，否则忘了就很麻烦）。最后MySQL的卸载比较麻烦，一定要从软件，安装路径，注册表这三个方面卸载干净。</p>
<h1 id="三，（补充）关系型数据库"><a href="#三，（补充）关系型数据库" class="headerlink" title="三，（补充）关系型数据库"></a>三，（补充）关系型数据库</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作"><a href="#三，MySQL操作" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="三，MySQL操作-1"><a href="#三，MySQL操作-1" class="headerlink" title="三，MySQL操作"></a>三，MySQL操作</h1><h2 id="1，这是二级标题-2"><a href="#1，这是二级标题-2" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-4"><a href="#（1），这是三级标题-4" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-2"><a href="#2，这是二级标题-2" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-5"><a href="#（1），这是三级标题-5" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong算法秘籍阅读笔记</title>
    <url>/2022/02/07/sf-1-labuladong/</url>
    <content><![CDATA[<p><strong>简介：</strong>该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。</p>
<span id="more"></span>

<h1 id="一，刷题思维"><a href="#一，刷题思维" class="headerlink" title="一，刷题思维"></a>一，刷题思维</h1><h2 id="1，数据结构的存储方式"><a href="#1，数据结构的存储方式" class="headerlink" title="1，数据结构的存储方式"></a>1，数据结构的存储方式</h2><h3 id="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）"><a href="#（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）" class="headerlink" title="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）"></a>（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</h3><p>散列表、栈、队列、堆、树、图等等各种数据结构 ，都是基于数组和链表的</p>
<h3 id="（2）数组和链表的优缺点"><a href="#（2）数组和链表的优缺点" class="headerlink" title="（2）数组和链表的优缺点"></a>（2）数组和链表的优缺点</h3><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。<u>但正因为连</u><br><u>续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全</u><br><u>部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以</u><br><u>保持连续，时间复杂度 O(N)。</u>  </p>
<p><strong>链表</strong>因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素<br>的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。<u>但是正因为存储空间不连续，<br>你⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位<br>置的指针，会消耗相对更多的储存空间</u></p>
<h2 id="2，数据结构的基本操作"><a href="#2，数据结构的基本操作" class="headerlink" title="2，数据结构的基本操作"></a>2，数据结构的基本操作</h2><h3 id="（1）数据结构的终极目的"><a href="#（1）数据结构的终极目的" class="headerlink" title="（1）数据结构的终极目的"></a>（1）数据结构的终极目的</h3><p>在不同的应⽤场景，尽可能⾼效地增删查改。  </p>
<h3 id="（2）操作的类型"><a href="#（2）操作的类型" class="headerlink" title="（2）操作的类型"></a>（2）操作的类型</h3><p>如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。<br>线性就是 for&#x2F;while 迭代为代表，⾮线性就是递归为代表。再具体⼀步，⽆⾮以下⼏种框架  ：</p>
<p>A，数组遍历框架（典型的线性迭代结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        <span class="comment">//访问并操作arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，链表遍历框架，兼具迭代和递归结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != <span class="keyword">null</span>;p = p.next)&#123;</span><br><span class="line">        <span class="comment">//访问并操作p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，二叉树遍历框架，典型的非线性递归遍历结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D,二叉树框架扩展为N叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E，N叉树遍历扩展为图的遍历</p>
<p>与N叉树类似，但是要避免出现环型的遍历，所以要添加一个布尔类型的Visited来标记是否遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArcNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Boolean visited;<span class="comment">//这里图中的每个节点的visited初始值为false</span></span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历有好几种，深度优先，广度优先，以及非递归，这里类似于N叉树，写深度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ArcNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.visited == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//访问并操作root.val</span></span><br><span class="line">     	root.visited = <span class="keyword">true</span>;</span><br><span class="line">   	 	<span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        	traverse(child);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-算法刷题指南"><a href="#3-算法刷题指南" class="headerlink" title="3,算法刷题指南"></a>3,算法刷题指南</h2><p>首先，<strong>数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法</strong>  ，所以在刷算法之前，应该了解常用的数据结构以及它们的基本操作和优缺点（散列表、栈、队列、堆、树、图等等）</p>
<p>然后，<strong>先刷⼆叉树，</strong>因为二叉树是最容易帮助人建立起框架思维的，对于一道二叉树相关的题，可以分为几个阶段：1，认识出这是一个能通过二叉树解决的问题；2，能写出答题的总体步骤（前序，中序，还是后序？），之中的一些细节就算写错，也不会错到哪儿去；3，扩展到解决其他问题（动态规划，回溯算法等等）</p>
<p><strong>注：</strong>这里我的理解是，二叉树作为一个在整个算法系统中的中间位置，能够很高的起到锻炼的作用，熟悉了二叉树后，简单的题目中的思路可以从二叉树中提取，复杂的题目可以从二叉树中扩展。</p>
<h1 id="二，计算机算法的本质"><a href="#二，计算机算法的本质" class="headerlink" title="二，计算机算法的本质"></a>二，计算机算法的本质</h1><h2 id="1，核心"><a href="#1，核心" class="headerlink" title="1，核心"></a>1，核心</h2><p>算法的本质就是穷举。(当然，某些问题可以通过总结规律解决，某些问题可以通过数学算法解决，但是绝大多数问题都是穷举)</p>
<p>但是此处的穷举并不是指暴力破解那样的寻找，因为一个问题的答案往往有很多条路，所以“穷举”思维，是包含两个层次的含义，如何穷举<strong>和</strong>如何聪明的穷举**，每道题的难点是不一样的</p>
<h3 id="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"><a href="#（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。" class="headerlink" title="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"></a>（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</h3><blockquote>
<p>（P19）前⽂ 动态规划核⼼套路 阐述了动态规划系列问题的核⼼原理，⽆⾮就是先写出暴⼒穷举解法（状态转移⽅程），加个备忘录就成⾃顶向下的动态规划解法了，再改⼀改就成⾃底向上的迭代解法了，动态规划的降维打击 ⾥也讲过如何分析优化动态规划算法的空间复杂度  </p>
<p>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧⼀听就会<br>了。但很多读者留⾔说明⽩了这些原理，遇到动态规划题⽬还是不会做，因为第⼀步的暴⼒解法都写不出<br>来。</p>
<p>这很正常，因为动态规划类型的题⽬可以千奇百怪，找状态转移⽅程才是难点，所以才有了 动态规划设计⽅<br>法：最⻓递增⼦序列 这篇⽂章，告诉你递归穷举的核⼼是数学归纳法，明确函数的定义，然后利⽤这个定义<br>写递归函数，就可以穷举出所有可⾏解。  </p>
</blockquote>
<h3 id="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"><a href="#（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。" class="headerlink" title="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"></a>（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</h3><blockquote>
<p>（p19）⽐如前⽂ Union Find 并查集算法详解 告诉你⼀种⾼效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我⽤ DFS&#x2F;BFS 暴⼒搜索（穷举）肯定可以做到，但⼈家 Union Find 算法硬是⽤数组模拟树结构，给你把连通性相关的操作复杂度给⼲到 O(1) 了。这就属于聪明地穷举，你学过就会⽤，没学过恐怕很难想出这种思路。</p>
<p>再⽐如贪⼼算法技巧，前⽂ 当⽼司机学会贪⼼算法 就告诉你，所谓贪⼼算法就是在题⽬中发现⼀些规律（专业点叫贪⼼选择性质），使得你不⽤完整穷举所有解就可以得出答案。</p>
<p>⼈家动态规划好⽍是⽆冗余地穷举所有解，然后找⼀个最值，你贪⼼算法可好，都不⽤穷举所有解就可以找<br>到答案，所以前⽂ 贪⼼算法解决跳跃游戏 中贪⼼算法的效率⽐动态规划还⾼。</p>
<p>再⽐如⼤名鼎鼎的 KMP 算法，你写个字符串暴⼒匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复⽤⼀些信息，减少了冗余计算，前⽂ KMP 字符匹配算法 就是使⽤状态机的思路实现<br>的 KMP 算法。  </p>
</blockquote>
<h1 id="三，基础数据结构"><a href="#三，基础数据结构" class="headerlink" title="三，基础数据结构"></a>三，基础数据结构</h1><h2 id="1，数组-x2F-链表"><a href="#1，数组-x2F-链表" class="headerlink" title="1，数组&#x2F;链表"></a>1，数组&#x2F;链表</h2><h3 id="（1）前缀和数组"><a href="#（1）前缀和数组" class="headerlink" title="（1）前缀和数组"></a>（1）前缀和数组</h3><p>前缀和，指的是在在计算中，如果要频繁的读取一段区间内的值，那么设定一个基准点，将该基准点以及到各个索引之间的值先计算出来并记录，这样再进行新区间值的计算的时候，能够避免重复计算。</p>
<p><u><strong>力扣303题——区域和检索-数组不可变</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png" alt="sf-1-1"></p>
<p>如果是不考虑时间复杂度，那么每次计算两个索引范围之间的和，都会进行一次数组的遍历，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.nums = nums;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		res += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目要求降低时间复杂度，那么我们要尽量避免同样的操作，前缀和数组就能帮助我们解决这样的问题，主要思路是，建立一个新的数组preSum，然后对于原来的数组nums，以0位基准，将不同范围的nums数组和存储在preSum中，也就是preSum[1]-&gt;sum[0]，preSum[4]-&gt;sum[0] + sum[1]+sum[2] + preSum[3]，那么求索引1~3之间的和，即可用preSum[3+1] - preSum[1]即可。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前缀和数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">	<span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">			preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣304题——二维区域和检索-矩阵不可变</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png" alt="sf-1-2"></p>
<p>此题和上一题类似，还是需要先计算矩阵的前缀和，只是此处的前缀和和上题不同，那么在这里我们需要什么样的前缀和呢？基准点是哪个呢?我们先看一下下面的计算过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png" alt="sf-1-3"></p>
<p>​    要计算红框里的数组和（坐标：2,1,4,3），它的值就等于黄框（0,0,4,3）减去粉框（0,0,1,3）减去绿框（0,0,4,0）最后加上紫框（0,0,1,0），这样我们就将基准点设置好了，同时我们也知道，需要计算的前缀和为坐标为（0,0,x,y）的框的和（x，y为不同的坐标点），利用这些坐标和，就可以算出所有的小框里的数字和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] preSum;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">			preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i- <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ⽬标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">		<span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] +preSum[x1][y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣560——和为k的子数组</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png" alt="sf-1-4"></p>
<p>这道题基础的做法是采用穷举所有子数组的做法，并检查他们是否和为K。但是这种做法太简单了，我们可以尝试用前缀和，有了前缀和在穷举子数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// 构造前缀和</span></span><br><span class="line">	<span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 穷举所有⼦数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)	</span><br><span class="line">			<span class="comment">// ⼦数组 nums[j..i-1] 的元素和</span></span><br><span class="line">			<span class="keyword">if</span> (preSum[i] - preSum[j] == k)</span><br><span class="line">				res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这里的时间复杂度还是o(N^2)，空间复杂度是o(N)（空间复杂度都挺高了时间复杂度没降下来说不过去），那么我们需要进行进一步的改良，一个思路是，我们能不能在计算前缀和的同时，判断该前缀和是否存在一个对应的相差为K的前缀和，如果有则统计次数加1，如果没有则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class="line">	HashMap&lt;Integer, Integer&gt;</span><br><span class="line">		preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// base case	</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum0_i += nums[i];</span><br><span class="line">		<span class="comment">// 这是我们想找的前缀和 nums[0..j]</span></span><br><span class="line">		<span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">		<span class="comment">// 如果前⾯有这个前缀和，则直接更新答案</span></span><br><span class="line">		<span class="keyword">if</span> (preSum.containsKey(sum0_j))</span><br><span class="line">			res += preSum.get(sum0_j);</span><br><span class="line">		<span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数</span></span><br><span class="line">		preSum.put(sum0_i,</span><br><span class="line">			preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）差分数组"><a href="#（2）差分数组" class="headerlink" title="（2）差分数组"></a>（2）差分数组</h3><p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和 。本节与前缀和数组类似，讲的是差分数组，指的是频繁对原始数组的某个区间的元素进⾏增减，最后的数组内容发生了改变。</p>
<p>**<u>引例</u>**：⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给…  最后的数组是什么样的呢？一般情况下，我们不断的循环遍历修改数组就行，但这样每次的时间复杂度都是O(n)，效率不高</p>
<p>所以我们需要使用<strong>差分数组</strong>，差分数组指的是构造一个新的数组diff[]，diff[i] &#x3D; nums[i] - nums[i - 1]（如图）,并且根据差分数组可以反推出原数组（设一个数组res[]，res[0] &#x3D; diff[0]，这样的话原数组res[i] &#x3D; res[i - 1] + diff[i]，其中i &gt;&#x3D; 1），</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png" alt="sf-1-5"></p>
<p>差分数组在频繁的修改某个区间的值中能够降低复杂度，比如要将区间 i ~ j 中的所有数都加3，那么可以将差分数组diff[i] +&#x3D; 3，diff[j] -&#x3D; 3，这样恢复为原数组的时候就可以实现这样的效果。原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -&#x3D; 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 。</p>
<p>差分数组的这些初始化操作，变化操作，以及恢复操作可以抽象为一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;<span class="comment">//assert对一个boolean表达式进行检查，一个正确运行的程序保证boolean值为true，若为false，则说明程序不正确，系统需要提供警告信息并且退出程序。</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] -nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处val可以是负数，另外如果j大于diff.length的话，就表明i之后的数组都要增加val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    	diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">        	diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣370——区间加法</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png" alt="sf-1-6"></p>
<p>这道题使用引例中实现的类即可。代码如下（省略了类的定义）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length,<span class="keyword">int</span>[][] updates)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    Difference difference = <span class="keyword">new</span> Difference(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] update : updates)&#123;</span><br><span class="line">        difference.increment(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1109——航班预订统计</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png" alt="sf-1-7"></p>
<p>本体也就是差分数组的变体，写法与上题大致相同，但是这里注意，航班的编号是1 ~ n！，对应数组中的0 ~ n-1!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Different different = <span class="keyword">new</span> Different(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] booking : bookings)&#123;</span><br><span class="line">        different.increment(booking[<span class="number">0</span>] - <span class="number">1</span>,booking[<span class="number">1</span>] - <span class="number">1</span>,booking[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> different.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1094——拼车</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png" alt="sf-1-8"></p>
<p>本题同样是差分数组的扩展，对于这种明显的问题，我们需要明确的是我们在模板中的nums[]，[i，j，val]数组，以及res[]数组的含义。在本题中，明显能发现trip[a,b,c]这个三维数组对应的是变化的标记，那么nums[]数组就是每站车上的人数（初始为0），最后的res[]就是车开了一遍后每站都有多少人。<u>我们判断能否一次性把顾客运送完，就先假设容量无限大，计算出res[],最后遍历res[]看途中是否有不符合条件的情况即可。</u>本题中没有直接说有多少车站，但是说明了车站的范围在0~1000之间，那么可设nums[1001]（初试值为0），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    Difference df = <span class="keyword">new</span> Difference(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] trip : trips)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = trip[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里注意，j站的时候已经下车啦</span></span><br><span class="line">        <span class="keyword">int</span> j = trip[<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = df.result();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h3><p><strong>引入：</strong>指的是一类问题，通过维护⼀个窗⼝，不断滑动，然后更新答案  。该算法时间复杂度为O（N），比字符串暴利算法高效很多。但是该思路存在很多细节问题：⽐如说如何向窗⼝中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果 …除此之外，出现了Bug调试也很困难。</p>
<p>所以根据labuladong笔记，其中总结了一个框架（包含了debug的输出提示），遇到相关类型，默写该框架，修改三个地方即可解决大部分滑动窗口题。(后面会有几道力扣的题进行使用展示)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need ,window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">//右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">        <span class="comment">//下面更新窗口数据</span></span><br><span class="line">        ...update...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面是debug输出的位置    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>,left,right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">           <span class="comment">//d 是将移出窗口的字符</span></span><br><span class="line">           <span class="keyword">char</span> d = s[left];</span><br><span class="line">           <span class="comment">//左移窗口</span></span><br><span class="line">           left++;</span><br><span class="line">           <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">           ...update...</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>滑动窗⼝很多时候都是在处理字符串相关的问题，Java 处理字符串不⽅便，所以本⽂代码为 C++ 实<br>现。不会⽤到什么编程⽅⾯的奇技淫巧，但是还是简单介绍⼀下⼀些⽤到的数据结构，以免有的读者因为语<br>⾔的细节问题阻碍对算法思想的理解：  </p>
<p>unordered_map 就是哈希表（字典），它的⼀个⽅法 count(key) 相当于 Java 的 containsKey(key)<br>可以判断键 key 是否存在。<br>        可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个<br>key，并把 map[key] 赋值为 0。<br>        所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) +1)。  </p>
<p><strong><u>力扣76——最小覆盖子串</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png" alt="sf-1-9"></p>
<p>这道题我们将代码先贴在下面，然后结合图片观察滑动窗口实现的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,先更新start和len的值，然后左移窗口，取left处的字符d，然后自增1。更新操作：判断need中是否有字符d，存在的话（如果window中的d的次数和need中的一样，则valid自减1，）则window中的d的出现次数自减1。若字符d导致了valid自减1，start记录的位置是将其包含在内的。</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若跳出了上面的循环，则取s的子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，本题中的代码的运行流程应该是下面这样，读者可以自己手动过一遍，加强印象</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png" alt="sf-1-10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png" alt="sf-1-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png" alt="sf-1-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png" alt="sf-1-13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png" alt="sf-1-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png" alt="sf-1-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png" alt="sf-1-16"></p>
<blockquote>
<p>使⽤ Java 的读者要尤其警惕语⾔特性的陷阱。Java 的 Integer，String 等类型判定相等应该⽤<br>equals ⽅法⽽不能直接⽤等号 &#x3D;&#x3D;，这是 Java包装类的⼀个隐晦细节。所以在左移窗⼝更新数据的时<br>候，不能直接改写为 window.get(d) &#x3D;&#x3D; need.get(d)，⽽要⽤window.get(d).equals(need.get(d))，之后的题⽬代码同理。  </p>
</blockquote>
<p><strong><u>力扣567——字符串排列</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png" alt="sf-1-17"></p>
<p>说明：本题第目的就是给你⼀个 s1 和⼀个 s2，请问你 s2中是否存在⼀个⼦串，包含 s1 中所有字符且不包含其他字符？  这里注意，s1中可以包含相同的字符串。</p>
<p>这道题应用在框架中要注意几点：1）窗口在往右扩大时，是一样的，将对应的字母都要包含的窗口中。2）收缩窗口时便有所不同，首先窗口的关闭条件应该是，while（right - left &gt;&#x3D; t.size()），这样才能保证及时缩小窗口。3）在缩小的过程中，一旦valid &#x3D;&#x3D; need.size()  ，便表明找到了最后的答案。    具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,这里窗口收缩的条件不同，right和left限制了一个与目标字符串相同大小的窗口，并且本题不需要记录该字符串的位置，所以也不需要start和len</span></span><br><span class="line">        <span class="comment">// while(valid == need.size())</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">		   <span class="comment">//这里注意，valid值如果与need的值相同，则表明当前窗口下的size个字符都是我们需要的字符</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的循环没有返回true，那就一定是false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣438——找到字符串中所有字母异位词</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-24.png" alt="js-1-24"></p>
<p>说明：本题扩大窗口没有特殊的地方，收缩窗口时注意记录子串的起始索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣3——最长不重复子串</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-25.png" alt="js-1-25"></p>
<p>说明：本题没有固定的字符串对应，所以不需要need数组，也不需要valid来记录情况，但是需要window数组来记录窗口中字符的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">char</span> d = s[left];</span><br><span class="line">             left++;</span><br><span class="line">			window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）二分搜索框架"><a href="#（4）二分搜索框架" class="headerlink" title="（4）二分搜索框架"></a>（4）二分搜索框架</h3><p><strong>引入</strong>：⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。⽽且，我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的⼆分查找算法  。下面是二分查找的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">     	<span class="keyword">int</span> mid = left + (right - left)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚，读者理解后可⾃⾏简化。<br>    其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样的变化。<br>    另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) &#x2F; 2 就和 (left +right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。  </p>
<p>接下来说明几个二分搜索的应用场景：</p>
<p><strong><u>寻找一个数（基本的二分搜索）</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left =  mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该算法有几个注意的地方：    1）while判断条件是（left &lt;&#x3D; right），而不是（left &lt; right），我们使用的闭区间搜索（因为right赋值为nums.length - 1)，若此时left和right都是2的话，while(left &lt; right)这个判断语句就会错过2这个下标所代表的位置；      2）当判断过mid位置的数字后，left和right的更新就对应的+1和-1；      3）该算法无法处理有多个结果的情况，比如在数组nums &#x3D; [1,2,2,2,3]中搜索数字2，只能得到索引2，无法得到左侧的索引1和右侧的索引2.</p>
<p><strong><u>寻找左侧边界的二分搜索</u></strong></p>
<p>下面的算法是左右都是闭区间检查，那么rigth的初试值就是nums.length - 1，while的终止条件就是left &#x3D; right + 1。这里要注意，循环的退出条件既然变成了left &#x3D; right + 1，那么如果一个数组中的左右元素都比target小，left就会比right大，所以最后那里需要进行判读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_boud</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.lenght - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>寻找右侧边界的二分查找</u></strong></p>
<p>下面是两边闭区间的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; taeget)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是左侧还是右侧边界的搜索，其实可以抽象为一定范围内的找极值的行为，比如对于nums &#x3D; [1,2,3,3,3,5,7]，想搜索target &#x3D; 3，搜索左侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png" alt="sf-1-18"></p>
<p>搜索右侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png" alt="sf-1-19"></p>
<p>是不是有一种做函数题的感觉</p>
<h3 id="（5）二分搜索题型"><a href="#（5）二分搜索题型" class="headerlink" title="（5）二分搜索题型"></a>（5）二分搜索题型</h3><p>⽂总结的⼆分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够⽤到⼆分搜索 。所以接下来需要一套二分搜索算法应用的套路（思路）</p>
<p><strong>首先</strong>，什么样的题可以使用二分搜索的技巧呢？一般是符合以下条件的题：</p>
<p>可以从题目中抽象出一个自变量x，关于x的函数f(x)，以及一个目标值target，同时x，f(x)，target需要满足以下条件</p>
<p>1，f(x)必须是在x上的单调函数（单增单减都可以）</p>
<p>2，题目要求计算f(x) &#x3D;&#x3D; target时的x的值</p>
<p>对于上一节的例子（就是nums &#x3D; [1,2,3,3,3,5,7]，搜索左侧target &#x3D; 3），可以抽象为下面这样的形式（虽然没必要）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid, nums) == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || f(left, nums) != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，对于一个需要二分搜索解决的问题，我们的思考点应该是几个方面，具体见下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1,根据题意确定x的最小值是多少</span></span><br><span class="line">    <span class="keyword">int</span> left = ...;</span><br><span class="line">    <span class="comment">//2,根据题意确定x的最小值是多少（这个是闭区间写法）</span></span><br><span class="line">    <span class="keyword">int</span> right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= rigth)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//3,怎么让f(x)大一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//4,怎么让f(x)小一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//5,题目求的左边界还是右边界（注意是闭区间写法）</span></span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6,闭区间需要判断是都超出范围</span></span><br><span class="line">    <span class="keyword">if</span> ...;</span><br><span class="line">    <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，想用二分搜索来解决问题的话，主要有以下几步：</p>
<ul>
<li>确定 x, f(x), target 分别是什么，并写出函数 f 的代码  </li>
<li>找到 x 的取值范围作为⼆分搜索的搜索区间，初始化 left 和 right 变量。  </li>
<li>根据题⽬的要求，确定应该使⽤搜索左侧还是搜索右侧的⼆分搜索算法，写出解法代码</li>
</ul>
<p><strong>力扣875——爱吃香蕉的珂珂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</span><br><span class="line"></span><br><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        Tool tool  = <span class="keyword">new</span> Tool();</span><br><span class="line">        <span class="keyword">int</span>[] res = tool.getMaxandMin(piles);</span><br><span class="line">        <span class="keyword">int</span> min = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = res[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getTime(piles,mid) &lt; h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) == h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] getMaxandMin(<span class="keyword">int</span>[] piles)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &gt; max)&#123;</span><br><span class="line">                max = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &lt; min)&#123;</span><br><span class="line">                min = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = min;</span><br><span class="line">        res[<span class="number">1</span>] = max;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            res += (pile % speed == <span class="number">0</span>) ? (pile / speed) : (pile / speed + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











































































































]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-springmvc</title>
    <url>/2022/02/06/js-3-springmvc/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-4"><a href="#（1），这是三级标题-4" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h3 id="（1），这是三级标题-5"><a href="#（1），这是三级标题-5" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring知识点</title>
    <url>/2022/02/06/js-1-spring/</url>
    <content><![CDATA[<p><strong>简介：</strong>Spring是目前java后端开发最核心，最基础的框架之一。网络上已经有很多资源，本文的主要目标为总结和整理学习中遇到的知识点，集百家之长和自己的实践，去粗取精。参考的资料有：，<a href="http://c.biancheng.net/spring/spring-abc.html">C语言中文网Spring教程</a>，<a href="http://www.voidme.com/spring">小白教程</a>，<a href="https://github.com/Snailclimb/JavaGuide">Java Guide</a></p>
<span id="more"></span>

<h1 id="一，认识Spring"><a href="#一，认识Spring" class="headerlink" title="一，认识Spring"></a>一，认识Spring</h1><h2 id="1，Spring是什么"><a href="#1，Spring是什么" class="headerlink" title="1，Spring是什么"></a>1，Spring是什么</h2><h3 id="（1），诞生于发展"><a href="#（1），诞生于发展" class="headerlink" title="（1），诞生于发展"></a>（1），诞生于发展</h3><p>早期的 J2EE（Java EE 平台）推崇以 EJB 为核心的开发方式，但这种开发方式在实际的开发过程中存在种种弊端，例如使用复杂、代码臃肿、代码侵入性强、开发周期长、移植难度大等。</p>
<p>Rod Johnson 在其 2002 年编著的畅销书《Expert One-on-One J2EE Design and Development》中，针对 EJB 各种臃肿的结构进行了逐一的分析和否定，并分别以更加简洁的方式进行了替换。这本书影响甚远，后来 Rod Johnson 将代码开源，并把这个新框架并命名为“Spring”，含义为：Spring 像一缕春风一样，扫平传统 J2EE 的寒冬。</p>
<p>2003 年 2 月，Spring 0.9 版本发布，；2004 年 4 月，Spring 1.0 版本正式发布。到目前为止，Spring 已经步入到了第 5 个大版本，也就是我们常说的 Spring 5。</p>
<h3 id="（2），Spring的含义"><a href="#（2），Spring的含义" class="headerlink" title="（2），Spring的含义"></a>（2），Spring的含义</h3><p><strong>广义：</strong>指代Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义：</strong>特指 Spring Framework，通常我们将它称为 Spring 框架。Spring 有两个核心部分： IOC 和 AOP。</p>
<table>
<thead>
<tr>
<th>核心</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>IOC</td>
<td align="center">Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。</td>
</tr>
<tr>
<td>AOP</td>
<td align="center">Aspect Oriented Programming 的简写，译为“面向切面编程”。                                                                           AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。</td>
</tr>
</tbody></table>
<h3 id="（3），特点"><a href="#（3），特点" class="headerlink" title="（3），特点"></a>（3），特点</h3><ul>
<li>方便解耦，简化开发</li>
<li>方便集成各种优秀框架</li>
<li>降低 Java EE API 的使用难度</li>
<li>方便程序的测试</li>
<li>AOP 编程的支持</li>
<li>声明式事务的支持</li>
</ul>
<h2 id="2，Spring体系结构"><a href="#2，Spring体系结构" class="headerlink" title="2，Spring体系结构"></a>2，Spring体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-1.png" alt="js-1-1"></p>
<p>  从上图可以看出，Spring架构中有5个模块，在我们后面的学习中，经常导入的一些包属于哪个模块，要有了解。</p>
<h3 id="（1），Data-Access-x2F-Integration（数据访问／集成）"><a href="#（1），Data-Access-x2F-Integration（数据访问／集成）" class="headerlink" title="（1），Data Access&#x2F;Integration（数据访问／集成）"></a>（1），Data Access&#x2F;Integration（数据访问／集成）</h3><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，这里暂时不深入</p>
<h3 id="（2），Web-模块"><a href="#（2），Web-模块" class="headerlink" title="（2），Web 模块"></a>（2），Web 模块</h3><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件</p>
<h3 id="（3），Core-Container（Spring-的核心容器）"><a href="#（3），Core-Container（Spring-的核心容器）" class="headerlink" title="（3），Core Container（Spring 的核心容器）"></a>（3），Core Container（Spring 的核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。</p>
<ul>
<li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li>
<li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li>
<li>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<h3 id="（4）AOP、Aspects、Instrumentation-和-Messaging"><a href="#（4）AOP、Aspects、Instrumentation-和-Messaging" class="headerlink" title="（4）AOP、Aspects、Instrumentation 和 Messaging"></a>（4）AOP、Aspects、Instrumentation 和 Messaging</h3><p> Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p>
<ul>
<li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li>
</ul>
<h3 id="（5）Test模块"><a href="#（5）Test模块" class="headerlink" title="（5）Test模块"></a>（5）Test模块</h3><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能</p>
<h1 id="二，第一个Spring程序"><a href="#二，第一个Spring程序" class="headerlink" title="二，第一个Spring程序"></a>二，第一个Spring程序</h1><h2 id="1，开发环境"><a href="#1，开发环境" class="headerlink" title="1，开发环境"></a>1，开发环境</h2><h3 id="（1）java-8的安装和IDE的准备"><a href="#（1）java-8的安装和IDE的准备" class="headerlink" title="（1）java 8的安装和IDE的准备"></a>（1）java 8的安装和IDE的准备</h3><p>这里不再赘述。</p>
<h3 id="（2）Spring下载"><a href="#（2）Spring下载" class="headerlink" title="（2）Spring下载"></a>（2）Spring下载</h3><p>Spring 下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a>  根据操作系统下载对应的版本</p>
<p>以5.3.13为例，下载后的目录结构如下，其中：docs 包含 Spring 的 API 文档和开发规范；libs包含开发需要的 jar 包和源码包；schema包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-2.png"></p>
<p>在 libs 目录中，包含了 Spring 框架提供的所有 jar 文件，其中有 4 个 jar 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块，具体如下表所示。</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>spring-core-x.x.xx.jar</td>
<td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td>
</tr>
<tr>
<td>spring-beans-x.x.xx.jar</td>
<td>所有应用都要用到的，它包含访问配置文件、创建和管理 Bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。</td>
</tr>
<tr>
<td>spring-context-x.x.xx.jar</td>
<td>Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等。</td>
</tr>
<tr>
<td>spring-expression-x.x.xx.jar</td>
<td>定义了 Spring 的表达式语言。</td>
</tr>
</tbody></table>
<p><strong>注：</strong>除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息。Apache Common Logging API 下载地址：<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">https://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p>
<h2 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2,hello world"></a>2,hello world</h2><h3 id="（1）新建一个java项目，并将上面提到的5个jar包添加"><a href="#（1）新建一个java项目，并将上面提到的5个jar包添加" class="headerlink" title="（1）新建一个java项目，并将上面提到的5个jar包添加"></a>（1）新建一个java项目，并将上面提到的5个jar包添加</h3><p>两种编译器添加jar包的方式不一样</p>
<p>eclipse：<a href="https://blog.csdn.net/qq_21808961/article/details/81215590">https://blog.csdn.net/qq_21808961/article/details/81215590</a></p>
<p>idea：<a href="https://blog.csdn.net/hwt1070359898/article/details/90517291">https://blog.csdn.net/hwt1070359898/article/details/90517291</a></p>
<h3 id="（2）创建普通类并添加方法"><a href="#（2）创建普通类并添加方法" class="headerlink" title="（2）创建普通类并添加方法"></a>（2）创建普通类并添加方法</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-3.png" alt="js-1-3"></p>
<h3 id="（3）创建Spring配置文件，并配置新建的对象"><a href="#（3）创建Spring配置文件，并配置新建的对象" class="headerlink" title="（3）创建Spring配置文件，并配置新建的对象"></a>（3）创建Spring配置文件，并配置新建的对象</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-4.png" alt="js-1-4"></p>
<h3 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-5.png" alt="js-1-5"></p>
<p><strong>注：</strong>截图来源为尚硅谷Spring教程。</p>
<h3 id="总结：在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1-xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext-“配置文件路径”-来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。"><a href="#总结：在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1-xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext-“配置文件路径”-来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。" class="headerlink" title="总结：在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1.xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext(“配置文件路径”)来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。"></a><strong>总结：</strong>在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1.xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext(“配置文件路径”)来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。</h3><h1 id="三，什么是Spring-IOC"><a href="#三，什么是Spring-IOC" class="headerlink" title="三，什么是Spring IOC"></a>三，什么是Spring IOC</h1><h2 id="1，什么是IoC"><a href="#1，什么是IoC" class="headerlink" title="1，什么是IoC"></a>1，什么是IoC</h2><p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p>
<p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p>
<h2 id="2，IoC原理"><a href="#2，IoC原理" class="headerlink" title="2，IoC原理"></a>2，IoC原理</h2><p>首先我们需要了解一下IoC思想的出现和发展，推荐<a href="https://www.cnblogs.com/superjt/p/4311577.html">这篇博文</a></p>
<p>然后，本质上Spring IoC就是将对象创建的过程托管给一个IoC容器来进行，和简单工厂模式类似，但是Spring中采用了反射机制，通过读取配置文件类判断要创建的类。推荐<a href="https://www.cnblogs.com/zhuoqingsen/p/8592951.html">这篇博文</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-6.png" alt="js-1-6"></p>
<p>上图则为Sprin创建对象的一个简单的过程，左上角ApplicationContext接受读取配置文件的内容，并使用getBean方法来实例化对象，此时getBean中的字符串是”person”，匹配到配置文件中id为person的标签，并根据该标签下的其他属性通过反射机制创建该对象，该对象是单例，效率比new 高</p>
<h2 id="3，依赖注入（引）"><a href="#3，依赖注入（引）" class="headerlink" title="3，依赖注入（引）"></a>3，依赖注入（引）</h2><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”</p>
<p>在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    String bid;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，B 中存在一个 A 类型的对象属性 a，此时我们就可以说 B 的对象依赖于对象 a。而依赖注入就是就是基于这种“依赖关系”而产生的</p>
<p>我们知道，控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p>
<p>依赖注入本质上是 <a href="http://c.biancheng.net/spring/attr-injection.html">Spring Bean 属性注入</a>的一种，只不过这个属性是一个对象属性而已</p>
<h2 id="4，IoC容器的两种实现"><a href="#4，IoC容器的两种实现" class="headerlink" title="4，IoC容器的两种实现"></a>4，IoC容器的两种实现</h2><p>IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架中的 IoC 容器有BeanFactory 和 ApplicationContext。</p>
<h3 id="（1），BeanFactory"><a href="#（1），BeanFactory" class="headerlink" title="（1），BeanFactory"></a>（1），BeanFactory</h3><p> IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 。<strong>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</strong></p>
<h3 id="（2）-ApplicationContext："><a href="#（2）-ApplicationContext：" class="headerlink" title="（2） ApplicationContext："></a>（2） ApplicationContext：</h3><p> BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用。<strong>加载配置文件时候就会把在配置文件对象进行创建</strong>，并且它有实现类</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-7.png" alt="js-1-7"></p>
<p>这两个实现类的使用方式有些许不同，具体如下图：</p>
<table>
<thead>
<tr>
<th align="center">实现类</th>
<th align="center"><strong>描述</strong></th>
<th align="center">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClassPathXmlApplicationContext</td>
<td align="center">加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(String configLocation);</td>
</tr>
<tr>
<td align="center">FileSystemXmlApplicationContext</td>
<td align="center">加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new FileSystemXmlApplicationContext(String configLocation);</td>
</tr>
</tbody></table>
<blockquote>
<p>在上表的示例代码中，参数 configLocation 用于指定 Spring 配置文件的名称和位置，如 Beans.xml。</p>
</blockquote>
<h1 id="四，Spring中bean配置"><a href="#四，Spring中bean配置" class="headerlink" title="四，Spring中bean配置"></a>四，Spring中bean配置</h1><h2 id="1，Spring中bean管理——属性注入"><a href="#1，Spring中bean管理——属性注入" class="headerlink" title="1，Spring中bean管理——属性注入"></a>1，Spring中bean管理——属性注入</h2><p>前面说到，Spring中的bean在配置文件中进行了配置，那么属性的设置也在配置文件中进行，下面我们将从普通属性注入（构造器注入，setter注入，短命名空间注入），以及特殊属性注入（内部bean，集合，其他属性）</p>
<h3 id="（1）普通属性–构造器注入"><a href="#（1）普通属性–构造器注入" class="headerlink" title="（1）普通属性–构造器注入"></a>（1）普通属性–构造器注入</h3><p>使用构造函数实现属性注入大致步骤如下：</p>
<ol>
<li><p>在 Bean 中添加一个有参构造函数，构造函数内的每一个参数代表一个需要注入的属性；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，通过 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <constructor-arg> 元素，对构造函数内的属性进行赋值，Bean 的构造函数内有多少参数，就需要使用多少个 <constructor-arg> 元素。</p>
<p>下图就是一个使用构造器注入的例子，student有一个构造器，包含三个参数的初试化过程。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-8.png" alt="js-1-8"></p>
<h3 id="（2）setter注入（重点）"><a href="#（2）setter注入（重点）" class="headerlink" title="（2）setter注入（重点）"></a>（2）setter注入（<strong>重点</strong>）</h3><p>在 Spring 实例化 Bean 的过程中，IoC 容器首先会调用默认的构造方法（无参构造方法）实例化 Bean（Java 对象），然后通过 Java 的反射机制调用这个 Bean 的 setXxx() 方法，将属性值注入到 Bean 中。</p>
<p>使用 setter 注入的方式进行属性注入，大致步骤如下：</p>
<ol>
<li><p>在 Bean 中提供一个默认的无参构造函数（在没有其他带参构造函数的情况下，可省略），并为所有需要注入的属性提供一个 setXxx() 方法；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，使用 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <property> 元素对各个属性进行赋值。</p>
<p>下图为一个使用setter方法注入的例子，student类中的id，name，grade属性都有set方法</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-9.png" alt="js-1-9"></p>
<h3 id="（3）短命名空间注入"><a href="#（3）短命名空间注入" class="headerlink" title="（3）短命名空间注入"></a>（3）短命名空间注入</h3><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a><strong>p命名空间注入</strong></h4><p>p 命名空间是 setter 方式属性注入的一种快捷实现方式。通过它，我们能够以 bean 属性的形式实现 setter 方式的属性注入，而不再使用嵌套的 <property> 元素，以实现简化 Spring 的 XML 配置的目的。</p>
<p>使用 p 命名空间注入依赖时，必须注意以下 3 点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）；</li>
<li>在使用 p 命名空间实现属性注入前，XML 配置的 <beans> 元素内必须先导入 p 命名空间的 XML 约束。</li>
</ul>
<p>下图是一个p标签的例子，其中在xml文件头部必须要导入以下 XML 约束，然后employee类中有empName，dept，empNo属性以及对应对应的get和set方法，dept是一个类。在bean文件的其他部分已经进行了配置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-10.png" alt="js-1-10"></p>
<p><strong>c命名空间注入</strong></p>
<p>c命名空间用的比较少，这里不再介绍</p>
<h2 id="2，Spring中bean管理——内部bean注入"><a href="#2，Spring中bean管理——内部bean注入" class="headerlink" title="2，Spring中bean管理——内部bean注入"></a>2，Spring中bean管理——内部bean注入</h2><h3 id="（1）setter-方式注入内部-Bean"><a href="#（1）setter-方式注入内部-Bean" class="headerlink" title="（1）setter 方式注入内部 Bean"></a>（1）setter 方式注入内部 Bean</h3><p>我们可以通过 setter 方式注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <property> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义。</p>
<p><strong>需要注意的是</strong>，内部 Bean 都是匿名的，不需要指定 id 和 name 的。即使制定了，IoC 容器也不会将它作为区分 Bean 的标识符，反而会无视 Bean 的 Scope 标签。因此内部 Bean 几乎总是匿名的，且总会随着外部的 Bean 创建。内部 Bean 是无法被注入到它所在的 Bean 以外的任何其他 Bean 的。</p>
<p>下图是一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-11.png" alt="js-1-11"></p>
<h3 id="（2）构造函数方式注入内部-Bean"><a href="#（2）构造函数方式注入内部-Bean" class="headerlink" title="（2）构造函数方式注入内部 Bean"></a>（2）构造函数方式注入内部 Bean</h3><p>我们可以通过构造方法注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <constructor-arg> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义，格式如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-12.png" alt="js-1-12"></p>
<h2 id="3，Spring中bean管理——集合注入"><a href="#3，Spring中bean管理——集合注入" class="headerlink" title="3，Spring中bean管理——集合注入"></a>3，Spring中bean管理——集合注入</h2><p>这里的集合包含以下几种</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><list></td>
<td>用于注入 list 类型的值，允许重复</td>
</tr>
<tr>
<td><set></td>
<td>用于注入 set 类型的值，不允许重复</td>
</tr>
<tr>
<td><map></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型</td>
</tr>
<tr>
<td><props></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都是字符串类型</td>
</tr>
</tbody></table>
<h3 id="（1）集合中存放普通属性"><a href="#（1）集合中存放普通属性" class="headerlink" title="（1）集合中存放普通属性"></a>（1）集合中存放普通属性</h3><p>如下图，javaCollection类中，有四个参数，course，list，maps和sets，并且都有对应的get和set方法，那么使用property标签进行赋值，四种类型情况如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-13.png" alt="js-1-13"></p>
<h3 id="（2）集合中存放对象类型"><a href="#（2）集合中存放对象类型" class="headerlink" title="（2）集合中存放对象类型"></a>（2）集合中存放对象类型</h3><p>如下图，配置了三个course的实例，那么在javaCollection类中，进行配置的话，具体方式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-14.png" alt="js-1-14"></p>
<h3 id="（3）把集合注入部分提取出来"><a href="#（3）把集合注入部分提取出来" class="headerlink" title="（3）把集合注入部分提取出来"></a>（3）把集合注入部分提取出来</h3><p>首先是在配置文件中引入名称空间 util，然后util标签写好这个list（或者其他集合），在类中引用即可，这样写的话，可读性更高</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4，Spring中bean管理——其他类型属性注入"><a href="#4，Spring中bean管理——其他类型属性注入" class="headerlink" title="4，Spring中bean管理——其他类型属性注入"></a>4，Spring中bean管理——其他类型属性注入</h2><p>除了普通属性、对象属性（Bean）、集合等属性外，Spring 也能够将其他类型的属性注入到 Bean 中，例如 Null 值、字面量、复合物属性等。</p>
<h3 id="（1）注入Null值"><a href="#（1）注入Null值" class="headerlink" title="（1）注入Null值"></a>（1）注入Null值</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-15.png" alt="js-1-15"></p>
<h3 id="（2）注入空字符串"><a href="#（2）注入空字符串" class="headerlink" title="（2）注入空字符串"></a>（2）注入空字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-16.png" alt="js-1-16"></p>
<h3 id="（3）注入字面量"><a href="#（3）注入字面量" class="headerlink" title="（3）注入字面量"></a>（3）注入字面量</h3><p>在 XML 配置中“&lt;”、“&gt;”、“&amp;”等特殊字符是不能直接保存的，否则 XML 语法检查时就会报错。此时，我们可以通过以下两种方式将包含特殊符号的属性注入 Bean 中。</p>
<p>A，使用转义字符</p>
<p>在 XML 中，特殊符号经过转义可以进行赋值，这个转义的规则和HTML中的非常类似</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-17.png" alt="js-1-17"></p>
<p>B，使用短字符串 <![CDATA[]]> </p>
<p>通过短字符串 <![CDATA[]]> 将包含特殊符号的属性值包裹起来，可以让 XML 解析器忽略对其中内容的解析，以属性原本的样子注入到 Bean 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-18.png" alt="js-1-18"></p>
<p>（4）级联赋值</p>
<p>我们可以在 <bean> 的 <property> 子元素中，为它所依赖的 Bean 的属性进行赋值，这就是所谓的“级联属性赋值”。使用级联属性赋值时，需要注意以下 3点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（默认存在）；</li>
<li>依赖其他 Bean 的类中，必须提供一个它依赖的 Bean 的 getXxx() 方法。</li>
</ul>
<p>如下图，exampleBean中有dependBean属性，最开始是在外面初始化，value值是“依赖Bean内部赋值”，然后是内部进行了级联属性赋值，最终的值更新为“级联属性赋值”</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-19.png" alt="js-1-19"></p>
<h1 id="五，Spring中bean的管理"><a href="#五，Spring中bean的管理" class="headerlink" title="五，Spring中bean的管理"></a>五，Spring中bean的管理</h1><h2 id="1，Spring-Bean的作用域"><a href="#1，Spring-Bean的作用域" class="headerlink" title="1，Spring Bean的作用域"></a>1，Spring Bean的作用域</h2><h3 id="（1）Bean的作用域的类型"><a href="#（1）Bean的作用域的类型" class="headerlink" title="（1）Bean的作用域的类型"></a>（1）Bean的作用域的类型</h3><p>我们可以在 <bean> 元素中添加 scope 属性来配置 Spring Bean 的作用范围。例如，如果每次获取 Bean 时，都需要一个新的 Bean 实例，那么应该将 Bean 的 scope 属性定义为 prototype，如果 Spring 需要每次都返回一个相同的 Bean 实例，则应将 Bean 的 scope 属性定义为 singleton。</p>
<p>Spring中，共有6中类型的作用域（这里我们只需要认识singleton和prototype即可）</p>
<table>
<thead>
<tr>
<th align="left">作用范围</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。  与 singleton 类似，但 singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而一个 Web 应用中可能会存在多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在以上 6 种 Bean 作用域中，除了 singleton 和 prototype 可以直接在常规的 Spring IoC 容器（例如 ClassPathXmlApplicationContext）中使用外，剩下的都只能在基于 Web 的 ApplicationContext 实现（例如 XmlWebApplicationContext）中才能使用，否则就会抛出一个 IllegalStateException 的异常。</p>
<h3 id="（3）-singleton-和-prototype-区别"><a href="#（3）-singleton-和-prototype-区别" class="headerlink" title="（3） singleton 和 prototype 区别"></a>（3） singleton 和 prototype 区别</h3><p>第一 singleton 单实例， prototype 多实例 </p>
<p>第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象</p>
<h2 id="2，Bean的生命周期"><a href="#2，Bean的生命周期" class="headerlink" title="2，Bean的生命周期"></a>2，Bean的生命周期</h2><p>Spring中的bean的生命周期分为5个部分：1)bean的实例化 ；2) Bean的属性赋值；3）bean的初试化  ；4）bean的使用 ；5）bean的销毁</p>
<p>Spring 根据 Bean 的作用域来选择 Bean 的管理方式，</p>
<ul>
<li>对于 singleton 作用域的 Bean 来说，Spring IoC 容器能够精确地控制 Bean 何时被创建、何时初始化完成以及何时被销毁；</li>
<li>对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，然后就将 Bean 的实例交给客户端代码管理，Spring IoC 容器将不再跟踪其生命周期</li>
</ul>
<h3 id="（1）Spring-生命周期流程"><a href="#（1）Spring-生命周期流程" class="headerlink" title="（1）Spring 生命周期流程"></a>（1）Spring 生命周期流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-20.png" alt="js-1-20"></p>
<p>这里每一步都有<a href="http://c.biancheng.net/spring/life-cycle.html">解释</a>，但是这里我们注意到：<u>如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</u></p>
<h3 id="（2）bean的生命周期设置"><a href="#（2）bean的生命周期设置" class="headerlink" title="（2）bean的生命周期设置"></a>（2）bean的生命周期设置</h3><p>有三种方式可以实现控制bean的生命周期，分别是1）通过接口实现；2）通过XML实现；3）使用注解实现。实际使用时，优先级为注解&gt;接口&gt;XML配置，这里我们以注解方式为例，来说明Bean实际的生命周期过程</p>
<p>通过 JSR-250 的 @PostConstruct 和 @PreDestroy 注解，指定 Bean 的生命周期回调方法。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@PostConstruct</td>
<td>指定初始化回调方法，这个方法会在 Spring Bean 被初始化后被调用，执行一些自定义的回调操作。</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>指定销毁回调方法，这个方法会在 Spring Bean 被销毁前被调用，执行一些自定义的回调操作。</td>
</tr>
</tbody></table>
<p>1，在 net.biancheng.c 包下，创建一个名为 AnnotationLifeCycleBean 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//网站名称</span></span><br><span class="line">    <span class="keyword">private</span> String webName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeCycleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步，执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webName</span><span class="params">(String webname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webName = webname;</span><br><span class="line">		System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，在 src 目录下，新建一个 Spring 配置文件 Beans.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过 XML 配置指定生命周期回调方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3，在 net.biancheng.c 包下，创建一个名为 MainApp 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(MainApp.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取 ClassPathXmlApplicationContext 容器</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        LifeCycleBean LifeCycleBean = context.getBean(<span class="string">&quot;LifeCycleBean&quot;</span>, LifeCycleBean.class);</span><br><span class="line">       System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">        <span class="comment">//手动销毁 Bean</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置的话，打印的结果和上面的顺序一样，具体过程如下：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） </p>
<p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p>
<p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法） </p>
<p>（4） bean 可以使用了（对象获取到了） </p>
<p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h3 id="（3），Spring-后置处理器"><a href="#（3），Spring-后置处理器" class="headerlink" title="（3），Spring 后置处理器"></a>（3），Spring 后置处理器</h3><p>BeanPostProcessor 接口也被称为后置处理器，通过该接口可以自定义调用初始化前后执行的操作方法。该接口中包含了两个方法：</p>
<p> 1）postProcessBeforeInitialization() 方法：在 Bean 实例化、属性注入后，初始化前调用。          </p>
<p> 2）postProcessAfterInitialization() 方法：在 Bean 实例化、属性注入、初始化都完成后调用。</p>
<p>当需要添加多个后置处理器实现类时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，取值越大优先级越低。实现了后置处理器后，bean 生命周期有七步：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（ 5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization （6） bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<p>在上一个例子的基础上，我们可以添加处理器，首先是添加一个InitHandler类，并实现BeanPostProcessor, Ordered两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHandler</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注册处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.InitHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么最后的运行结构就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-21.png" alt="js-1-21"></p>
<h2 id="3，bean的自动装配"><a href="#3，bean的自动装配" class="headerlink" title="3，bean的自动装配"></a>3，bean的自动装配</h2><h3 id="（1）背景："><a href="#（1）背景：" class="headerlink" title="（1）背景："></a>（1）背景：</h3><p>在以往的配置中，在 Bean 与 Bean 之间建立依赖关系的行为称为“装配”。在前面的内容中，我们可以在XML中通过<constructor-arg>和 <property>的ref属性，手动维护Bean与Bean之间的依赖关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过 &lt;property&gt; 元素维护 Employee 和 Dept 的依赖关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小规模的依赖关系可以手动操作，但是大规模的依赖，需要使用自动装配功能。</p>
<h3 id="（2）自动装配"><a href="#（2）自动装配" class="headerlink" title="（2）自动装配"></a>（2）自动装配</h3><p>bean 标签属性 autowire，配置自动装配 。autowire 属性常用两个值： </p>
<p>byName  表示按属性名称自动装配，XML 文件中 Bean 的 id 或 name 必须与类中的属性名称相同。</p>
<p>byType 表示按类中对象属性数据类型进行自动装配。即使 XML 文件中 Bean 的 id 或 name 与类中的属性名不               同，只要 Bean 的 class 属性值与类中的对象属性的类型相同，就可以完成自动装配。</p>
<p>对上面两种情况，下面给了对应的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">//。。。省略的其他属性</span></span><br><span class="line">    <span class="comment">//部门信息</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略构造器和其他属性get，set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,由于开启了自动装配，那么employee类在进行属性注入的时候，如果需要配置Dept，容器就会寻找到容器中id=&quot;dept&quot;的类，调用set方法进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,这里是byType进行装配，寻找容器中class属性为Dept的类，调用set进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>byName<br>从Spring环境中获取目标对象时，目标对象中的属性会根据名称在整个Spring环境中查找标签的id属性值。如果有相同的，那么获取这个对象，实现关联。整个Spring环境：表示所有的spring配置文件中查找，那么id不能有重复的。</p>
<p>byType<br>从Spring环境中获取目标对象时，目标对象中的属性会根据类型在整个spring环境中查找标签的class属性值。如果有相同的，那么获取这个对象，实现关联。</p>
<p>如果存在多个相同类型的bean对象，会出错；如果属性为单一类型的数据，那么查找到多个关联对象会发生错误；如果属性为数组或集合(泛型)类型，那么查找到多个关联对象不会发生异常。</p>
</blockquote>
<h2 id="4，基于注解的自动装配"><a href="#4，基于注解的自动装配" class="headerlink" title="4，基于注解的自动装配"></a>4，基于注解的自动装配</h2><p>Spring 通过注解实现自动装配的步骤如下：1，引入依赖；2，开启组件扫描；3，使用注解定义 Bean；4，依赖注入</p>
<h3 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>除了 spring 的四个基础 jar 包和 commons-logging-xxx.jar 外，想要使用注解实现 Spring 自动装配，还需要引入Spring 提供的 spring-aop 的 Jar 包。</p>
<h3 id="（2）开启组件扫描"><a href="#（2）开启组件扫描" class="headerlink" title="（2）开启组件扫描"></a>（2）开启组件扫描</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能，此时会扫描net.baincheng.c包下的所有代码，如果有注解标记的实体，便会装配到容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：在使用 <a href="context:component-scan">context:component-scan</a> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。（也就是第4行添加的内容）</p>
<h3 id="（3）使用注解定义Bean"><a href="#（3）使用注解定义Bean" class="headerlink" title="（3）使用注解定义Bean"></a>（3）使用注解定义Bean</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td>@Repository</td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Service</td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Controller</td>
<td>该注解通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<h3 id="（4）基于注解的方式实现依赖注入"><a href="#（4）基于注解的方式实现依赖注入" class="headerlink" title="（4）基于注解的方式实现依赖注入"></a>（4）基于注解的方式实现依赖注入</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>可以应用到 Bean 的属性变量、setter 方法、非 setter 方法及构造函数等，默认按照 Bean 的类型进行装配。@Autowired注解默认按照 Bean 的类型进行装配，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合 @Qualifier 注解一起使用</td>
</tr>
<tr>
<td>@Resource</td>
<td>作用与 Autowired 相同，区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 的名称进行装配。@Resource 中有两个重要属性：name 和 type。<br>1，Spring 将 name 属性解析为 Bean 的实例名称，type 属性解析为 Bean 的实例类型。<br/>2，如果指定 name 属性，则按实例名称进行装配；<br/>3，如果指定 type 属性，则按 Bean 类型进行装配；<br/>4，如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</td>
</tr>
</tbody></table>
<h3 id="（5）示例"><a href="#（5）示例" class="headerlink" title="（5）示例"></a>（5）示例</h3><p>A，创建Spring-autowire-demo工程，并导入要求的6个包（基本的5个加上Spring-aop-xxxx）</p>
<p>B，创建com.zhao.spring.dao包，并创建名为UserDao的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，创建com.zhao.spring.dao.impl包，在其中创建UserDao的实现类UserDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system.out.print(<span class="string">&quot;进行了Dao层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，创建com.zhao.spring.servcie包，在其中创建UserServcie接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，创建com.zhao.spring.service.impl包，并创建UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> UserServcieImpl implements UserService&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.print(<span class="string">&quot;进行了Service层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>F,创建com.zhao.spring.controller包，并在包下创建UserController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;userController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span><span class="comment">//能实现和@Autowired一样的效果</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServcie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.out;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了Controller层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>G，在src目录下，创建配置文件Beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spirng&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>H，在com.zhao.spring包下，创建MainApplication.class，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        UserController userController = context.getBean(<span class="string">&quot;userController&quot;</span>,UserController.class);</span><br><span class="line">        userController.doStr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I，最后控制台输出应该是下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行了Dao层访问</span><br><span class="line">进行了Service层访问</span><br><span class="line">进行了Controller层访问</span><br></pre></td></tr></table></figure>

<h2 id="5，外部属性文件的配置链接"><a href="#5，外部属性文件的配置链接" class="headerlink" title="5，外部属性文件的配置链接"></a>5，外部属性文件的配置链接</h2><p>在操作数据库时，我们经常会用到连接池对数据库链接进行管理，其中比较常用的就是Druid，有两种方式在Spring配置该数据库连接池。</p>
<p>（1）直接配置数据库信息</p>
<p>首先，引入Druid连接池依赖jar包</p>
<p>然后，在xml文件中配置连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）引入外部属性文件配置数据库连接池</p>
<p>首先，新建jdbc.properties配置文件，文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql://localhost:3306/userDb</span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>然后，把外部 properties 属性文件引入到 spring 配置文件中（注意引入 context 名称空间）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六，AOP面向切面编程"><a href="#六，AOP面向切面编程" class="headerlink" title="六，AOP面向切面编程"></a>六，AOP面向切面编程</h1><h2 id="1，认识AOP"><a href="#1，认识AOP" class="headerlink" title="1，认识AOP"></a>1，认识AOP</h2><h3 id="（1）目标"><a href="#（1）目标" class="headerlink" title="（1）目标"></a>（1）目标</h3><p>假设现在有一个电商系统，我们根据业务使用 OOP（面向对象）思想，将应用划分为多个不同的业务模块，例如订单模块、商品模块等。但是，除了这些功能模块，我们还需要一些一些非业务的通用功能，例如日志管理、权限管理、事务管理、异常管理等。这些功能可能贯穿所有业务模块。</p>
<p>理论上可以将这些非业务功能抽象为公共方法，但是这样代码间的耦合性就会非常高。我们想能不能让业务只专注与业务，添加非业务代码不会影响业务本身。</p>
<h3 id="（2）面向切面编程（AOP）"><a href="#（2）面向切面编程（AOP）" class="headerlink" title="（2）面向切面编程（AOP）"></a>（2）面向切面编程（AOP）</h3><p>AOP 的全称是“Aspect Oriented Programming”，译为“面向切面编程”，和 OOP（面向对象编程）类似，它也是一种编程思想。</p>
<p>与 OOP 中纵向的父子继承关系不同，AOP 是通过横向的抽取机制实现的。它将应用中的一些非业务的通用功能抽取出来单独维护，并通过声明的方式（例如配置文件、注解等）定义这些功能要以何种方式作用在那个应用中，而不是在业务模块的代码中直接调用。</p>
<p>这虽然设计公共函数有几分类似，但传统的公共函数除了在代码直接硬调用之外并没有其他手段。AOP 则为这一问题提供了一套灵活多样的实现方法（例如 Proxy 代理、拦截器、字节码翻译技术等），可以在无须修改任何业务代码的基础上完成对这些通用功能的调用和修改。</p>
<h3 id="（3）AOP实现（框架）"><a href="#（3）AOP实现（框架）" class="headerlink" title="（3）AOP实现（框架）"></a>（3）AOP实现（框架）</h3><table>
<thead>
<tr>
<th align="left">AOP 框架</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Spring AOP</td>
<td>是一款基于 AOP 编程的框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。  Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。Spring AOP 支持 2 种代理方式，分别是基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理。</td>
</tr>
<tr>
<td align="left">AspectJ</td>
<td>是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。  AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。</td>
</tr>
</tbody></table>
<h3 id="（4）AOP术语"><a href="#（4）AOP术语" class="headerlink" title="（4）AOP术语"></a>（4）AOP术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint（连接点）</td>
<td>AOP 的核心概念，指的是程序执行期间明确定义的一个点，例如方法的调用、类初始化、对象实例化等。 <strong>通俗说</strong>，类里面的可以被增强的方法（or变量），称之为连接点。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>又称切点，指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。<strong>通俗说</strong>，就是实际被增强的方法。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>指拦截到 Joinpoint 之后要执行的代码，即对切入点增强的内容。<strong>通俗说</strong>，实际增强的逻辑部分就称为通知</td>
</tr>
<tr>
<td>Target（目标）</td>
<td>指代理的目标对象，通常也被称为被通知（advised）对象。</td>
</tr>
<tr>
<td>Weaving（织入）</td>
<td>指把增强代码应用到目标对象上，生成代理对象的过程。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>指生成的代理对象。</td>
</tr>
<tr>
<td>Aspect（切面）</td>
<td>切面是切入点（Pointcut）和通知（Advice）的结合。<strong>通俗说，</strong>就是把通知应用到切入点的过程</td>
</tr>
</tbody></table>
<h2 id="2，Spring-AOP"><a href="#2，Spring-AOP" class="headerlink" title="2，Spring AOP"></a>2，Spring AOP</h2><h3 id="（1）Spring-AOP的代理机制"><a href="#（1）Spring-AOP的代理机制" class="headerlink" title="（1）Spring AOP的代理机制"></a>（1）Spring AOP的代理机制</h3><p>Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。</p>
<p>Spring AOP 的底层是通过以下 2 种动态代理机制，为目标对象（Target Bean）执行横向织入的。</p>
<table>
<thead>
<tr>
<th>代理技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 动态代理</td>
<td>Spring AOP 默认的动态代理方式，若目标对象实现了若干接口，Spring 使用 JDK 的 java.lang.reflect.Proxy 类进行代理。(也就是通过接口来实现一个对象来进行操作)</td>
</tr>
<tr>
<td>CGLIB 动态代理</td>
<td>若目标对象没有实现任何接口，Spring 则使用 CGLIB 库生成目标对象的子类，以实现对目标对象的代理。（创建一个类的子类来进行增强操作）</td>
</tr>
</tbody></table>
<p>对于使用JDK的 java.lang.reflect.Proxy 类进行代理，主要是考Proxy类的newProxyInstance 方法实现，该方法有三个参数，<u>第一参数</u>，类加载器；<u>第二参数</u>，增强方法所在的类，这个类实现的接口，支持多个接口；<u>第三参数</u>，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance (ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h);</span><br></pre></td></tr></table></figure>

<p>下面就贴一段代码帮助理解这样的代理具体是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，创建接口，定义方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2,创建接口实现类，实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3,使用Proxy类创建接口代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="comment">//这里的dao也就是加了增强逻辑了的</span></span><br><span class="line">        <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4,这里是代理对象的逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先这个有参构造器，是用来接受需要创建代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里填写增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="comment">//执行方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法执行（也就是调用原来的增强的方法）</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）Spring-AOP连接点"><a href="#（2）Spring-AOP连接点" class="headerlink" title="（2）Spring AOP连接点"></a>（2）Spring AOP连接点</h3><p>Spring AOP 并没有像其他 AOP 框架（例如 AspectJ）一样提供了完成的 AOP 功能，它是 Spring 提供的一种简化版的 AOP 组件。其中最明显的简化就是，Spring AOP 只支持一种连接点类型：方法调用。您可能会认为这是一个严重的限制，但实际上 Spring AOP 这样设计的原因是为了让 Spring 更易于访问。</p>
<p>方法调用连接点是迄今为止最有用的连接点，通过它可以实现日常编程中绝大多数与 AOP 相关的有用的功能。如果需要使用其他类型的连接点（例如成员变量连接点），我们可以将 Spring AOP 与其他的 AOP 实现一起使用，最常见的组合就是 Spring AOP + ApectJ。 </p>
<h3 id="（3）Spring-AOP通知类型"><a href="#（3）Spring-AOP通知类型" class="headerlink" title="（3）Spring AOP通知类型"></a>（3）Spring AOP通知类型</h3><table>
<thead>
<tr>
<th>通知类型</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
<td>在目标方法执行前实施增强。</td>
</tr>
<tr>
<td>后置通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行后实施增强。</td>
</tr>
<tr>
<td>后置返回通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行完成，并返回一个返回值后实施增强。</td>
</tr>
<tr>
<td>环绕通知</td>
<td>org.aopalliance.intercept.MethodInterceptor</td>
<td>在目标方法执行前后实施增强。</td>
</tr>
<tr>
<td>异常通知</td>
<td>org.springframework.aop.ThrowsAdvice</td>
<td>在方法抛出异常后实施增强。</td>
</tr>
<tr>
<td>引入通知</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
<td>在目标类中添加一些新的方法和属性。</td>
</tr>
</tbody></table>
<h2 id="3，Spring集成AspectJ"><a href="#3，Spring集成AspectJ" class="headerlink" title="3，Spring集成AspectJ"></a>3，Spring集成AspectJ</h2><p>Spring AOP 是一个简化版的 AOP 实现，并没有提供完整版的 AOP 功能。通常情况下，Spring AOP 是能够满足我们日常开发过程中的大多数场景的，但在某些情况下，我们可能需要使用 Spring AOP 范围外的某些 AOP 功能。例如 Spring AOP 仅支持执行公共（public）非静态方法的调用作为连接点，如果我们需要向受保护的（protected）或私有的（private）的方法进行增强，此时就需要使用功能更加全面的 AOP 框架来实现，其中使用最多的就是 AspectJ。</p>
<p>AspectJ 是一个基于 Java 语言的全功能的 AOP 框架，它并不是 Spring 组成部分，是一款独立的 AOP 框架。但由于 AspectJ 支持通过 Spring 配置 AspectJ 切面，因此它是 Spring AOP 的完美补充，通常情况下，我们都是将 AspectJ 和 Spirng 框架一起使用，简化 AOP 操作。</p>
<h3 id="（1）引入依赖-1"><a href="#（1）引入依赖-1" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>使用AspectJ需要引入一些依赖，这些包可以自行下载（红色为必须新增的，绿色则看情况）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-22.png" alt="js-1-22"></p>
<h3 id="（2）基于XML的AOP开发"><a href="#（2）基于XML的AOP开发" class="headerlink" title="（2）基于XML的AOP开发"></a>（2）基于XML的AOP开发</h3><p><u>A，引入aop命名空间（在xml文件头中引入）</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>B，定义切面</u></p>
<p>在 Spring 配置文件中，使用 &lt;aop:aspect&gt; 元素定义切面。该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 &lt;aop:aspect&gt; 之前需要先定义一个普通的 Spring Bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用来定义该切面的唯一标识名称，ref 用于引用普通的 Spring Bean。</p>
<p><u>C，定义切入点&lt;aop:pointcut&gt;</u> </p>
<p>&lt;aop:pointcut&gt; 用来定义切入点，用来表示对哪个类中的那个方法进行增强。它既可以在 &lt;aop:pointcut&gt; 元素中使用，也可以在&lt;aop:pointcut&gt; 元素下使用。</p>
<ul>
<li>当&lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享；</li>
<li>当 &lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素时，表示该切入点只对当前切面有效。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* net.biancheng.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式。</p>
<p>execution 的语法格式格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符] [返回值类型] [类的完全限定名] [方法名称]([参数列表]) </span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>返回值类型、方法名、参数列表是必须配置的选项，而其它参数则为可选配置项。</li>
<li>返回值类型：<code>*</code>表示可以为任何返回值。如果返回值为对象，则需指定全路径的类名。</li>
<li>类的完全限定名：指定包名 + 类名。</li>
<li>方法名：<code>*</code>代表所有方法，<code>set*</code> 代表以 set 开头的所有方法。</li>
<li>参数列表：<code>(..)</code>代表所有参数；<code>(*)</code>代表只有一个参数，参数类型为任意类型；<code>(*,String)</code>代表有两个参数，第一个参数可以为任何值，第二个为 String 类型的值。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-23.png" alt="js-1-23"></p>
<p><u>D，定义通知</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异常通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最终通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    .... </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>E，示例</u></p>
<p>E-1. 新建一个名为 my-spring-asepctj-demo 的 Java 项目，并将以下依赖 Jar 包导入到该项目中。</p>
<ul>
<li>commons-logging-1.2.jar</li>
<li>spring-aop-5.3.13.jar</li>
<li>spring-aspects-5.3.13.jar</li>
<li>spring-beans-5.3.13.jar</li>
<li>spring-context-5.3.13.jar</li>
<li>spring-core-5.3.13.jar</li>
<li>spring-expression-5.3.13.jar</li>
<li>aspectjweaver-1.9.7.jar</li>
</ul>
<p>E-2. 在 com.zhao.spring.dao 包下，创建一个名为 OrderDao 的接口，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-3.在 com.zhao.spring.dao.impl 包下，创建 OrderDao 的实现类 OrderDaoImpl，这是一个被增强类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 add() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 delete() 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-4. 在com.zhao.spring 包下，创建一个名为 MyOrderAspect 的类，这是一个增强类，用来实现一些增强方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderAspect</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---前……&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---后……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常增强…… 异常信息为：&quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置返回增强…… 方法返回值为：&quot;</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-5. 在 src 目录下创建一个 Spring 配置文件 Beans2.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义 Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.dao.impl.OrderDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myOrderAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.MyOrderAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开始配置增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面是两个切面，前一个代表了对add方法进行增强，后一个代表对OrderDao类的所有方法进行增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;beforePointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.add(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;afterPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面的这个aop:aspect使用了myOrderAspect增强类中的方法-&gt;</span></span><br><span class="line"><span class="comment">        &lt;aop:aspect ref=&quot;myOrderAspect&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;!--前置增强，这里使用before方法对add方法进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--后置返回增强，这个使用afterReturning方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterReturnPointCut&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">returning</span>=<span class="string">&quot;returnValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最终通知，这个使用after方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterPointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--环绕通知，这个使用aroud方法对add进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>E-6. 在 net.biancheng.c 包下，创建一个名 MainApp 的类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans2.xml&quot;</span>);</span><br><span class="line">        OrderDao orderDao = context2.getBean(<span class="string">&quot;orderDao&quot;</span>, OrderDao.class);</span><br><span class="line">        orderDao.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        orderDao.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-7. 执行 MainApp 中的 main 方法，控制台输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置增强……</span><br><span class="line">环绕增强---前……</span><br><span class="line">正在执行 OrderDao 中的 add() 方法</span><br><span class="line">环绕增强---后……</span><br><span class="line">最终增强……</span><br><span class="line">====</span><br><span class="line">正在执行 OrderDao 中的 delete() 方法</span><br><span class="line">后置返回增强…… 方法返回值为：1</span><br><span class="line">最终增强……</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring5</tag>
      </tags>
  </entry>
  <entry>
    <title>xm-2-MyBatis-Plus</title>
    <url>/2022/02/06/xm-2-MyBatis-Plus/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，基础知识之字词积累"><a href="#一，基础知识之字词积累" class="headerlink" title="一，基础知识之字词积累"></a>一，基础知识之字词积累</h1><h2 id="1，《斑比出生了》"><a href="#1，《斑比出生了》" class="headerlink" title="1，《斑比出生了》"></a>1，《斑比出生了》</h2><h3 id="（1），几种类型的词语"><a href="#（1），几种类型的词语" class="headerlink" title="（1），几种类型的词语"></a>（1），几种类型的词语</h3><h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>尚融宝项目背景</title>
    <url>/2022/02/05/xm-1-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>**简介：尚融宝是尚硅谷培训机构的一个中等规模的项目，实现了一个网络借贷信息中介服务平台，为个人投资者、个人融资用户和小微企业提供专业的线上信贷及出借撮合服务。是学习微服务一个不错的项目。</p>
<span id="more"></span>

<h1 id="一，项目简介"><a href="#一，项目简介" class="headerlink" title="一，项目简介"></a>一，项目简介</h1><h2 id="1，项目的业务流程"><a href="#1，项目的业务流程" class="headerlink" title="1，项目的业务流程"></a>1，项目的业务流程</h2><p>业务流程如下图，从业务流程图可以看出，每个步骤必须有一个开始和结束，中间没有特别复杂的分支，设计业务的时候就应该像这样清晰简洁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-1.png" alt="xm-1-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-2.png" alt="xm-1-2"></p>
<h2 id="2，项目的架构图"><a href="#2，项目的架构图" class="headerlink" title="2，项目的架构图"></a>2，项目的架构图</h2><p>从架构图可以看出，不同服务之间的前端，网关，配置，数据库都可能会不一样，并且在发布时使用了Doker技术</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-3.png" alt="xm-1-3"></p>
<h1 id="二，技术栈（注意版本）"><a href="#二，技术栈（注意版本）" class="headerlink" title="二，技术栈（注意版本）"></a>二，技术栈（注意版本）</h1><p>首先基础的部分需要掌握：java基础、HTML、CSS、JavaScript、Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud Alibaba，MySQL（5.7及以上）、Redis、RabbitMQ、nginx、idea、maven、VMWare 虚拟机、CentOS 操作系统</p>
<h2 id="1，后端"><a href="#1，后端" class="headerlink" title="1，后端"></a>1，后端</h2><p><strong>SpringBoot 2.3.4.RELEASE</strong></p>
<p><strong>SpringCloud Hoxton.SR8：</strong>微服务基础设施 - 服务注册、服务发现、服务熔断、微服务网关、配置中心等</p>
<p>SpringCloud Alibaba 2.2.2.RELEASE</p>
<p><strong>MyBatis Plus：持久层框架和代码生成器</strong></p>
<p>Lombok：简化实体类开发</p>
<p>Swagger2：Api接口文档生成工具</p>
<p>Logback：日志系统</p>
<p>alibaba-easyexcel：Excel读写</p>
<p><strong>Spring Data Redis：Spring项目中访问Redis缓存</strong></p>
<p>HTTPClient: 基于Http协议的客户端，用来实现远程调用</p>
<p>Spring Task：定时任务</p>
<h2 id="2，数据库和中间件"><a href="#2，数据库和中间件" class="headerlink" title="2，数据库和中间件"></a>2，数据库和中间件</h2><p><strong>MySQL 5.7：关系型数据库   管理工具：Navicat</strong></p>
<p><strong>Redis 5.0：缓存技术   管理工具：RedisDesktopManager</strong></p>
<p><strong>RabbitMQ 3.8：消息中间件</strong></p>
<h2 id="3，三方接口"><a href="#3，三方接口" class="headerlink" title="3，三方接口"></a>3，三方接口</h2><p>阿里云短信：短信网关</p>
<p>阿里云OSS：分布式文件存储</p>
<p>资金托管平台API对接：汇付宝</p>
<h2 id="4，了解即可"><a href="#4，了解即可" class="headerlink" title="4，了解即可"></a>4，了解即可</h2><p>Node.js： JavaScript 运行环境</p>
<p>ES6：JavaScript的模块化版本</p>
<p>axios：一个发送Ajax请求的工具</p>
<p>Vue.js：web 界面的渐进式框架</p>
<p>Element-UI：前端组件库</p>
<p>模块化开发：解决javascript变量全局空间污染的问题</p>
<p>NPM：模块资源管理器</p>
<p>vue-element-admin：基于Vue.js的后台管理系统UI集成方案</p>
<p>NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架</p>
<h1 id="三，开发环境"><a href="#三，开发环境" class="headerlink" title="三，开发环境"></a>三，开发环境</h1><h2 id="1，开发环境检测"><a href="#1，开发环境检测" class="headerlink" title="1，开发环境检测"></a>1，开发环境检测</h2><p>在开始开发之前，需要确定基本的环境是否和开发要求的一致，在本项目中，要检查以下几个方面：</p>
<ul>
<li><p>jdk 1.8 配置：JAVA_HOME，path</p>
</li>
<li><p>maven 3.6 配置：MAVEN_HOME，本地仓库</p>
</li>
<li><p>ideaIU-2020.2.3，尽量在欢迎页面进行设置，这样对所有项目都是普遍有效的，当然给特定项目设置也是可以的，这里注意通过File–&gt;close project来到欢迎界面，如果不想每次打开idea都进入已有的项目（特别是大的项目，加载就得好一会），可以通过在Setting-&gt;System Settings取消勾选Reopen last project on open（如下图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-4.png" alt="xm-1-4"></p>
<p><em>注意：在idea的欢迎页面选择Configure &gt; settings</em>（比较新的版本似乎取消了右下角的Configure，比如我的idea 2021，要设置的话可以参考下图）。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-5.png" alt="xm-1-5"></p>
</li>
</ul>
<p>接着就是在开始一个项目时，一些基础的配置，<em>包括配置：Java Compiler、File Encodings、Maven、Auto Import、Code Completion &gt; Match case（取消）</em>  <em>插件：lombok、MyBatisX</em></p>
<p>1，Java Compiler。需要在Setting中（搜索Java Compiler），设置编译器为javac，版本为自己安装的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-6.png" alt="xm-1-6"></p>
<p>2，File Encodings。同上，如图，需要设置三个地方的编码方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-7.png" alt="xm-1-7"></p>
<p>3，maven</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-8.png" alt="xm-1-8"></p>
<p>4，Auto Import、Code Completion &gt; Match case（取消) 插件：lombok、MyBatisX</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-9.png" alt="xm-1-9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-10.png" alt="xm-1-10"></p>
<p>5，插件：lombok、MyBatisX</p>
<p>插件安装这里不再赘述</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
</search>
