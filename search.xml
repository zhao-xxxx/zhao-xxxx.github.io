<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jc-2-虚拟机</title>
    <url>/2022/04/25/jc-2-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p><strong>简介：</strong>虚拟机部分关键知识点学习</p>
<span id="more"></span>

<h1 id="一，认识JVM"><a href="#一，认识JVM" class="headerlink" title="一，认识JVM"></a>一，认识JVM</h1><h2 id="1，JVM是什么？有什么好处？"><a href="#1，JVM是什么？有什么好处？" class="headerlink" title="1，JVM是什么？有什么好处？"></a>1，JVM是什么？有什么好处？</h2><p>*一次编译，到处运行</p>
<p>*数组越界检查</p>
<p>*管理内存</p>
<h2 id="2，常见的JVM"><a href="#2，常见的JVM" class="headerlink" title="2，常见的JVM"></a>2，常见的JVM</h2><p>hotspot</p>
<p>按照规范自定义虚拟机</p>
<h2 id="3，学习路线"><a href="#3，学习路线" class="headerlink" title="3，学习路线"></a>3，学习路线</h2><p>JVM内存结构</p>
<p>GC垃圾回收机制</p>
<p>java文件编译优化</p>
<p>类加载的过程</p>
<p>运行的优化</p>
<h1 id="二，内存结构"><a href="#二，内存结构" class="headerlink" title="二，内存结构"></a>二，内存结构</h1><h2 id="1，程序计数器"><a href="#1，程序计数器" class="headerlink" title="1，程序计数器"></a>1，程序计数器</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220705215546471.png" alt="image-20220705215546471" style="zoom: 50%;" />

<p>记住下一条JVM指令的执行地址</p>
<h3 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h3><ul>
<li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li>
</ul>
<p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p>
<p>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</p>
<p><strong>它是唯一一个在 JVM 规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong></p>
<h2 id="2，虚拟机栈"><a href="#2，虚拟机栈" class="headerlink" title="2，虚拟机栈"></a>2，虚拟机栈</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220705220612451.png" alt="image-20220705220612451" style="zoom: 50%;" />

<p>每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用（包括方法的参数，局部变量，返回地址），是线程私有的，生命周期和线程一致。</p>
<blockquote>
<p>1，垃圾不涉及栈内存</p>
<p>2，栈内存越大并不是越好，会导致并发的线程变少</p>
<p>3，方法内的局部变量，如果没有逃离方法的作用范围，则是线程安全的；如果局部变量引用了对象，并逃离了方法的作用范围，则是线程不安全的</p>
</blockquote>
<h3 id="栈运行原理："><a href="#栈运行原理：" class="headerlink" title="栈运行原理："></a>栈运行原理：</h3><p>1，JVM 直接对 Java 栈的操作只有两个，对栈帧的<strong>压栈</strong>和<strong>出栈</strong>，遵循“先进后出&#x2F;后进先出”原则</p>
<p>2，在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧</strong>（Current Frame），与当前栈帧对应的方法就是<strong>当前方法</strong>（Current Method），定义这个方法的类就是<strong>当前类</strong>（Current Class）</p>
<p>3，如果在,当前方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧（不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧）</p>
<p>4，如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
<p>5，Java 方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</strong></p>
<h3 id="栈内存溢出："><a href="#栈内存溢出：" class="headerlink" title="栈内存溢出："></a>栈内存溢出：</h3><p>1，递归调用，不断有新的栈帧</p>
<p>2，栈帧设置过大，也容易栈内存溢出</p>
<h3 id="栈帧的结构：（扩展）"><a href="#栈帧的结构：（扩展）" class="headerlink" title="栈帧的结构：（扩展）"></a>栈帧的结构：（扩展）</h3><h2 id="3，本地方法栈"><a href="#3，本地方法栈" class="headerlink" title="3，本地方法栈"></a>3，本地方法栈</h2><ul>
<li><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用，给本地方法的运行提供</p>
</li>
<li><p>本地方法栈也是线程私有的</p>
</li>
<li><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p>
</li>
</ul>
<blockquote>
<p>栈是运行时的单位，而堆是存储的单位。</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。</p>
</blockquote>
<h2 id="4，堆"><a href="#4，堆" class="headerlink" title="4，堆"></a>4，堆</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>通过new关键字创建的对象都会使用堆内存。（是线程共享的，需要考虑线程安全；有垃圾回收机制）</p>
<p>堆内存逻辑上划分为三个区域：</p>
<ul>
<li>新生代（年轻代）：新对象和没达到一定年龄的对象</li>
<li>老年代（养老区）：被长时间使用的对象，内存空间比新生代大</li>
<li>元空间（jdk1.8之前叫永久代）：一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</li>
</ul>
<h3 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220706114724866.png" alt="image-20220706114724866"></p>
<p><strong>（1）年轻代：</strong>年轻代被分为三个区域，伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from&#x2F;to或s0&#x2F;s1），默认比例是8:1:1</p>
<blockquote>
<p>大多数新创建对象都位于Eden内存空间中。Eden被填满时，执行Minor GC，将所有的幸存对象移到某个SM中；过段时间Minor GC还会检查并再次移动幸存对象到另一个SM中，多次GC后存活下来的对象进入老年代</p>
</blockquote>
<p><strong>（2）老年代</strong>：旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。 </p>
<blockquote>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p>
</blockquote>
<p><strong>（3）元空间</strong>：不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。</p>
<h3 id="堆的设置："><a href="#堆的设置：" class="headerlink" title="堆的设置："></a>堆的设置：</h3><p>（1）参数：</p>
<ul>
<li><p><code>-Xms</code> 用来表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code>（默认初始堆内存大小为：电脑内存大小&#x2F;64）</p>
</li>
<li><p><code>-Xmx</code> 用来表示堆的最大内存，等价于 <code>-XX:MaxHeapSize</code>（默认最大堆内存大小为：电脑内存大小&#x2F;4）</p>
</li>
</ul>
<p>（2）堆内存分配</p>
<p>默认情况下新生代和老年代的比例是 1:2，可以通过 <code>–XX:NewRatio</code> 来配置（新生代中的 <strong>Eden</strong>:<strong>From Survivor</strong>:<strong>To Survivor</strong> 的比例是 <strong>8:1:1</strong>，可以通过 <code>-XX:SurvivorRatio</code> 来配置）</p>
<p>（3）对象在堆中的生命周期</p>
<p>3.1 在 JVM 内存模型的堆中，堆被划分为新生代和老年代</p>
<ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
<p>3.2 当创建一个对象时，对象会被优先分配到新生代的 Eden 区</p>
<ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
<p>3.3 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）</p>
<ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
<p>3.4 如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></p>
<p>（4）对象的创建和分配过程</p>
<p>4.1 new的对象先放在新生代的eden区，当eden区被填满时，则用minor GC进行垃圾回收，销毁没有用的对象，将幸存的对象放进Survivor 1区，然后再放new的对象</p>
<p>4.2 如果再次触发垃圾回收，此时上次幸存下来的放到Survivor 0 区，如果没有回收，就会放到Survivor  1 区<br>；接着如果再次经历垃圾回收，此时会重新放回Survivor 0 区，接着再去Survivor 1 区</p>
<p>4.3 默认是 15 次回收标记 在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理 若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常</p>
<p>（5）TLAB（Thread Local Allocation Buffer）</p>
<p>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内 多线程同时分配内存时，</p>
<p>使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220706162417323.png" alt="image-20220706162417323"></p>
<p>（6）堆是分配对象存储的唯一选择吗（逃逸分析）</p>
<h3 id="堆内存诊断："><a href="#堆内存诊断：" class="headerlink" title="堆内存诊断："></a>堆内存诊断：</h3><p>（1）jps工具：</p>
<p>查看当前系统中有哪些java进程</p>
<p>（2）jmap工具</p>
<p>查看堆内存占用情况，命令是：jmap -heap 进程id（Heap Usage下的内容）</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220707160141090.png" alt="image-20220707160141090" style="zoom:67%;" />

<h2 id="5，方法区"><a href="#5，方法区" class="headerlink" title="5，方法区"></a>5，方法区</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现</p>
<h3 id="辨析（方法区，永久代，元数据区）："><a href="#辨析（方法区，永久代，元数据区）：" class="headerlink" title="辨析（方法区，永久代，元数据区）："></a>辨析（方法区，永久代，元数据区）：</h3><p><strong>方法区（method area）</strong>只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而<strong>永久代（PermGen）</strong>是 Hotspot虚拟机特有的概念， Java8 的时候又被元空间取代了，<strong>永久代和元空间都可以理解为方法区的落地实现。</strong></p>
<p><strong>永久代</strong>物理上是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而<strong>元空间</strong>存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）</p>
<p>永久代和元空间存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220707162742379.png" alt="image-20220707162742379" style="zoom:67%;" />

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220706163501975.png" alt="image-20220706163501975"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220706170614495.png" alt="image-20220706170614495"></p>
<h3 id="方法区大小："><a href="#方法区大小：" class="headerlink" title="方法区大小："></a>方法区大小：</h3><p>补充</p>
<h3 id="内部结构："><a href="#内部结构：" class="headerlink" title="内部结构："></a>内部结构：</h3><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p>
<p>（1）类型信息</p>
<p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：全类名+父类全类名（有的话）+访问修饰符+直接接口列表</p>
<p>（2）域信息</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）</p>
<p>（3）方法</p>
<p>方法名称，返回类型，参数，修饰符，字符码，异常表</p>
<h3 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，首先我们需要理解常量池</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220707172138120.png" alt="image-20220707172138120"></p>
<p>（1）常量池：</p>
<p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p>
<p>（2）运行时常量池：</p>
<p>在加载了类和结构到虚拟机后，就会创建运行时常量池。</p>
<p>每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</p>
<h3 id="StringTable（字符串常量池）："><a href="#StringTable（字符串常量池）：" class="headerlink" title="StringTable（字符串常量池）："></a>StringTable（字符串常量池）：</h3><p>（1）作用：体现在创建的过程中，直接创建还是说</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220709153436697.png" alt="image-20220709153436697" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220709154747417.png" alt="image-20220709154747417" style="zoom:67%;" />

<p>（2）位置</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220709155856169.png" alt="image-20220709155856169" style="zoom:67%;" />

<p>（3）垃圾回收机制</p>
<p>会发生垃圾回收</p>
<p>（4）性能调优</p>
<p>一个是可以调整 -XX:StringTableSize&#x3D;桶个数（数量越大越快）</p>
<p>一个是考虑字符串对象是否入池</p>
<h1 id="三，内存模型"><a href="#三，内存模型" class="headerlink" title="三，内存模型"></a>三，内存模型</h1><h2 id="1，直接内存"><a href="#1，直接内存" class="headerlink" title="1，直接内存"></a>1，直接内存</h2><h3 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h3><p>直接内存不属于JVM管理，操作系统管理，常见于NIO操作时用作数据缓冲区，分配回收成本较高，读写性能高</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710151107189.png" alt="image-20220710151107189"></p>
<p>！原来读取数据的时候，需要经过两个缓冲区，数据多复制了一次，导致速度变慢</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710151243134.png" alt="image-20220710151243134" style="zoom:67%;" />

<p>！划分出直接内存，java程序可以直接访问直接内存，减少了一次数据的复制</p>
<p>！从上面就引出一个问题，直接内存也会出现内存溢出，分配和回收是这么样的呢？</p>
<h3 id="内存管理："><a href="#内存管理：" class="headerlink" title="内存管理："></a>内存管理：</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710155900557.png" alt="image-20220710155900557"></p>
<p>不是垃圾回收来管理的，而是使用unsafe的类来进行管理</p>
<h2 id="2，内存模型简单引入"><a href="#2，内存模型简单引入" class="headerlink" title="2，内存模型简单引入"></a>2，内存模型简单引入</h2><h3 id="存的对象："><a href="#存的对象：" class="headerlink" title="存的对象："></a>存的对象：</h3><p>（1）每个线程都有自己的栈，包含执行的每个方法的所有局部变量，这些变量对其他线程不可见。八个基本类型的所有变量都是存在栈中的，一个线程不能和另一个线程共享这些变量，只能传递副本</p>
<p>（2）堆包含了在Java应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类(例如Byte，Integer，Long等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。</p>
<p>（3）四种情况的存储方式：</p>
<p>！局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。</p>
<p>！局部变量也可以是对象的引用。 在这种情况下，引用(局部变量)存储在线程堆栈中，但是对象本身存储在堆(Heap)上。</p>
<p>！对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。</p>
<p>！静态类变量也与类定义一起存储在堆上</p>
<p>（4）线程栈如何访问堆的对象？</p>
<p>首先线程栈中的变量可以引用堆中的对象，以及对象的成员变量，但每个线程都有自己的局部变量副本。</p>
<p>其次两个线程可以引用同一对象，注意共享对象(对象3)如何将对象2和对象4作为成员变量引用(由对象3到对象2和对象4的箭头所示)。 通过对象3中的这些成员变量引用，两个线程可以访问对象2和对象4.</p>
<p>另外有一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象(对象1和对象5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象1和对象5。 但是在上图中，每个线程只引用了两个对象中的一个。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710203822656.png" alt="image-20220710203822656" style="zoom:67%;" />

<h3 id="JMM与硬件内存结构的关系："><a href="#JMM与硬件内存结构的关系：" class="headerlink" title="JMM与硬件内存结构的关系："></a>JMM与硬件内存结构的关系：</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710211509958.png" alt="image-20220710211509958" style="zoom:67%;" />

<p>CPU：现代计算机通常有2个或更多CPU。 其中一些CPU也可能有多个内核。 每个CPU都能够在任何给定时间运行一个线程。 这意味着如果您的Java应用程序是多线程的，线程真的在可能同时运行.</p>
<p>寄存器：每个CPU基本上都包含一组在CPU内存中的寄存器。 CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为CPU可以比访问主存储器更快地访问这些寄存器。</p>
<p> 高速缓存存储器：大多数现代CPU都有一些大小的缓存存储层。 CPU可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU高速缓存存储器介于内部寄存器和主存储器的速度之间。</p>
<p>主存储区（RAM）：所有CPU都可以访问主内存。 主存储区通常比CPU的高速缓存存储器大得多。同时访问速度也就较慢.</p>
<h3 id="JMM与硬件内存的关系："><a href="#JMM与硬件内存的关系：" class="headerlink" title="JMM与硬件内存的关系："></a>JMM与硬件内存的关系：</h3><p>Java内存模型（JMM）和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中。 这在图中说明：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710212827502.png" alt="image-20220710212827502" style="zoom:67%;" />

<h3 id="对象共享后的可见性——硬件内存视角："><a href="#对象共享后的可见性——硬件内存视角：" class="headerlink" title="对象共享后的可见性——硬件内存视角："></a>对象共享后的可见性——硬件内存视角：</h3><p>如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。</p>
<p>下图描绘了该情况。 在左CPU上运行的一个线程将共享对象复制到其CPU缓存中，并将其count变量更改为2.对于在右边的CPU上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.</p>
<p>要解决此问题，您可以使用Java的volatile关键字。 volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710212935841.png" alt="image-20220710212935841" style="zoom:67%;" />

<h3 id="竞态条件——硬件视角："><a href="#竞态条件——硬件视角：" class="headerlink" title="竞态条件——硬件视角："></a>竞态条件——硬件视角：</h3><p>如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。</p>
<p>如果这些增量是按先后顺序执行的，则变量计数将增加两次并将原始值+ 2写回主存储器。</p>
<p>但是，两个增量同时执行而没有适当的同步。 无论线程A和B中哪一个将其更新后的计数版本写回主存储器，更新的值将仅比原始值高1，尽管有两个增量。</p>
<p>要解决此问题，您可以使用Java synchronized块。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220710221251843.png" alt="image-20220710221251843" style="zoom:67%;" />

<h2 id="3，内存模型详解"><a href="#3，内存模型详解" class="headerlink" title="3，内存模型详解"></a>3，内存模型详解</h2><p><a href="https://pdai.tech/md/java/jvm/java-jvm-jmm.html">https://pdai.tech/md/java/jvm/java-jvm-jmm.html</a>  此处暂时不添加</p>
<h1 id="四，垃圾回收"><a href="#四，垃圾回收" class="headerlink" title="四，垃圾回收"></a>四，垃圾回收</h1><h2 id="1，基础知识"><a href="#1，基础知识" class="headerlink" title="1，基础知识"></a>1，基础知识</h2><h3 id="对象回收："><a href="#对象回收：" class="headerlink" title="对象回收："></a>对象回收：</h3><p>（1）引用计数法：</p>
<p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<p>（2）可达性分析法：</p>
<p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p>
<p>GC Roots一般有：@虚拟机栈中引用的对象；@本地方法栈中引用的对象；@方法区中类静态属性引用的对象；@方法区中常量引用的对象</p>
<p>（3）方法区的回收</p>
<p>方法区主要存放永久代的对象，回收效率不高，所以这里主要是对常量池的回收和对类的卸载。在大量使用反射，动态代理，CGLib等框架动态生成对象以及自定义ClassLoader时需要具备类卸载功能，从而保证不会出现内存溢出</p>
<p>（4）finalize（）</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</p>
<p>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。所以要慎重的使用该方法</p>
<h3 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a>引用类型：</h3><p>（1）强引用</p>
<p>被引用的对象不会被回收，比如使用 new 一个新对象的方式来创建强引用</p>
<p>（2）软引用</p>
<p>被软引用关联的对象只有在内存不够的情况下才会被回收</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712170039353.png" alt="image-20220712170039353" style="zoom:67%;" />

<p>（3）弱引用</p>
<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712170119417.png" alt="image-20220712170119417" style="zoom:67%;" />

<p>（4）虚引用</p>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知</p>
<h3 id="垃圾回收算法："><a href="#垃圾回收算法：" class="headerlink" title="垃圾回收算法："></a>垃圾回收算法：</h3><p>（1）标记-清除</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712170540861.png" alt="image-20220712170540861" style="zoom:67%;" />

<p>将存活的对象进行标记，然后清理掉未被标记的对象。</p>
<p>不足：1）标记和清除效率不高；2）会产生大量不连续的内存碎片，导致无法给大对象分配内存</p>
<p>（2）标记-整理</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712170749902.png" alt="image-20220712170749902" style="zoom:67%;" />

<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p>（3）复制</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712170928522.png" alt="image-20220712170928522" style="zoom:67%;" />

<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半</p>
<p>（4）分代收集</p>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用: 复制算法</li>
<li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h3 id="垃圾收集器："><a href="#垃圾收集器：" class="headerlink" title="垃圾收集器："></a>垃圾收集器：</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712171934330.png" alt="image-20220712171934330" style="zoom:50%;" />

<p>上图是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<p>@单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</p>
<p>@串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
<p>（1）Serial收集器</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712172242803.png" alt="image-20220712172242803"></p>
<p>说明：这是一个单线程的，串行的垃圾收集器。</p>
<p>优点：简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率</p>
<p>缺点：stw时间比较长</p>
<p>（2）ParNew收集器：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712172605208.png" alt="image-20220712172605208" style="zoom: 67%;" />

<p>说明：它是 Serial 收集器的多线程版本。</p>
<p>（3）Parallel Scavenge 收集器</p>
<p>说明：与 ParNew 一样是多线程收集器。但是它的目标是尽可能缩短垃圾收集时用户线程的停顿时间，控制吞吐量（CPU 用于运行用户代码的时间 &#x2F; 总时间）。</p>
<p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>（4）Serial Old 收集器</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220712173525677.png" alt="image-20220712173525677" style="zoom:67%;" />

<p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用</p>
<p>（5）Parallel old</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220713153818731.png" alt="image-20220713153818731"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<p>（6）CMS收集器</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220713154402478.png" alt="image-20220713154402478"></p>
<p>CMS（Concurrent Mark Sweep）是一种标记-清除算法。分为4个步骤：</p>
<p>a，初始标记：这里快速标记一下GC roots直接关联的对象，停顿了</p>
<p>b，并发标记：进行GC roots Tracing，耗时最常，不需要停顿</p>
<p>c，重新标记：上一步中由于程序继续运作导致某些对象的状态发生了变化，再次标记和调整，停顿</p>
<p>d，并发清除：不需要停顿</p>
<p>缺点（这里提几个）：</p>
<p>a，吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</p>
<p>b，无法处理浮动垃圾（指的是并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收），如果浮动垃圾超出了预留的内存，就会导致 Concurrent Mode Failure，虚拟机将临时启用 Serial Old 来替代 CMS。</p>
<p>c，标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC</p>
<p>（7）G1收集器</p>
<p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220713160559628.png" alt="image-20220713160559628" style="zoom: 50%;" />

<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220713163729772.png" alt="image-20220713163729772"></p>
<p>不计算Remembered Set的操作的话，G1的流程如下：</p>
<p>（a）初试标记</p>
<p>（b）并发标记</p>
<p>（c）最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行</p>
<p>（d）筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率</p>
<h3 id="内存分配策略："><a href="#内存分配策略：" class="headerlink" title="内存分配策略："></a>内存分配策略：</h3><p>（1）对象优先在Eden区分配</p>
<p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC</p>
<p>（2）大对象直接分配在老年代</p>
<p>大对象指需要连续存储空间的对象，比如超长数组。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
<p>（3）长期存活的对象直接进入老年代</p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="Full-GC的触发条件："><a href="#Full-GC的触发条件：" class="headerlink" title="Full GC的触发条件："></a>Full GC的触发条件：</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件</p>
<p>（1）调用System.GC()</p>
<p>该方法只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存</p>
<p>（2）老年代空间不足</p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。</p>
<p>除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。</p>
<p>还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<p>（3）Concurrent Mode Failure</p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-5-操作系统</title>
    <url>/2022/04/25/jc-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-6-数据结构</title>
    <url>/2022/04/25/jc-6-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-4-计算机网络</title>
    <url>/2022/04/25/jc-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-3-多线程</title>
    <url>/2022/04/25/jc-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p><strong>简介：</strong>多线程与并发知识整理，尽量精简</p>
<span id="more"></span>

<h1 id="一，理论基础"><a href="#一，理论基础" class="headerlink" title="一，理论基础"></a>一，理论基础</h1><h2 id="1，背景"><a href="#1，背景" class="headerlink" title="1，背景"></a>1，背景</h2><h3 id="1，为什么需要多线程"><a href="#1，为什么需要多线程" class="headerlink" title="1，为什么需要多线程"></a>1，为什么需要多线程</h3><p>CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p>
<p>CPU增加了缓存，以均衡与内存的速度差异——导致了可见性问题</p>
<p>操作系统增加了进程，线程，以分时复用CPU——原子性问题</p>
<p>编译程序优化指令执行次序，使得缓存能够更加合理的利用——有序性问题</p>
<h3 id="2，并发问题的根源"><a href="#2，并发问题的根源" class="headerlink" title="2，并发问题的根源"></a>2，并发问题的根源</h3><p><strong>可见性</strong>：我们需要一个线程对共享变量的修改，另外一个线程能够立刻看到。</p>
<p>然而现实情况是我们的修改很难同步，见下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>CPU1执行线程1，CPU2执行线程2。当xc1执行i &#x3D; 10时，是先把i &#x3D; 0加载到高速缓存中再赋值为10，此时假设 i 的变化还没写到主存中去。</p>
<p>那么xc2执行 j &#x3D; i，此时读取主存的 i 为0。这就是 xc2 由于可见性问题没有立即看到 xc1 的修改</p>
<p><strong>原子性</strong>：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>i +&#x3D; 1 这个操作需要三条CPU指令：</p>
<blockquote>
<p>1，将变量 i 从内存读取到 CPU寄存器；<br>       2，在CPU寄存器中执行 i + 1 操作；<br>       3，将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p>
</blockquote>
<p>由于CPU分时复用（线程切换）的存在，xc1 执行了第一条指令后，就切换到 xc2 执行，假如 xc2 执行了这三条指令后，再切换会 xc1 执行后续两条指令，将造成最后写到内存中的i值是2而不是3</p>
<p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上述代码的第一行和第二行的顺序不一定是固定的，因为可能会发生指令重排序（Instruction Reorder）。</p>
<p>重排序分三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p>源代码–》编译器优化的重排序–》指令级并行的重排序–》内存系统的重排序–》最终执行的指令序列</p>
<p>对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<h3 id="3，JAVA是怎么解决并发问题的-JMM-Java内存模型"><a href="#3，JAVA是怎么解决并发问题的-JMM-Java内存模型" class="headerlink" title="3，JAVA是怎么解决并发问题的: JMM(Java内存模型)"></a>3，JAVA是怎么解决并发问题的: JMM(Java内存模型)</h3><p><strong>第一个维度：核心的几个点</strong></p>
<p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p>
<ul>
<li>volatile、synchronized 和 final 三个关键字</li>
<li>Happens-Before 规则</li>
</ul>
<p><strong>第二个维度：原子性，可见性，有序性</strong></p>
<p><em>原子性：</em></p>
<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。下面的四个语句中，只有语句1是原子操作，也就是说只有<u>简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作</u>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;         <span class="comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;           <span class="comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4： 同语句3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
</blockquote>
<p><em>可见性：</em></p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<blockquote>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
</blockquote>
<p><em>有序性：</em></p>
<p>可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的</p>
<h3 id="4，关键字，volatile，-Sychronized，final"><a href="#4，关键字，volatile，-Sychronized，final" class="headerlink" title="4，关键字，volatile， Sychronized，final"></a>4，关键字，volatile， Sychronized，final</h3><p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p>
<p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html">https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html</a></p>
<p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">https://pdai.tech/md/java/thread/java-thread-x-key-final.html</a></p>
<h3 id="5，Happens-Before"><a href="#5，Happens-Before" class="headerlink" title="5，Happens-Before"></a>5，Happens-Before</h3><h4 id="（1）单一线程原则"><a href="#（1）单一线程原则" class="headerlink" title="（1）单一线程原则"></a>（1）单一线程原则</h4><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<h4 id="（2）管程锁定原则"><a href="#（2）管程锁定原则" class="headerlink" title="（2）管程锁定原则"></a>（2）管程锁定原则</h4><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>
<img src="C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\image-20220810212801692.png" alt="image-20220810212801692" style="zoom:67%;" />

<h4 id="（3）volatile变量规则"><a href="#（3）volatile变量规则" class="headerlink" title="（3）volatile变量规则"></a>（3）volatile变量规则</h4><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<h4 id="（4）线程启动规则"><a href="#（4）线程启动规则" class="headerlink" title="（4）线程启动规则"></a>（4）线程启动规则</h4><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220810213448843.png" alt="image-20220810213448843" style="zoom:67%;" />

<h4 id="（5）线程加入规则"><a href="#（5）线程加入规则" class="headerlink" title="（5）线程加入规则"></a>（5）线程加入规则</h4><p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220810213714334.png" alt="image-20220810213714334" style="zoom:67%;" />

<h4 id="（6）线程中断规则"><a href="#（6）线程中断规则" class="headerlink" title="（6）线程中断规则"></a>（6）线程中断规则</h4><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>
<h4 id="（7）对象终结"><a href="#（7）对象终结" class="headerlink" title="（7）对象终结"></a>（7）对象终结</h4><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</p>
<h4 id="（8）传递性"><a href="#（8）传递性" class="headerlink" title="（8）传递性"></a>（8）传递性</h4><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</p>
<h3 id="6，线程安全不是一个非真即假的命题"><a href="#6，线程安全不是一个非真即假的命题" class="headerlink" title="6，线程安全不是一个非真即假的命题"></a>6，线程安全不是一个非真即假的命题</h3><p>一个类在可以被多个线程安全调用时就是线程安全的。</p>
<p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<h4 id="（1）不可变"><a href="#（1）不可变" class="headerlink" title="（1）不可变"></a>（1）不可变</h4><p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p>
<p>不可变的类型:</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如Long和Double，但是AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<h4 id="（2）绝对线程安全"><a href="#（2）绝对线程安全" class="headerlink" title="（2）绝对线程安全"></a>（2）绝对线程安全</h4><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
<h4 id="（3）相对线程安全"><a href="#（3）相对线程安全" class="headerlink" title="（3）相对线程安全"></a>（3）相对线程安全</h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</p>
<p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>
<p>如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。必须要对删除和访问元素的方法采取限制，比如用Sychronized来进行修饰。</p>
<h4 id="（4）线程兼容"><a href="#（4）线程兼容" class="headerlink" title="（4）线程兼容"></a>（4）线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</p>
<p>Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>
<h4 id="（5）线程对立"><a href="#（5）线程对立" class="headerlink" title="（5）线程对立"></a>（5）线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<h3 id="7，线程安全的实现方法"><a href="#7，线程安全的实现方法" class="headerlink" title="7，线程安全的实现方法"></a>7，线程安全的实现方法</h3><h4 id="（1）互斥同步"><a href="#（1）互斥同步" class="headerlink" title="（1）互斥同步"></a>（1）互斥同步</h4><p><a href="https://pdai.tech/md/java/thread/java-thread-x-thread-basic.html#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5">synchronized 和 ReentrantLock。</a></p>
<h4 id="（2）非阻塞同步"><a href="#（2）非阻塞同步" class="headerlink" title="（2）非阻塞同步"></a>（2）非阻塞同步</h4><p>互斥同步中，线程阻塞和唤醒是有成本的，会造成性能问题。互斥不同是一种悲观的并发策略，它总是认为操作会导致线程问题，所以需要进行上锁，从而导致了线程切换的成本。</p>
<p>随着硬件指令集的发展，我们可以使用<strong>基于冲突检测的乐观并发策略</strong>（不需要线程阻塞，是乐观的）: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。</p>
<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<p><strong>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过</strong>。<a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html">J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference</a> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h4 id="（3）无同步方案"><a href="#（3）无同步方案" class="headerlink" title="（3）无同步方案"></a>（3）无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。有以下几种情况：</p>
<p><strong>栈封闭：</strong></p>
<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的</p>
<p><strong>线程本地存储：</strong></p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 <strong>Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式</strong>，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 <strong>java.lang.ThreadLocal 类来实现线程本地存储功能。</strong><a href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html"> ThreadLocal详解</a></p>
<p><strong>可重入代码：</strong></p>
<p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h1 id="二，线程基础"><a href="#二，线程基础" class="headerlink" title="二，线程基础"></a>二，线程基础</h1><h2 id="1，线程状态转换和方式"><a href="#1，线程状态转换和方式" class="headerlink" title="1，线程状态转换和方式"></a>1，线程状态转换和方式</h2><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220814113109112.png" alt="image-20220814113109112" style="zoom:67%;" />

<h3 id="1，新建："><a href="#1，新建：" class="headerlink" title="1，新建："></a>1，新建：</h3><p>创建后未启动</p>
<h3 id="2，可运行："><a href="#2，可运行：" class="headerlink" title="2，可运行："></a>2，可运行：</h3><p>可能正在运行，也可能在等待CPU时间片</p>
<h3 id="3，阻塞："><a href="#3，阻塞：" class="headerlink" title="3，阻塞："></a>3，阻塞：</h3><p>线程请求一个排它锁，其他线程释放了锁就会结束这个状态</p>
<h3 id="4，无限期等待（Waiting）"><a href="#4，无限期等待（Waiting）" class="headerlink" title="4，无限期等待（Waiting）"></a>4，无限期等待（Waiting）</h3><p>除非其他线程唤醒，否则不会分配时间片</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220814114311195.png" alt="image-20220814114311195" style="zoom: 67%;" />

<h3 id="5，限期等待（Timed-Waiting）"><a href="#5，限期等待（Timed-Waiting）" class="headerlink" title="5，限期等待（Timed  Waiting）"></a>5，限期等待（Timed  Waiting）</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220814114406623.png" alt="image-20220814114406623" style="zoom:67%;" />

<h3 id="6-死亡"><a href="#6-死亡" class="headerlink" title="6.死亡"></a>6.死亡</h3><p>任务结束或者异常</p>
<h2 id="2，线程使用方式"><a href="#2，线程使用方式" class="headerlink" title="2，线程使用方式"></a>2，线程使用方式</h2><p>有三种使用线程的方法:</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；Callable 可以有返回值，返回值通过 FutureTask 进行封装</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过新建一个 Thread 类，然后将实现了接口的类作为参数，使用run()方法来调用。可以说任务是通过线程驱动从而执行的。</p>
<h2 id="3，基础线程机制"><a href="#3，基础线程机制" class="headerlink" title="3，基础线程机制"></a>3，基础线程机制</h2><h3 id="1，Executor"><a href="#1，Executor" class="headerlink" title="1，Executor"></a>1，Executor</h3><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor:</p>
<ul>
<li>CachedThreadPool: 一个任务创建一个线程；</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<h3 id="2，Daemon"><a href="#2，Daemon" class="headerlink" title="2，Daemon"></a>2，Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>使用 setDaemon() 方法将一个线程设置为守护线程</p>
<h3 id="3，sleep"><a href="#3，sleep" class="headerlink" title="3，sleep()"></a>3，sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<h3 id="4-yield"><a href="#4-yield" class="headerlink" title="4,yield()"></a>4,yield()</h3><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<h2 id="4，线程中断"><a href="#4，线程中断" class="headerlink" title="4，线程中断"></a>4，线程中断</h2><h3 id="1，InterruptException"><a href="#1，InterruptException" class="headerlink" title="1，InterruptException"></a>1，InterruptException</h3><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>
<p>比如一个线程在调用sleep()方法休眠时，main方法停止，就会抛出这个异常</p>
<h3 id="2，Interrupted"><a href="#2，Interrupted" class="headerlink" title="2，Interrupted()"></a>2，Interrupted()</h3><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态（ while (!interrupted()) +方法体，来判断线程是否中断了），从而提前结束线程。</p>
<h3 id="3，Executor-的中断操作"><a href="#3，Executor-的中断操作" class="headerlink" title="3，Executor 的中断操作"></a>3，Executor 的中断操作</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法（就直接报InterruptException这个异常了）。</p>
<h2 id="5，线程互斥同步"><a href="#5，线程互斥同步" class="headerlink" title="5，线程互斥同步"></a>5，线程互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h3 id="1，synchronized"><a href="#1，synchronized" class="headerlink" title="1，synchronized"></a>1，synchronized</h3><p><strong>同步一个代码块 &#x2F; 一个方法</strong>：它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该对象中有一个同步代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是new 一个SynchronizedExample对象，则两个线程用这个对象是互斥的；否则不是互斥的</span></span><br></pre></td></tr></table></figure>

<p><strong>同步一个类 &#x2F; 同步一个静态方法</strong>  :不同于上面，这个是作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<h3 id="2，ReentrantLock"><a href="#2，ReentrantLock" class="headerlink" title="2，ReentrantLock"></a>2，ReentrantLock</h3><p>ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="3，两种锁的对比"><a href="#3，两种锁的对比" class="headerlink" title="3，两种锁的对比"></a>3，两种锁的对比</h3><table>
<thead>
<tr>
<th>角度</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>锁的实现</td>
<td>JVM 实现的</td>
<td>JDK 实现的。</td>
</tr>
<tr>
<td>性能（大致相同）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>等待可中断</td>
<td>不可以</td>
<td>可以</td>
</tr>
<tr>
<td>公平锁</td>
<td>不是</td>
<td>默认情况下也是非公平的，但是也可以是公平的</td>
</tr>
<tr>
<td>绑定多个条件</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</p>
<h3 id="4，线程之间的动作"><a href="#4，线程之间的动作" class="headerlink" title="4，线程之间的动作"></a>4，线程之间的动作</h3><p><strong>Join()</strong></p>
<p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p><strong>wait() notify() notifyAll()</strong></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220814160532714.png" alt="image-20220814160532714"></p>
<p><strong>await() signal() signalAll()</strong></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<h1 id="三，Java锁的类型"><a href="#三，Java锁的类型" class="headerlink" title="三，Java锁的类型"></a>三，Java锁的类型</h1><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220815134110295.png" alt="image-20220815134110295" style="zoom:67%;" />

<h2 id="1，乐观锁-VS-悲观锁"><a href="#1，乐观锁-VS-悲观锁" class="headerlink" title="1，乐观锁 VS 悲观锁"></a>1，乐观锁 VS 悲观锁</h2><h3 id="1，概念"><a href="#1，概念" class="headerlink" title="1，概念"></a>1，概念</h3><p>对于同一个数据的并发操作，<strong>悲观锁</strong>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁</p>
<p><strong>乐观锁</strong>认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<h3 id="2，实现"><a href="#2，实现" class="headerlink" title="2，实现"></a>2，实现</h3><ul>
<li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li>
<li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure>

<h3 id="3，关联知识"><a href="#3，关联知识" class="headerlink" title="3，关联知识"></a>3，关联知识</h3><p><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html">https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html</a></p>
<h2 id="2，自旋锁-VS-自适应自旋锁"><a href="#2，自旋锁-VS-自适应自旋锁" class="headerlink" title="2，自旋锁 VS 自适应自旋锁"></a>2，自旋锁 VS 自适应自旋锁</h2><h3 id="1，预备知识"><a href="#1，预备知识" class="headerlink" title="1，预备知识"></a>1，预备知识</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失</p>
<p>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁</p>
<h3 id="2，概念"><a href="#2，概念" class="headerlink" title="2，概念"></a>2，概念</h3><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<h3 id="3，关联知识-1"><a href="#3，关联知识-1" class="headerlink" title="3，关联知识"></a>3，关联知识</h3><p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81</a></p>
<h2 id="3，无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3，无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3，无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3，无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><h3 id="1，概念-1"><a href="#1，概念-1" class="headerlink" title="1，概念"></a>1，概念</h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>
<h3 id="2，实现-1"><a href="#2，实现-1" class="headerlink" title="2，实现"></a>2，实现</h3><p>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<p>具体参看：<a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B</a></p>
<h2 id="4，公平锁-VS-非公平锁"><a href="#4，公平锁-VS-非公平锁" class="headerlink" title="4，公平锁 VS 非公平锁"></a>4，公平锁 VS 非公平锁</h2><h3 id="1，概念-2"><a href="#1，概念-2" class="headerlink" title="1，概念"></a>1，概念</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p>
<h3 id="2，优缺点："><a href="#2，优缺点：" class="headerlink" title="2，优缺点："></a>2，优缺点：</h3><p>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h3 id="3，关联知识-2"><a href="#3，关联知识-2" class="headerlink" title="3，关联知识"></a>3，关联知识</h3><p><a href="https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html">https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html</a></p>
<h2 id="5，可重入锁-VS-非可重入锁"><a href="#5，可重入锁-VS-非可重入锁" class="headerlink" title="5，可重入锁 VS 非可重入锁"></a>5，可重入锁 VS 非可重入锁</h2><h3 id="1，概念-3"><a href="#1，概念-3" class="headerlink" title="1，概念"></a>1，概念</h3><p><strong>可重入锁</strong>又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁</p>
<p>可重入锁的一个优点是可一定程度避免死锁（一个对象获取到了锁，第一个方法使用了锁，另个一方法想获取锁时，对象无法释放锁，另一个方法无法获取锁）</p>
<p>以打水为例，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。</p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<h3 id="2，实现-2"><a href="#2，实现-2" class="headerlink" title="2，实现"></a>2，实现</h3><p>ReentrantLock和synchronized都是重入锁，NonReentrantLock是非可重入锁。我们可以用这两个的源码来了解两者的不同</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status &#x3D;&#x3D; 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status !&#x3D; 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status !&#x3D; 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 &#x3D;&#x3D; 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220815143105555.png" alt="image-20220815143105555" style="zoom:67%;" />

<h3 id="6，独享锁（排它锁）-VS-共享锁"><a href="#6，独享锁（排它锁）-VS-共享锁" class="headerlink" title="6，独享锁（排它锁） VS 共享锁"></a>6，独享锁（排它锁） VS 共享锁</h3><h3 id="1，概念-4"><a href="#1，概念-4" class="headerlink" title="1，概念"></a>1，概念</h3><p><strong>独享锁也叫排他锁</strong>，是指该锁一次只能被一个线程所持有。<strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<h3 id="2，实现-3"><a href="#2，实现-3" class="headerlink" title="2，实现"></a>2，实现</h3><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h1 id="四，关键字：synchronized详解"><a href="#四，关键字：synchronized详解" class="headerlink" title="四，关键字：synchronized详解"></a>四，关键字：synchronized详解</h1><h2 id="1，使用"><a href="#1，使用" class="headerlink" title="1，使用"></a>1，使用</h2><p>3个注意点：</p>
<ul>
<li>一把锁同时被一个线程获取，没有获取的线程只能等待</li>
<li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响（例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁）</li>
<li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li>
</ul>
<h3 id="1，对象锁"><a href="#1，对象锁" class="headerlink" title="1，对象锁"></a>1，对象锁</h3><p><strong>代码块形式：手动指定锁定对象，可以是this，也可以是其他对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//================================================================================================</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    Object block1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object block2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方法锁形式：synchronized修饰普通方法，锁对象默认为this</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，类锁"><a href="#2，类锁" class="headerlink" title="2，类锁"></a>2，类锁</h3><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p>
<p><strong>synchronized修饰静态方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence1 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence2 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized指定锁对象为Class对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence1 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line">    <span class="keyword">static</span> SynchronizedObjectLock instence2 = <span class="keyword">new</span> SynchronizedObjectLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有线程需要的锁都是同一把</span></span><br><span class="line">        <span class="keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(instence1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2，synchronized原理分析"><a href="#2，synchronized原理分析" class="headerlink" title="2，synchronized原理分析"></a>2，synchronized原理分析</h2><h3 id="1，加锁和释放锁的原理"><a href="#1，加锁和释放锁的原理" class="headerlink" title="1，加锁和释放锁的原理"></a>1，加锁和释放锁的原理</h3><p>对于一段有Sychronized的代码，可以用javac命令编译获得.class文件，然后用javap命令反编译查看.class文件，此时会得到代码执行的字节码（如下图）</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220820155949017.png" alt="image-20220820155949017" style="zoom: 80%;" />

<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p>
<ul>
<li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li>
<li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li>
<li>这把锁已经被别的线程获取了，等待锁释放</li>
</ul>
<p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220820163617816.png" alt="image-20220820163617816" style="zoom:80%;" />

<p>该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器</p>
<h3 id="2，可重入原理："><a href="#2，可重入原理：" class="headerlink" title="2，可重入原理："></a>2，可重入原理：</h3><p><strong>可重入</strong>：若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。</p>
<p><strong>可重入锁</strong>：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedDemo demo =  <span class="keyword">new</span> SynchronizedDemo();</span><br><span class="line">        demo.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + <span class="string">&quot;: method1()&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+ <span class="string">&quot;: method2()&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+ <span class="string">&quot;: method3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结合前文中加锁和释放锁的原理，不难理解： 执行monitorenter获取锁</span></span><br><span class="line"><span class="comment">//（monitor计数器=0，可获取锁） 执行method1()方法，monitor计数器+1 -&gt; 1 （获取到锁） 执行method2()方法，monitor计数器+1 -&gt; 2 执行method3()方法，monitor计数器+1 -&gt; 3 执行monitorexit命令</span></span><br><span class="line"><span class="comment">//method3()方法执行完，monitor计数器-1 -&gt; 2 method2()方法执行完，monitor计数器-1 -&gt; 1 method2()方法执行完，monitor计数器-1 -&gt; 0 （释放了锁） （monitor计数器=0，锁被释放了）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是Synchronized的重入性，即在<strong>同一锁程</strong>中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。</p>
<h3 id="3，保证可见性的原理"><a href="#3，保证可见性的原理" class="headerlink" title="3，保证可见性的原理"></a>3，保证可见性的原理</h3><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220820172149219.png" alt="image-20220820172149219" style="zoom:67%;" />

<p>黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。也就是线程A执行的结果对线程B一定可见。</p>
<h3 id="3，JVM中锁的优化"><a href="#3，JVM中锁的优化" class="headerlink" title="3，JVM中锁的优化"></a>3，JVM中锁的优化</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220820172828672.png" alt="image-20220820172828672" style="zoom:80%;" />

<p>这里补充说明<strong>自适应自旋锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                                             背景</span><br><span class="line">在多线程竞争Synchronized锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。</span><br><span class="line">  同时共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。</span><br><span class="line">为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。在JDK1<span class="number">.6</span>之前，自旋锁默认的自旋次数为<span class="number">10</span>次，用户可以使用参数-XX:PreBlockSpin来更改。可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。</span><br><span class="line"></span><br><span class="line">                                         自适应自旋锁</span><br><span class="line">在JDK <span class="number">1.6</span>中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。</span><br><span class="line">   如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到<span class="number">100</span>此循环。</span><br><span class="line">   相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明</span><br></pre></td></tr></table></figure>

<h2 id="3，Synchronized和Lock比较"><a href="#3，Synchronized和Lock比较" class="headerlink" title="3，Synchronized和Lock比较"></a>3，Synchronized和Lock比较</h2><h3 id="1，Synchronized的缺陷"><a href="#1，Synchronized的缺陷" class="headerlink" title="1，Synchronized的缺陷"></a>1，Synchronized的缺陷</h3><p><strong>效率低</strong>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时</p>
<p><strong>不够灵活</strong>：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活</p>
<p><strong>无法知道是否成功获得锁</strong>：相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，….</p>
<h3 id="2，Lock能解决的问题："><a href="#2，Lock能解决的问题：" class="headerlink" title="2，Lock能解决的问题："></a>2，Lock能解决的问题：</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821154904194.png" alt="image-20220821154904194" style="zoom:67%;" />

<p>synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活；synchronized中多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。</p>
<p><code>Condition与Lock的结合</code>可以灵活设置条件；ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断，一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待</p>
<h3 id="3，总结："><a href="#3，总结：" class="headerlink" title="3，总结："></a>3，总结：</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821155120807.png" alt="image-20220821155120807" style="zoom:80%;" />

<h1 id="五，关键字：Volatile详解"><a href="#五，关键字：Volatile详解" class="headerlink" title="五，关键字：Volatile详解"></a>五，关键字：Volatile详解</h1><h2 id="1，作用"><a href="#1，作用" class="headerlink" title="1，作用"></a>1，作用</h2><h3 id="1，防止重排序"><a href="#1，防止重排序" class="headerlink" title="1，防止重排序"></a>1，防止重排序</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821155511650.png" alt="image-20220821155511650" style="zoom:80%;" />

<p>一个经典的例子是实现单例模式时，我们需要对singleton进行重排序限制。理由如下：</p>
<ul>
<li>实例化对象分为三步：（1）分配内存空间；（2）初始化对象；（3）将内存空间的地址赋值给对应的引用，此时singleton能指向一个单例</li>
<li>由于操作系统可以对指令进行重排序，那么上述步骤可能变为：（1）分配内存空间；（2）将内存空间的地址赋值给对应的引用；（3）初始化对象。此时多线程下，singleton可能会指向一个空的地址，没有对象。</li>
</ul>
<h3 id="2，实现可见性"><a href="#2，实现可见性" class="headerlink" title="2，实现可见性"></a>2，实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile能保证一个变量在改变后，能及时更新到主内存中，而一个线程想操作这个变量时，必须去主内存中取</p>
<h3 id="3，保证原子性：单次读-x2F-写"><a href="#3，保证原子性：单次读-x2F-写" class="headerlink" title="3，保证原子性：单次读&#x2F;写"></a>3，保证原子性：单次读&#x2F;写</h3><ul>
<li>注意不能保证 i++ 这种操作的原子性，因为这本质上包含三个动作：读取i的值；对i加1；将i的值写回内存</li>
<li>另外共享的long和double需要用volatile修饰，因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。</li>
</ul>
<h2 id="2，实现原理"><a href="#2，实现原理" class="headerlink" title="2，实现原理"></a>2，实现原理</h2><h3 id="1，可见性实现"><a href="#1，可见性实现" class="headerlink" title="1，可见性实现"></a>1，可见性实现</h3><p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821163252855.png" alt="image-20220821163252855"></p>
<p>进一步，编译后volatile修饰的变量在进行写操作时会生成lock 前缀的指令，在多核处理器下会引发两件事情:</p>
<ul>
<li><p>将当前处理器缓存行的数据写回到系统内存。</p>
</li>
<li><p>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效（<u>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改</u>，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里）</p>
</li>
</ul>
<h3 id="2，有序性实现"><a href="#2，有序性实现" class="headerlink" title="2，有序性实现"></a>2，有序性实现</h3><p><strong>happens-before 关系</strong></p>
<p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。如下如，能保证当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821164913466.png" alt="image-20220821164913466" style="zoom:80%;" />

<p><strong>volatile禁止重排序：</strong></p>
<p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。Java 编译器会在生成指令系列时在适当的位置会<u>插入内存屏障指令来禁止特定类型的处理器重排序。</u></p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821172712502.png" alt="image-20220821172712502"></p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821172724210.png" alt="image-20220821172724210" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821172741794.png" alt="image-20220821172741794" style="zoom:50%;" />

<h2 id="3，应用场景"><a href="#3，应用场景" class="headerlink" title="3，应用场景"></a>3，应用场景</h2><p>使用 volatile 必须具备的条件</p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
<li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li>
</ul>
<h3 id="模式1：状态标志"><a href="#模式1：状态标志" class="headerlink" title="模式1：状态标志"></a>模式1：状态标志</h3><p>也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p>
<h3 id="模式2：独立观察-independent-observation"><a href="#模式2：独立观察-independent-observation" class="headerlink" title="模式2：独立观察(independent observation)"></a>模式2：独立观察(independent observation)</h3><p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821173130224.png" alt="image-20220821173130224"></p>
<h3 id="模式3：双重检查-double-checked"><a href="#模式3：双重检查-double-checked" class="headerlink" title="模式3：双重检查(double-checked)"></a>模式3：双重检查(double-checked)</h3><p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220821173159432.png" alt="image-20220821173159432"></p>
<h1 id="六，关键字：final详解"><a href="#六，关键字：final详解" class="headerlink" title="六，关键字：final详解"></a>六，关键字：final详解</h1><h2 id="1，基础使用"><a href="#1，基础使用" class="headerlink" title="1，基础使用"></a>1，基础使用</h2><h3 id="1，修饰类"><a href="#1，修饰类" class="headerlink" title="1，修饰类"></a>1，修饰类</h3><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。（此时这个类中的所有方法都是隐式的加上final的）</p>
<h3 id="2，修饰方法"><a href="#2，修饰方法" class="headerlink" title="2，修饰方法"></a>2，修饰方法</h3><p> <strong>private final：</strong></p>
<p>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。（子类不能获取的父类的final方法）</p>
<p><strong>final方法可以被重载</strong></p>
<h3 id="3，修饰参数"><a href="#3，修饰参数" class="headerlink" title="3，修饰参数"></a>3，修饰参数</h3><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>
<h3 id="4，修饰变量"><a href="#4，修饰变量" class="headerlink" title="4，修饰变量"></a>4，修饰变量</h3><p><strong>final修饰的字段不一定是编译器常量：</strong></p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822143624169.png" alt="image-20220822143624169" style="zoom: 80%;" />

<p><strong>static final：</strong></p>
<p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822143729932.png" alt="image-20220822143729932" style="zoom: 80%;" />

<p><strong>blank final：</strong></p>
<p>Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：</p>
<ul>
<li>在定义处进行赋值(这不叫空白final)</li>
<li>在构造器中进行赋值，保证了该值在被使用前赋值。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822143955534.png" alt="image-20220822143955534" style="zoom: 80%;" />

<h2 id="2，final-域重排序规则"><a href="#2，final-域重排序规则" class="headerlink" title="2，final 域重排序规则"></a>2，final 域重排序规则</h2><h3 id="1，final域为基本数据类型"><a href="#1，final域为基本数据类型" class="headerlink" title="1，final域为基本数据类型"></a>1，final域为基本数据类型</h3><p><strong>写final域的重排序规则：</strong></p>
<p>禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>
<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>篇幅影响，简单理解，假设final修饰的变量x如果是基本类型数据并且在一个构造函数内赋值。那么多线程情况下，某个线程在获取变量x时一定是能获得一个有值的x，而不是获得一个空值x。详见：<a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">https://pdai.tech/md/java/thread/java-thread-x-key-final.html</a></p>
<p><strong>读final域的重排序规则：</strong></p>
<p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</p>
<p>篇幅影响，简单理解，假设final修饰的变量x如果是基本类型数据并且在一个构造函数内赋值。那么多线程情况下，某个线程在获取变量x时一定是能获得一个有值的x，而在普通变量时，可能获取的就是一个空值。详见：<a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">https://pdai.tech/md/java/thread/java-thread-x-key-final.html</a></p>
<h3 id="2，final域为引用类型"><a href="#2，final域为引用类型" class="headerlink" title="2，final域为引用类型"></a>2，final域为引用类型</h3><p> <strong>对final修饰的对象的成员域写操作</strong>：</p>
<p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p>
<p> <strong>对final修饰的对象的成员域读操作</strong>：这里要看原文</p>
<p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>
<h3 id="3，重排序总结"><a href="#3，重排序总结" class="headerlink" title="3，重排序总结"></a>3，重排序总结</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822152746419.png" alt="image-20220822152746419" style="zoom:80%;" />



<h2 id="3，final再深入理解"><a href="#3，final再深入理解" class="headerlink" title="3，final再深入理解"></a>3，final再深入理解</h2><h3 id="1，final引用不能从构造函数逸出"><a href="#1，final引用不能从构造函数逸出" class="headerlink" title="1，final引用不能从构造函数逸出"></a>1，final引用不能从构造函数逸出</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822153223112.png" alt="image-20220822153223112" style="zoom:80%;" />

<p>上图中，如果一个线程先执行了2，那么另一个线程在执行reader方法时，会获得一个没有赋值的a。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题</p>
<h3 id="2，使用final的限制条件和局限性"><a href="#2，使用final的限制条件和局限性" class="headerlink" title="2，使用final的限制条件和局限性"></a>2，使用final的限制条件和局限性</h3><p>首先，一个final类型的成员变量，必须在定义时赋值，或者在构造函数退出之前赋值</p>
<p>其次，final类型引用的对象，对象本身的值是可以变的，但是引用不能指向其他的对象</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220822154352201.png" alt="image-20220822154352201" style="zoom:80%;" />



<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="七，JUC类总体概览和学习导览"><a href="#七，JUC类总体概览和学习导览" class="headerlink" title="七，JUC类总体概览和学习导览"></a>七，JUC类总体概览和学习导览</h1><p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220823154909785.png" alt="image-20220823154909785"></p>
<p>JUC类分为5大部分，我们根据特点分为以下4个学习的模块，括号里是重点</p>
<ul>
<li>Lock框架和Tools类（Condition,Lock,ReadWriteLock接口； CountDownLatch，Semaphore工具类）</li>
<li>Collections: 并发集合（ConcurrentHashMap）</li>
<li>Atomic: 原子类（AtomicBoolean，AtomicInteger，AtomicLong三个类）</li>
<li>Executors: 线程池（ThreadPoolExecutor ，ScheduledThreadExecutor，FutureTask，Executor）</li>
</ul>
<h2 id="1，Lock框架和Tools类"><a href="#1，Lock框架和Tools类" class="headerlink" title="1，Lock框架和Tools类"></a>1，Lock框架和Tools类</h2><table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>接口: Condition</td>
<td>Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。</td>
</tr>
<tr>
<td>接口: Lock</td>
<td>Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。</td>
</tr>
<tr>
<td>接口: ReadWriteLock</td>
<td>ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的</td>
</tr>
<tr>
<td>抽象类: AbstractOwnableSynchonizer</td>
<td></td>
</tr>
<tr>
<td>抽象类(long): AbstractQueuedLongSynchronizer</td>
<td></td>
</tr>
<tr>
<td>核心抽象类(int): AbstractQueuedSynchonizer</td>
<td>AbstractQueuedSynchonizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。</td>
</tr>
<tr>
<td>锁常用类: LockSupport</td>
<td></td>
</tr>
<tr>
<td>锁常用类: ReentrantLock</td>
<td>ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</td>
</tr>
<tr>
<td>锁常用类: ReentrantReadWriteLock</td>
<td></td>
</tr>
<tr>
<td>锁常用类: StampedLock</td>
<td></td>
</tr>
<tr>
<td>工具常用类: CountDownLatch</td>
<td>CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</td>
</tr>
<tr>
<td>工具常用类: CyclicBarrier</td>
<td></td>
</tr>
<tr>
<td>工具常用类: Phaser</td>
<td></td>
</tr>
<tr>
<td>工具常用类: Semaphore</td>
<td>Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</td>
</tr>
<tr>
<td>工具常用类: Exchanger</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2，Collections-并发集合"><a href="#2，Collections-并发集合" class="headerlink" title="2，Collections: 并发集合"></a>2，Collections: 并发集合</h2><table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Queue: ArrayBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: LinkedBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: LinkedBlockingDeque</td>
<td></td>
</tr>
<tr>
<td>Queue: ConcurrentLinkedQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: ConcurrentLinkedDeque</td>
<td></td>
</tr>
<tr>
<td>Queue: DelayQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: PriorityBlockingQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: SynchronousQueue</td>
<td></td>
</tr>
<tr>
<td>Queue: LinkedTransferQueue</td>
<td></td>
</tr>
<tr>
<td>List: CopyOnWriteArrayList</td>
<td></td>
</tr>
<tr>
<td>Set: CopyOnWriteArraySet</td>
<td></td>
</tr>
<tr>
<td>Set: ConcurrentSkipListSet</td>
<td></td>
</tr>
<tr>
<td>Map: ConcurrentHashMap</td>
<td>是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。</td>
</tr>
<tr>
<td>Map: ConcurrentSkipListMap</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3，Atomic：原子类"><a href="#3，Atomic：原子类" class="headerlink" title="3，Atomic：原子类"></a>3，Atomic：原子类</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>基础类型：AtomicBoolean，AtomicInteger，AtomicLong</td>
<td>AtomicBoolean，AtomicInteger，AtomicLong是类似的，分别针对bool，interger，long的原子类。</td>
</tr>
<tr>
<td>数组：AtomicIntegerArray，AtomicLongArray，BooleanArray</td>
<td>AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray是数组原子类。</td>
</tr>
<tr>
<td>引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference</td>
<td></td>
</tr>
<tr>
<td>FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4，Excutors：线程池"><a href="#4，Excutors：线程池" class="headerlink" title="4，Excutors：线程池"></a>4，Excutors：线程池</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>接口: Executor</td>
<td>Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。</td>
</tr>
<tr>
<td>ScheduledExecutorService</td>
<td></td>
</tr>
<tr>
<td>AbstractExecutorService</td>
<td></td>
</tr>
<tr>
<td>FutureTask</td>
<td>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行</td>
</tr>
<tr>
<td>核心: ThreadPoolExecutor</td>
<td>ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。</td>
</tr>
<tr>
<td>核心: ScheduledThreadExecutor</td>
<td></td>
</tr>
<tr>
<td>核心: Fork&#x2F;Join框架</td>
<td></td>
</tr>
<tr>
<td>工具类: Executors</td>
<td>Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。 ¶ 参考文章</td>
</tr>
</tbody></table>
<h1 id="八，JUC原子类-CAS-Unsafe和原子类详解"><a href="#八，JUC原子类-CAS-Unsafe和原子类详解" class="headerlink" title="八，JUC原子类: CAS, Unsafe和原子类详解"></a>八，JUC原子类: CAS, Unsafe和原子类详解</h1><h2 id="1，CAS"><a href="#1，CAS" class="headerlink" title="1，CAS"></a>1，CAS</h2><p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220823172349595.png" alt="image-20220823172349595"></p>
<h3 id="1，什么是CAS"><a href="#1，什么是CAS" class="headerlink" title="1，什么是CAS"></a>1，什么是CAS</h3><p>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p>
<p>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。</p>
<h3 id="2，CAS问题"><a href="#2，CAS问题" class="headerlink" title="2，CAS问题"></a>2，CAS问题</h3><p><strong>ABA问题：</strong></p>
<p>一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p>
<p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p><strong>循环时间长开销大：</strong></p>
<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p><strong>只能保证一个共享变量的原子操作：</strong></p>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<h2 id="2，Unsafe类"><a href="#2，Unsafe类" class="headerlink" title="2，Unsafe类"></a>2，Unsafe类</h2><h3 id="1，简介"><a href="#1，简介" class="headerlink" title="1，简介"></a>1，简介</h3><p>java中的原子类就是通过UnSafe类实现的，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但是很容易导致程序出错，需要谨慎使用。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220823195647273.png" alt="image-20220823195647273"></p>
<h3 id="2，Unsafe与CAS"><a href="#2，Unsafe与CAS" class="headerlink" title="2，Unsafe与CAS"></a>2，Unsafe与CAS</h3><p>Unsafe中，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法</p>
<h3 id="3，Unsafe底层"><a href="#3，Unsafe底层" class="headerlink" title="3，Unsafe底层"></a>3，Unsafe底层</h3><p>这里不做具体了解</p>
<h3 id="4，Unsafe其他功能"><a href="#4，Unsafe其他功能" class="headerlink" title="4，Unsafe其他功能"></a>4，Unsafe其他功能</h3><p>Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p>
<p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></p>
<h2 id="3，AtomicInteger（其他原子类也类似）"><a href="#3，AtomicInteger（其他原子类也类似）" class="headerlink" title="3，AtomicInteger（其他原子类也类似）"></a>3，AtomicInteger（其他原子类也类似）</h2><h3 id="1，使用-1"><a href="#1，使用-1" class="headerlink" title="1，使用"></a>1，使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>：获取当前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span>：获取当前的值，并设置新的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>：获取当前的值，并自增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span>：获取当前的值，并自减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span>：获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span>: 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<h3 id="2，源码"><a href="#2，源码" class="headerlink" title="2，源码"></a>2，源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们可以看到 AtomicInteger 底层用的是<span class="keyword">volatile</span>的变量和CAS来进行更改数据的。 </span><br><span class="line">    <span class="keyword">volatile</span>保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值 </span><br><span class="line">    CAS 保证数据更新的原子性</span><br></pre></td></tr></table></figure>



<h3 id="4，AtomicStampedReference解决CAS的ABA问题"><a href="#4，AtomicStampedReference解决CAS的ABA问题" class="headerlink" title="4，AtomicStampedReference解决CAS的ABA问题"></a>4，AtomicStampedReference解决CAS的ABA问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;  <span class="comment">//维护对象引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//用于标志版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * expectedReference ：更新之前的原始值</span></span><br><span class="line"><span class="comment">      * newReference : 将要更新的新值</span></span><br><span class="line"><span class="comment">      * expectedStamp : 期待更新的标志版本</span></span><br><span class="line"><span class="comment">      * newStamp : 将要更新的标志版本</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前的(元素值，版本号)对</span></span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 引用没变</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 版本号没变</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            <span class="comment">// 新引用等于旧引用</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">            <span class="comment">// 新版本号等于旧版本号</span></span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            <span class="comment">// 构造新的Pair对象并CAS更新</span></span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用</span></span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果元素值和版本号都没有变化，并且和新的也相同，返回true；</li>
<li>如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。</li>
</ul>
<p>以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。</p>
<ul>
<li>首先，使用版本号控制；</li>
<li>其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；</li>
<li>最后，外部传入元素值及版本号，而不是节点(Pair)的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个使用举例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">        <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,初始值 a = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">        <span class="keyword">int</span> stamp = atomicStampedRef.getStamp(); <span class="comment">//获取当前标识别</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待1秒 ，以便让干扰线程执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isCASSuccess = atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,stamp,stamp +<span class="number">1</span>);  <span class="comment">//此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败</span></span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,CAS操作结果: &quot;</span> + isCASSuccess);</span><br><span class="line">    &#125;,<span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        Thread.yield(); <span class="comment">// 确保thread-main 优先执行</span></span><br><span class="line">atomicStampedRef.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,【increment】 ,值 = &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">        atomicStampedRef.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() +<span class="string">&quot;,【decrement】 ,值 = &quot;</span>+ atomicStampedRef.getReference());</span><br><span class="line">    &#125;,<span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    main.start();</span><br><span class="line">    other.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&gt; 操作线程Thread[主操作线程,<span class="number">5</span>,main],初始值 a = <span class="number">2</span></span><br><span class="line">&gt; 操作线程Thread[干扰线程,<span class="number">5</span>,main],【increment】 ,值 = <span class="number">2</span></span><br><span class="line">&gt; 操作线程Thread[干扰线程,<span class="number">5</span>,main],【decrement】 ,值 = <span class="number">1</span></span><br><span class="line">&gt; 操作线程Thread[主操作线程,<span class="number">5</span>,main],CAS操作结果: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>





<h1 id="九，-JUC锁-锁核心类AQS详解"><a href="#九，-JUC锁-锁核心类AQS详解" class="headerlink" title="九， JUC锁: 锁核心类AQS详解"></a>九， JUC锁: 锁核心类AQS详解</h1><h2 id="1，认识AQS"><a href="#1，认识AQS" class="headerlink" title="1，认识AQS"></a>1，认识AQS</h2><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS使用一个int成员变量state（用volatile修饰）来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<h2 id="2，AQS对资源的共享方式"><a href="#2，AQS对资源的共享方式" class="headerlink" title="2，AQS对资源的共享方式"></a>2，AQS对资源的共享方式</h2><p>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
<p>Share(共享)：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore等</p>
<h2 id="3，AQS使用了模板方法模式"><a href="#3，AQS使用了模板方法模式" class="headerlink" title="3，AQS使用了模板方法模式"></a>3，AQS使用了模板方法模式</h2><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">有下面这些模板方法</span><br><span class="line">    </span><br><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<h2 id="4，-AbstractQueuedSynchronizer数据结构"><a href="#4，-AbstractQueuedSynchronizer数据结构" class="headerlink" title="4， AbstractQueuedSynchronizer数据结构"></a>4， AbstractQueuedSynchronizer数据结构</h2><p>AbstractQueuedSynchronizer类底层的数据结构是使用<code>CLH(Craig,Landin,and Hagersten)队列</code>是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。</p>
<p>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。</p>
<p>而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824145609807.png" alt="image-20220824145609807"></p>
<h2 id="5，源码分析"><a href="#5，源码分析" class="headerlink" title="5，源码分析"></a>5，源码分析</h2><p>类的继承关系，Node类，ConditionObject类，类的属性这些源码，这里不展示，具体在：<a href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90</a></p>
<p>主要说明一下两个方法</p>
<h3 id="1，acquire方法"><a href="#1，acquire方法" class="headerlink" title="1，acquire方法"></a>1，acquire方法</h3><p>该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下，流程是下图:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824153047365.png" alt="image-20220824153047365"></p>
<p>addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq方法插入队列中，enq方法会使用无限循环来确保节点的成功插入。</p>
<p>接着，再来看acquireQueued方法的整个的逻辑。逻辑如下:</p>
<ul>
<li><p>判断结点的前驱是否为head并且是否成功获取(资源)。</p>
</li>
<li><p>若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。</p>
</li>
<li><p>若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。</p>
</li>
<li><p>若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。</p>
</li>
</ul>
<h3 id="2，release方法"><a href="#2，release方法" class="headerlink" title="2，release方法"></a>2，release方法</h3><p>以独占的方式释放对象，流程和之前类似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">        <span class="comment">// 保存头节点</span></span><br><span class="line">        Node h = head; </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头节点不为空并且头节点状态不为0</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头节点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6，AbstractQueuedSynchronizer示例详解一"><a href="#6，AbstractQueuedSynchronizer示例详解一" class="headerlink" title="6，AbstractQueuedSynchronizer示例详解一"></a>6，AbstractQueuedSynchronizer示例详解一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchonizerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, lock);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, lock);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设运行顺序是这样的：首先线程t1先执行lock.lock操作，然后t2执行lock.lock操作，然后t1执行lock.unlock操作，最后t2执行lock.unlock操作。基于这样的时序，分析AbstractQueuedSynchronizer内部的工作机制。</p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824164844037.png" alt="image-20220824164844037"></p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824164855105.png" alt="image-20220824164855105"></p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824164906822.png" alt="image-20220824164906822"></p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824164917486.png" alt="image-20220824164917486"></p>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824164932164.png" alt="image-20220824164932164"></p>
<h2 id="7，总结"><a href="#7，总结" class="headerlink" title="7，总结"></a>7，总结</h2><p>对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。</p>
<ul>
<li>每一个结点都是由前一个结点唤醒</li>
<li>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。</li>
<li>condition queue中的结点向sync queue中转移是通过signal操作完成的。</li>
<li>当结点的状态为SIGNAL时，表示后面的结点需要运行。</li>
</ul>
<h1 id="十，JUC锁-ReentrantLock详解"><a href="#十，JUC锁-ReentrantLock详解" class="headerlink" title="十，JUC锁: ReentrantLock详解"></a>十，JUC锁: ReentrantLock详解</h1><h2 id="1，结构和内部类"><a href="#1，结构和内部类" class="headerlink" title="1，结构和内部类"></a>1，结构和内部类</h2><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824172109221.png" alt="image-20220824172109221" style="zoom:67%;" />

<p>ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p>
<h3 id="1，Sync类"><a href="#1，Sync类" class="headerlink" title="1，Sync类"></a>1，Sync类</h3><p>关注红框中的三个方法</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824172357746.png" alt="image-20220824172357746" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">著作权归https:<span class="comment">//pdai.tech所有。</span></span><br><span class="line">链接：https:<span class="comment">//pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非公平方式获取</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 表示没有线程正在竞争该锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 比较并设置状态成功，状态0表示锁没有被占用</span></span><br><span class="line">                <span class="comment">// 设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current); </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程拥有该锁</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 增加重入次数</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(nextc); </span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">// 当前线程不为独占线程</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="comment">// 释放标识</span></span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 已经释放，清空独占</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置标识</span></span><br><span class="line">        setState(c); </span><br><span class="line">        <span class="keyword">return</span> free; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断资源是否被当前线程占有</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">	。。。。。。</span><br><span class="line">&#125;　　</span><br></pre></td></tr></table></figure>

<h3 id="2，NonfairSync类"><a href="#2，NonfairSync类" class="headerlink" title="2，NonfairSync类"></a>2，NonfairSync类</h3><p>lock方法中尝试获取锁，不管其他线程。acquire方法，会尝试获取锁，如果获取锁失败，就创建一个该线程的等待节点插入到AQS队列的尾部，并阻塞当前线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 比较并设置状态成功，状态0表示锁没有被占用</span></span><br><span class="line">            <span class="comment">// 把当前线程设置独占了锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 锁已经被占用，或者set失败</span></span><br><span class="line">            <span class="comment">// 以独占模式获取对象，忽略中断</span></span><br><span class="line">            acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="3，FairSyn类"><a href="#3，FairSyn类" class="headerlink" title="3，FairSyn类"></a>3，FairSyn类</h3><p>跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。其中，FairSync类的lock的方法调用如下，只给出了主要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以独占模式获取对象，忽略中断</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// 尝试公平获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 状态为0</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 不存在已经等待更久的线程并且比较并且设置状态成功</span></span><br><span class="line">                <span class="comment">// 设置当前线程独占</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 状态不为0，即资源已经被线程占据</span></span><br><span class="line">            <span class="comment">// 下一个状态</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 超过了int的表示范围</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220824174131751.png" alt="image-20220824174131751"></p>
<h2 id="2，类的属性"><a href="#2，类的属性" class="headerlink" title="2，类的属性"></a>2，类的属性</h2><p>ReentrantLock类的sync非常重要，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。（private final Sync sync;  作为类的全局变量使用）</p>
<h2 id="3，类的构造函数"><a href="#3，类的构造函数" class="headerlink" title="3，类的构造函数"></a>3，类的构造函数</h2><ul>
<li>ReentrantLock()型构造函数——这个默认是采用非公平策略</li>
<li>ReentrantLock(boolean)型构造函数——参数为true表示公平策略，否则，采用非公平策略:</li>
</ul>
<h2 id="4，核心函数分析"><a href="#4，核心函数分析" class="headerlink" title="4，核心函数分析"></a>4，核心函数分析</h2><p>通过分析ReentrantLock的源码，可知对其操作都转化为对Sync对象的操作，由于Sync继承了AQS，所以基本上都可以转化为对AQS的操作。</p>
<p>如将ReentrantLock的lock函数转化为对Sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到Sync的不同子类。</p>
<h2 id="5，示例分析"><a href="#5，示例分析" class="headerlink" title="5，示例分析"></a>5，示例分析</h2><p>一个公平锁的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchonizerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, lock);        </span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, lock);</span><br><span class="line">        MyThread t3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t3&quot;</span>, lock);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();    </span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**说明:**上面的程序存在下面这样一种执行顺序， 首先，t1线程的lock操作 -&gt; t2线程的lock操作 -&gt; t3线程的lock操作 -&gt; t1线程的unlock操作 -&gt; t2线程的unlock操作 -&gt; t3线程的unlock操作。根据这个时序图来进一步分析源码的工作流程。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901202802512.png" alt="image-20220901202802512" style="zoom:67%;" />

<ul>
<li>t1线程执行lock.lock，下图给出了方法调用中的主要方法。由调用流程可知，t1线程成功获取了资源，可以继续执行。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901203959550.png" alt="image-20220901203959550" style="zoom:67%;" />

<ul>
<li>t2线程执行lock.lock，下图给出了方法调用中的主要方法。最后的结果是t2线程会被禁止，因为调用了LockSupport.park。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901210903689.png" alt="image-20220901210903689" style="zoom:67%;" />

<ul>
<li>t3线程执行lock.lock，下图给出了方法调用中的主要方法。最后的结果是t3线程会被禁止，因为调用了LockSupport.park。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901210940334.png" alt="image-20220901210940334" style="zoom:67%;" />

<ul>
<li>t1线程调用了lock.unlock，下图给出了方法调用中的主要方法。最后，head的状态会变为0，t2线程会被unpark，即t2线程可以继续运行。此时t3线程还是被禁止。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901211017432.png" alt="image-20220901211017432" style="zoom:67%;" />

<ul>
<li>t2获得cpu资源，继续运行，由于t2之前被park了，现在需要恢复之前的状态，下图给出了方法调用中的主要方法。在setHead函数中会将head设置为之前head的下一个结点，并且将pre域与thread域都设置为null，在acquireQueued返回之前，sync queue就只有两个结点了。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901211127404.png" alt="image-20220901211127404" style="zoom:67%;" />

<ul>
<li>t2执行lock.unlock，下图给出了方法调用中的主要方法。最终unpark t3线程，让t3线程可以继续运行。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901211156415.png" alt="image-20220901211156415" style="zoom:67%;" />

<ul>
<li>t3线程获取cpu资源，恢复之前的状态，继续运行。最终达到的状态是sync queue中只剩下了一个结点，并且该节点除了状态为0外，其余均为null。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901211237474.png" alt="image-20220901211237474" style="zoom:67%;" />

<ul>
<li>t3执行lock.unlock，下图给出了方法调用中的主要方法。最后的状态和之前的状态是一样的，队列中有一个空节点，头节点为尾节点均指向它。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901211320011.png" alt="image-20220901211320011"></p>
<h1 id="十一，-JUC集合-ConcurrentHashMap详解"><a href="#十一，-JUC集合-ConcurrentHashMap详解" class="headerlink" title="十一， JUC集合: ConcurrentHashMap详解"></a>十一， JUC集合: ConcurrentHashMap详解</h1><h2 id="1，为什么HashTable慢"><a href="#1，为什么HashTable慢" class="headerlink" title="1，为什么HashTable慢"></a>1，为什么HashTable慢</h2><p>Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p>
<h2 id="2，ConcurrentHashMap-JDK-1-7"><a href="#2，ConcurrentHashMap-JDK-1-7" class="headerlink" title="2，ConcurrentHashMap - JDK 1.7"></a>2，ConcurrentHashMap - JDK 1.7</h2><p>在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap</p>
<p>ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable</p>
<p>这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可</p>
<h3 id="1，数据结构"><a href="#1，数据结构" class="headerlink" title="1，数据结构"></a>1，数据结构</h3><p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment需，这里需要关注一个名为concurrencyLevel的参数</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220901215148005.png" alt="image-20220901215148005" style="zoom: 80%;" />

<p><code>concurrencyLevel</code>: 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<h3 id="2-初试化"><a href="#2-初试化" class="headerlink" title="2,初试化"></a>2,初试化</h3><p>initialCapacity: 初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>
<p>loadFactor: 负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 - 4 &#x3D; 28，segmentMask 为 16 - 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</li>
</ul>
<h3 id="3，put过程分析"><a href="#3，put过程分析" class="headerlink" title="3，put过程分析"></a>3，put过程分析</h3><p><strong>第一层</strong>很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p><strong>第二层</strong>就是在某个Segment中的HashTable进行put</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁，先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4，get过程分析"><a href="#4，get过程分析" class="headerlink" title="4，get过程分析"></a>4，get过程分析</h3><p>相对于 put 来说，get 就很简单了。</p>
<ul>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ul>
<h3 id="5，几个关键方法的说明"><a href="#5，几个关键方法的说明" class="headerlink" title="5，几个关键方法的说明"></a>5，几个关键方法的说明</h3><p><strong>初始化槽：ensureSegment——初始化时</strong></p>
<p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line"></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><strong>获取读写锁：scanAndLockForPut——put过程</strong></p>
<p>在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。 </span><br><span class="line">    </span><br><span class="line">这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容：rehash——put过程</strong></p>
<p>segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">仔细一看发现，如果没有第一个 <span class="keyword">for</span> 循环，也是可以工作的，但是，这个 <span class="keyword">for</span> 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头节点 e 的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6，并发问题分析"><a href="#6，并发问题分析" class="headerlink" title="6，并发问题分析"></a>6，并发问题分析</h3><p><strong>put操作：</strong></p>
<ul>
<li><p>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</p>
</li>
<li><p>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</p>
</li>
<li><p>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</p>
</li>
</ul>
<p><strong>remove 操作：</strong></p>
<ul>
<li>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</li>
<li>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</li>
<li>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</li>
</ul>
<h2 id="3，ConcurrentHashMap-JDK-1-8"><a href="#3，ConcurrentHashMap-JDK-1-8" class="headerlink" title="3，ConcurrentHashMap - JDK 1.8"></a>3，ConcurrentHashMap - JDK 1.8</h2><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制</p>
<p>在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p>
<h3 id="1，数据结构-1"><a href="#1，数据结构-1" class="headerlink" title="1，数据结构"></a>1，数据结构</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220902151403825.png" alt="image-20220902151403825" style="zoom:80%;" />

<h3 id="2，初始化"><a href="#2，初始化" class="headerlink" title="2，初始化"></a>2，初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，put过程分析-1"><a href="#3，put过程分析-1" class="headerlink" title="3，put过程分析"></a>3，put过程分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">著作权归https:<span class="comment">//pdai.tech所有。</span></span><br><span class="line">链接：https:<span class="comment">//pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组&quot;空&quot;，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头节点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头节点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头节点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4，get过程分析-1"><a href="#4，get过程分析-1" class="headerlink" title="4，get过程分析"></a>4，get过程分析</h3><p>都是最简单的，这里也不例外:</p>
<ul>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li>
<li>根据该位置处结点性质进行相应查找<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，需要使用find方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li>
</ul>
</li>
</ul>
<h3 id="5，几个关键方法说明"><a href="#5，几个关键方法说明" class="headerlink" title="5，几个关键方法说明"></a>5，几个关键方法说明</h3><p><strong>初始化数组: initTable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</span><br><span class="line"></span><br><span class="line">初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><strong>链表转红黑树：treeifyBin</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是先遍历链生成表</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将链表头放进去，设置成红黑树</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩容: tryPresize</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, <span class="keyword">null</span>)，再下一个循环将 sizeCtl 加 <span class="number">1</span>，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 <span class="number">1</span>，并执行 transfer(tab, nt)。 所以，可能的操作就是执行 <span class="number">1</span> 次 transfer(tab, <span class="keyword">null</span>) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先要说明的是，进行的是翻倍扩容，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c: size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么? 不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据迁移：transfer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 <span class="keyword">null</span>，之后再调用此方法的时候，nextTab 不会为 <span class="keyword">null</span>。 </span><br><span class="line">    阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了。而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 <span class="number">16</span> 个小任务。</span><br><span class="line">    所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。 第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</span><br><span class="line">    说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">//源码太长https://pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84-inittable</span></span><br></pre></td></tr></table></figure>





<h1 id="十二，JUC线程池-ThreadPoolExecutor详解"><a href="#十二，JUC线程池-ThreadPoolExecutor详解" class="headerlink" title="十二，JUC线程池: ThreadPoolExecutor详解"></a>十二，JUC线程池: ThreadPoolExecutor详解</h1><h1 id="十三，JUC工具类-Semaphore详解"><a href="#十三，JUC工具类-Semaphore详解" class="headerlink" title="十三，JUC工具类: Semaphore详解"></a>十三，JUC工具类: Semaphore详解</h1><h1 id="十四，Java-并发-ThreadLocal详解"><a href="#十四，Java-并发-ThreadLocal详解" class="headerlink" title="十四，Java 并发 - ThreadLocal详解"></a>十四，Java 并发 - ThreadLocal详解</h1>]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-mybatis</title>
    <url>/2022/04/25/js-3-mybatis(&amp;plus)/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>jc-1-集合</title>
    <url>/2022/04/25/jc-1-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><strong>简介：</strong>本文对集合类的源码进行了初步的学习和消化。</p>
<span id="more"></span>

<h1 id="一，分类"><a href="#一，分类" class="headerlink" title="一，分类"></a>一，分类</h1><h2 id="1，Collection接口"><a href="#1，Collection接口" class="headerlink" title="1，Collection接口"></a>1，Collection接口</h2><h3 id="（1）set集合"><a href="#（1）set集合" class="headerlink" title="（1）set集合"></a>（1）set集合</h3><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。</p>
<p>但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。</p>
<p>并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序</p>
<h3 id="（2）List集合"><a href="#（2）List集合" class="headerlink" title="（2）List集合"></a>（2）List集合</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>基于动态数组实现，支持随机访问。</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>和 ArrayList 类似，但它是线程安全的。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
<h3 id="（3）Queue"><a href="#（3）Queue" class="headerlink" title="（3）Queue"></a>（3）Queue</h3><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>可以用它来实现双向队列。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列</p>
<h2 id="2，Map接口"><a href="#2，Map接口" class="headerlink" title="2，Map接口"></a>2，Map接口</h2><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>基于红黑树实现。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>基于哈希表实现。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p>
<h1 id="二，ArrayList源码解析"><a href="#二，ArrayList源码解析" class="headerlink" title="二，ArrayList源码解析"></a>二，ArrayList源码解析</h1><h2 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h2><p>ArrayList实现了List接口，底层通过数组实现，元素顺序与放入的顺序相同，允许放null值。其类中有capacity变量，表示当前能存储的元素，会自动扩容。</p>
<p>get() ，set()，size()等方法均能在常数时间内完成。add()方法与插入的位置有关。addAll()方法与添加的元素个数成正比</p>
<h2 id="2，底层数据结构"><a href="#2，底层数据结构" class="headerlink" title="2，底层数据结构"></a>2，底层数据结构</h2><p>维护了一个object数组和size变量。这个size默认是10</p>
<h2 id="3，构造函数"><a href="#3，构造函数" class="headerlink" title="3，构造函数"></a>3，构造函数</h2><p>1，可以按照要求的大小（传入initialCapacity参数）进行初始化，elementData数组中的元素都为null。</p>
<p>2，传入一个list，以获取迭代器</p>
<p>3，不传入参数，按照默认大小创建，默认size为10</p>
<h2 id="4，自动扩容"><a href="#4，自动扩容" class="headerlink" title="4，自动扩容"></a>4，自动扩容</h2><p>数组扩容通过一个public方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。</p>
<p>当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5，add-addAll"><a href="#5，add-addAll" class="headerlink" title="5，add(),addAll()"></a>5，add(),addAll()</h2><p><code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</p>
<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addAll()</code>方法能够一次添加多个元素</p>
<p>在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，</p>
<p>从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。</p>
<p>跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 <code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6，get和set方法"><a href="#6，get和set方法" class="headerlink" title="6，get和set方法"></a>6，get和set方法</h2><p>太简单了不说了</p>
<h2 id="7，remove方法"><a href="#7，remove方法" class="headerlink" title="7，remove方法"></a>7，remove方法</h2><p><code>remove()</code>方法也有两个版本</p>
<p><code>remove(int index)</code>删除指定位置的元素</p>
<p><code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。</p>
<p>删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8，trimToSize"><a href="#8，trimToSize" class="headerlink" title="8，trimToSize()"></a>8，trimToSize()</h2><p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现</p>
<h2 id="9-indexOf-lastIndexOf"><a href="#9-indexOf-lastIndexOf" class="headerlink" title="9,indexOf(), lastIndexOf()"></a>9,indexOf(), lastIndexOf()</h2><p>获取元素的第一次出现的index,和获取元素的最后一次出现的index</p>
<h2 id="10，-Fail-Fast机制"><a href="#10，-Fail-Fast机制" class="headerlink" title="10， Fail-Fast机制"></a>10， Fail-Fast机制</h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</p>
<h1 id="三，LinkedList源码"><a href="#三，LinkedList源码" class="headerlink" title="三，LinkedList源码"></a>三，LinkedList源码</h1><h2 id="1，概述-1"><a href="#1，概述-1" class="headerlink" title="1，概述"></a>1，概述</h2><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<em>Queue</em>)，同时又可以看作一个栈(<em>Stack</em>)。这样看来，<em>LinkedList</em>简直就是个全能冠军。</p>
<p>LinkedList底层是一个双向链表，有两个指针，first和last。<em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220428164125372.png" alt="image-20220428164125372" style="zoom:67%;" />

<h2 id="2，底层数据结构-1"><a href="#2，底层数据结构-1" class="headerlink" title="2，底层数据结构"></a>2，底层数据结构</h2><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Node是私有的内部类:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，构造函数-1"><a href="#3，构造函数-1" class="headerlink" title="3，构造函数"></a>3，构造函数</h2><p>一个空参，一个有参（可以传入一个collection，做出list中的元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，常用方法"><a href="#4，常用方法" class="headerlink" title="4，常用方法"></a>4，常用方法</h2><h3 id="（1）getFirst-和getLast-方法"><a href="#（1）getFirst-和getLast-方法" class="headerlink" title="（1）getFirst()和getLast()方法"></a>（1）getFirst()和getLast()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="（2）remove系列方法"><a href="#（2）remove系列方法" class="headerlink" title="（2）remove系列方法"></a>（2）remove系列方法</h3><p>下面的这写方法中，都涉及了修改size，modCount，和考虑GC</p>
<p><strong>remove(Object o)方法</strong> - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素；</p>
<p>这里被删除的节点手动赋值为了null，方便GC去收集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">// 第一个元素</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">// 最后一个元素</span></span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>; <span class="comment">// GC</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>**remove(int index)**方法使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。返回的是被删除的这个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.  Shifts any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the left (subtracts one from their indices).</span></span><br><span class="line"><span class="comment"> * Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeFirst()方法</strong>，这个方法中先判断头节点是不是null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>removeLast()方法</strong>中，同样也是先判断这个节点是不是null，然后再进行进一步的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the last element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）add系列方法"><a href="#（3）add系列方法" class="headerlink" title="（3）add系列方法"></a>（3）add系列方法</h3><p>有add(),addAll()</p>
<p>**add()*<em>方法有两个版本，一个是<code>add(E e)</code>，该方法在LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add(int index, E element)</strong>, 当index&#x3D;&#x3D;size时，等同于add(E e); 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>addAll()方法</strong>，addAll(Collection&lt;? extends E&gt; c)直接在链表为连上，addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">   * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment">   * collection&#x27;s iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment">   * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment">   * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment">   * this list, and it&#x27;s nonempty.)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">   * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">   * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">   * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">   * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">   * specified collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment">   *              from the specified collection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line"><span class="comment">//1，首先将collection c转换为数组，并且判断长度是不是0</span></span><br><span class="line">      Object[] a = c.toArray();</span><br><span class="line">      <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">      <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//2,如果说位置和长度相同，那么pre指针就是last；否则用succ指向要插入位置的node，pre指向succ的前一个</span></span><br><span class="line">      Node&lt;E&gt; pred, succ;</span><br><span class="line">      <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">          succ = <span class="keyword">null</span>;</span><br><span class="line">          pred = last;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          succ = node(index);</span><br><span class="line">          pred = succ.prev;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//3,对于数组中的每个元素，创建新node，并链接在pred的后面，此时判断一下First的情况，并不断移动pre</span></span><br><span class="line">      <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">          Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">              first = newNode;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              pred.next = newNode;</span><br><span class="line">          pred = newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4,判断一下succ的值，看是不是要进行连接</span></span><br><span class="line">      <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">          last = pred;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          pred.next = succ;</span><br><span class="line">          succ.prev = pred;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      size += numNew;</span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）clear"><a href="#（4）clear" class="headerlink" title="（4）clear"></a>（4）clear</h3><p>为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.</span></span><br><span class="line"><span class="comment"> * The list will be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（5）Positional-Access-方法"><a href="#（5）Positional-Access-方法" class="headerlink" title="（5）Positional Access 方法"></a>（5）Positional Access 方法</h3><p>通过index获取元素，将某个位置的元素重新赋值，删除指定位置的元素，这些都比较简单。下面看看将元素插入到指定index位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts the element currently at that position (if any) and any</span></span><br><span class="line"><span class="comment"> * subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（6）查找操作"><a href="#（6）查找操作" class="headerlink" title="（6）查找操作"></a>（6）查找操作</h3><p>查找操作的本质是查找元素的下标:</p>
<p>查找第一次出现的index, 如果找不到返回-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the first occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找最后一次出现的index, 如果找不到返回-1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the last occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（7）队列操作"><a href="#（7）队列操作" class="headerlink" title="（7）队列操作"></a>（7）队列操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the front of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the end of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the first element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the last element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the first element of this list,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the last element of this list,</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops an element from the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, removes and returns the first element of this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the last occurrence of the specified element in this</span></span><br><span class="line"><span class="comment"> * list (when traversing the list from head to tail).  If the list</span></span><br><span class="line"><span class="comment"> * does not contain the element, it is unchanged.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四，HashMap（HashSet）"><a href="#四，HashMap（HashSet）" class="headerlink" title="四，HashMap（HashSet）"></a>四，HashMap（HashSet）</h1><h2 id="1，java1-7版本"><a href="#1，java1-7版本" class="headerlink" title="1，java1.7版本"></a>1，java1.7版本</h2><h3 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h3><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。该容器不保证元素有序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。</p>
<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 HashMap采用的是冲突链表方式</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429205921429.png" alt="image-20220429205921429" style="zoom: 67%;" />

<p><strong>读存性能：</strong>如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>
<p><strong>有两个参数可以影响<em>HashMap</em>的性能：</strong>:初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p><strong>存放的注意事项：</strong>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<u><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”。</u>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要*@Override*<code>hashCode()</code>和<code>equals()</code>方法。</p>
<h3 id="（2）get方法"><a href="#（2）get方法" class="headerlink" title="（2）get方法"></a><strong>（2）get方法</strong></h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，<code>get(Object key)</code>方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心</p>
<p><code>getEntry()</code>方法是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。</p>
<p>要计算key对应的bucket的下标，<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429220035827.png" alt="image-20220429220035827" style="zoom:67%;" />

<h3 id="（3）put方法"><a href="#（3）put方法" class="headerlink" title="（3）put方法"></a>（3）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；</p>
<p>如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220429221657125.png" alt="image-20220429221657125" style="zoom:67%;" />

<h3 id="（3）remove"><a href="#（3）remove" class="headerlink" title="（3）remove()"></a>（3）remove()</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>getEntry()</code>过程类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2，Java1-8版本"><a href="#2，Java1-8版本" class="headerlink" title="2，Java1.8版本"></a>2，Java1.8版本</h2><h3 id="（1）概述-1"><a href="#（1）概述-1" class="headerlink" title="（1）概述"></a>（1）概述</h3><p>java8在处理同位置的元素时，该用数组+链表+红黑树的组合解决，当同一位置的元素超过8个时，由链表变为红黑树，这样就降低了寻找元素的时间。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p>
<h3 id="（2）put方法"><a href="#（2）put方法" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，参数理解：第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作，第五个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 2，数组的初试化时机：第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度，第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 3.1找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//3.2数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.1，如何插入到位置，如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2，如何插入到位置，到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// ***此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5，与***对应，处理相同的情况。e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;。对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）数组扩容"><a href="#（3）数组扩容" class="headerlink" title="（3）数组扩容"></a>（3）数组扩容</h3><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移</p>
<p>这也太复杂了，得空再看看资料</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//1.1，开始进行参数的调整 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2，将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//1.3 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 1.4 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//1.5 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 2.2 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 2.3 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 2.4 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-get方法"><a href="#4-get方法" class="headerlink" title="(4)get方法"></a>(4)get方法</h3><p>相对于 put 来说，get 真的太简单了。</p>
<ul>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="五，LinkedHashMap（LinkedHashSet）"><a href="#五，LinkedHashMap（LinkedHashSet）" class="headerlink" title="五，LinkedHashMap（LinkedHashSet）"></a>五，LinkedHashMap（LinkedHashSet）</h1><h2 id="1，概述-2"><a href="#1，概述-2" class="headerlink" title="1，概述"></a>1，概述</h2><p><em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说**LinkedHashSet里面有一个LinkedHashMap(适配器模式)*<em>。因此本文将重点分析</em>LinkedHashMap*。</p>
<p><strong>优点</strong>：<em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。LinkedHashMap<em>是</em>HashMap*的直接子类，<strong>二者唯一的区别是*LinkedHashMap*在*HashMap*的基础上，采用双向链表(doubly-linked list)的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p>
<p>除了可以保迭代历顺序，这种结构还有一个好处 : <strong>迭代*LinkedHashMap*时不需要像*HashMap*那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>
<p><strong>性能</strong>: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p><strong>原理</strong>：将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。**<code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</p>
<h2 id="2，常用方法"><a href="#2，常用方法" class="headerlink" title="2，常用方法"></a>2，常用方法</h2><h3 id="（1）get方法"><a href="#（1）get方法" class="headerlink" title="（1）get方法"></a>（1）get方法</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样</p>
<h3 id="（2）put方法-1"><a href="#（2）put方法-1" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该Entry，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；</p>
<p>如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。插入有两个含义：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li>
<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下:</span></span><br><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="(3)remove方法"></a>(3)remove方法</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p>
<p>删除也有两层含义：</p>
<blockquote>
<p>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</p>
<p>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3，实现FIFO替换策略的缓存"><a href="#3，实现FIFO替换策略的缓存" class="headerlink" title="3，实现FIFO替换策略的缓存"></a>3，实现FIFO替换策略的缓存</h3><p><em>LinkedHashMap</em>除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。</p>
<p>在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="六，TreeMap（TreeSet）"><a href="#六，TreeMap（TreeSet）" class="headerlink" title="六，TreeMap（TreeSet）"></a>六，TreeMap（TreeSet）</h1><h2 id="1，概述-3"><a href="#1，概述-3" class="headerlink" title="1，概述"></a>1，概述</h2><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口（key不能为null），也就是说会按照<code>key</code>的大小顺序对<em>Map</em>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p>
<p>*<strong>TreeMap*底层通过红黑树(Red-Black tree)实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度</p>
<p><em>TreeMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成(wrapped)同步的:</p>
<h2 id="2，红黑树"><a href="#2，红黑树" class="headerlink" title="2，红黑树"></a>2，红黑树</h2><h3 id="（1）认识红黑树"><a href="#（1）认识红黑树" class="headerlink" title="（1）认识红黑树"></a>（1）认识红黑树</h3><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色</li>
<li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li>
<li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。</li>
</ol>
<p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p>
<h3 id="（2）左旋调整"><a href="#（2）左旋调整" class="headerlink" title="（2）左旋调整"></a>（2）左旋调整</h3><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501141626265.png" alt="image-20220501141626265" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeMap中的左旋调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1，准备将r转上去</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        <span class="comment">//2，p左边连接r的左子树，注意这是双向连接</span></span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        <span class="comment">//3，r挂在p原来的父节点的下面，注意这也是双向连接</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        <span class="comment">//4，最后再调整一下r左边的双向连接，右边不用动</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）右旋调整"><a href="#（3）右旋调整" class="headerlink" title="（3）右旋调整"></a>（3）右旋调整</h3><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501141858898.png" alt="image-20220501141858898" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TreeMap的右旋调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1,p的左孩子挂上l的右子树，注意是双向连接</span></span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        <span class="comment">//2，l的父节点更新为p的父节点</span></span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        <span class="comment">//3，l的右孩子更新为p</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-寻找节点的后继"><a href="#4-寻找节点的后继" class="headerlink" title="(4)寻找节点的后继"></a>(4)寻找节点的后继</h3><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p>
<blockquote>
<ol>
<li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li>
<li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找节点后继函数successor()</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;<span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3，常用方法"><a href="#3，常用方法" class="headerlink" title="3，常用方法"></a>3，常用方法</h2><h3 id="（1）get方法-1"><a href="#（1）get方法-1" class="headerlink" title="（1）get方法"></a>（1）get方法</h3><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。</p>
<p>算法思想是根据<code>key</code>的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220501145145879.png" alt="image-20220501145145879" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）put方法-2"><a href="#（2）put方法-2" class="headerlink" title="（2）put方法"></a>（2）put方法</h3><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//1，使用元素的自然顺序进行比较，并找到要插入的位置parent</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//2，创建并插入新的entry插入到parent下面</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    <span class="comment">//3，调整树的结构</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里最难的是第三步的fixAfterInsertion函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/TreeMap_put.png" alt="TreeMap_put.png"></p>
<p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（4）remove方法"><a href="#（4）remove方法" class="headerlink" title="（4）remove方法"></a>（4）remove方法</h3><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。<code>deleteEntry()</code>函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p>
<p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p>
<blockquote>
<ol>
<li>删除点p的左右子树都为空，或者只有一棵子树非空。</li>
<li>删除点p的左右子树都非空。</li>
</ol>
</blockquote>
<p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 1. 删除点p的左右子树都非空。</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 删除点p只有一棵子树非空。</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p>
<p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/TreeMap_fixAfterDeletion.png" alt="TreeMap_fixAfterDeletion.png"></p>
<p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p>
<p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>js-mysql-1</title>
    <url>/2022/02/05/js-4-mysql/</url>
    <content><![CDATA[<p><strong>简介：</strong>MySQL的简介和安装</p>
<span id="more"></span>

<h1 id="一，MySQL介绍"><a href="#一，MySQL介绍" class="headerlink" title="一，MySQL介绍"></a>一，MySQL介绍</h1><p>​     MySQL是一个<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>，由瑞典MySQL AB 公司开发，目前属于 <a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品。MySQL 是最流行的<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/11032386?fromtitle=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&fromid=696511">关系型数据库管理系统</a>之一，在 WEB 应用方面，MySQL是最好的 <a href="https://baike.baidu.com/item/RDBMS/1048260">RDBMS</a> (Relational Database Management System，关系数据库管理系统) 应用软件之一。</p>
<p>   MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>​    MySQL的优点有：1）成本低：开放源代码，一般可免费使用；2）性能高：执行很快；3）简单：容易安装和使用                                                                                                                                                                                                 </p>
<h1 id="二，Mysql安装（win系统，5-7版本）"><a href="#二，Mysql安装（win系统，5-7版本）" class="headerlink" title="二，Mysql安装（win系统，5.7版本）"></a>二，Mysql安装（win系统，5.7版本）</h1><p><strong>下载地址：</strong></p>
<p>官网下载(不推荐使用)：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br> 清华镜像站下载(推荐)：<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7">https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7</a></p>
<h2 id="1，软件安装版"><a href="#1，软件安装版" class="headerlink" title="1，软件安装版"></a>1，软件安装版</h2><p>软件安装版也就是后缀为.msi的安装包，进行有界面操作的安装，在安装的过程中对相关的属性进行设置，可参考这篇博客：<a href="https://blog.csdn.net/weixin_43790276/article/details/102090540">https://blog.csdn.net/weixin_43790276/article/details/102090540</a></p>
<h2 id="2，安装包解压版"><a href="#2，安装包解压版" class="headerlink" title="2，安装包解压版"></a>2，安装包解压版</h2><p>使用.zip后缀的安装包进行安装时，需要结合命令行和配置文件进行配置，适合有一定基础的使用，可参考博客：<a href="https://www.jianshu.com/p/ea4accd7afb4%E4%BB%A5%E5%8F%8A%E5%8D%9A%E5%AE%A2%EF%BC%9A">https://www.jianshu.com/p/ea4accd7afb4以及博客：</a></p>
<p><strong>总结：</strong>上面两种方式各有优点和缺点，选择适合自己的方法进行安装即可。我选择的是.mis安装方式，Windows中的服务名忘了设置，是默认的MySQL57，端口也是3306，用户名和密码都是root（自己学习用就设置简单一点，否则忘了就很麻烦）。最后MySQL的卸载比较麻烦，一定要从软件，安装路径，注册表这三个方面卸载干净。</p>
<h1 id="三，关系型数据库设计理论"><a href="#三，关系型数据库设计理论" class="headerlink" title="三，关系型数据库设计理论"></a>三，关系型数据库设计理论</h1><h2 id="1，函数依赖是什么？"><a href="#1，函数依赖是什么？" class="headerlink" title="1，函数依赖是什么？"></a>1，函数依赖是什么？</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为<strong>键码</strong>。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是<strong>部分函数依赖</strong>，否则就是<strong>完全函数依赖</strong></p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个<strong>传递函数依赖</strong></p>
<h2 id="2，数据库设计为什么需要遵循范式？"><a href="#2，数据库设计为什么需要遵循范式？" class="headerlink" title="2，数据库设计为什么需要遵循范式？"></a>2，数据库设计为什么需要遵循范式？</h2><h3 id="（1）如果不遵循会有什么问题？"><a href="#（1）如果不遵循会有什么问题？" class="headerlink" title="（1）如果不遵循会有什么问题？"></a>（1）如果不遵循会有什么问题？</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/image-20220719200638902.png" alt="image-20220719200638902" style="zoom:67%;" />

<p>不符合范式的关系，会产生很多异常，主要有以下四种异常:</p>
<ul>
<li><strong>冗余数据</strong>: 例如 <code>学生-2</code> 出现了两次。</li>
<li><strong>修改异常</strong>: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li><strong>删除异常</strong>: 删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li><strong>插入异常</strong>: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>js-6-linux</title>
    <url>/2022/04/25/js-7-linux/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是简单总结linux常用命令</p>
<span id="more"></span>

<h1 id="一，基础操作"><a href="#一，基础操作" class="headerlink" title="一，基础操作"></a>一，基础操作</h1><h2 id="1，文件"><a href="#1，文件" class="headerlink" title="1，文件"></a>1，文件</h2><h3 id="（1）文件属性"><a href="#（1）文件属性" class="headerlink" title="（1）文件属性"></a>（1）文件属性</h3><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x. 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x: 文件类型以及权限，第 1 位为文件类型字段（d是目录，-是文件，l是链接文件），后 9 位为文件权限字段，             一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</span><br><span class="line">3: 链接数 </span><br><span class="line">root: 文件拥有者 </span><br><span class="line">root: 所属群组 </span><br><span class="line">17: 文件大小 </span><br><span class="line">May 6 00:14: 文件最后被修改的时间 </span><br><span class="line">.config: 文件名</span><br></pre></td></tr></table></figure>

<h3 id="（2）文件编辑状态"><a href="#（2）文件编辑状态" class="headerlink" title="（2）文件编辑状态"></a>（2）文件编辑状态</h3><p>一般指令模式(Command mode): VIM 的默认模式，可以用于移动游标查看内容；</p>
<p>编辑模式(Insert mode): 按下 “i&#x2F;a&#x2F;o” 等按键之后进入，可以对文本进行编辑；</p>
<p>指令列模式(Bottom-line mode): 按下 “:” 按键之后进入，用于保存退出等操作。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904104028096.png" alt="image-20220904104028096" style="zoom:67%;" />

<h3 id="3-文件与目录的基本操作"><a href="#3-文件与目录的基本操作" class="headerlink" title="(3)文件与目录的基本操作"></a>(3)文件与目录的基本操作</h3><p>ls：列出文件或者目录信息。</p>
<p>cd：切换目录</p>
<p>mkdir：创建目录</p>
<p>rmdir：删除目录</p>
<p>touch：更新文件时间或者建立新文件</p>
<p>cp：如果源文件有两个以上，则目的文件一定要是目录才行。cp source destination</p>
<p>rm：删除文件</p>
<p>mv：移动文件</p>
<h3 id="（4）相关权限"><a href="#（4）相关权限" class="headerlink" title="（4）相关权限"></a>（4）相关权限</h3><p><strong>修改权限：</strong></p>
<p> r、w、x 表示可读、可写、可执行。可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<p>将 .bashrc 文件的权限修改为 -rwxr-xr– 写作命令是：chmod 754 .bashrc</p>
<p>也可以使用符号来设定权限。示例: 为 .bashrc 文件的所有用户添加写权限 写作命令是：chmod a+w .bashrc</p>
<p><strong>文件的默认权限：</strong></p>
<p>文件默认权限: 文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</p>
<p>目录默认权限: 目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</p>
<h3 id="（5）链接"><a href="#（5）链接" class="headerlink" title="（5）链接"></a>（5）链接</h3><p><strong>实体链接：</strong></p>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p><strong>符号链接：</strong></p>
<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。</p>
<h3 id="（6）获取文件的内容"><a href="#（6）获取文件的内容" class="headerlink" title="（6）获取文件的内容"></a>（6）获取文件的内容</h3><p>cat：从第一行读取文件内容。</p>
<p>tac：是 cat 的反向操作，从最后一行开始打印</p>
<p>more：和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<p>less： more 类似，但是多了一个向前翻页的功能</p>
<p>head：取得文件前几行。head [-n number] filename，这里的n就是看前几行的意思</p>
<p>tail：是 head 的反向操作，只是取得是后几行。</p>
<p>od：以字符或者十六进制的形式显示二进制文件</p>
<h3 id="（7）指令与文件搜索"><a href="#（7）指令与文件搜索" class="headerlink" title="（7）指令与文件搜索"></a>（7）指令与文件搜索</h3><p><strong>which：</strong></p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904111947599.png" alt="image-20220904111947599" style="zoom:67%;" />

<p><strong>whereis：</strong></p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904111952643.png" alt="image-20220904111952643" style="zoom:67%;" />

<p><strong>locate：</strong></p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904112057008.png" alt="image-20220904112057008" style="zoom:67%;" />

<p><strong>find：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## find [basedir] [option]</span><br><span class="line">example: find . -name &quot;shadow*&quot;</span><br><span class="line"></span><br><span class="line">-name filename</span><br><span class="line">-size [+-]SIZE: 搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有: c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span><br><span class="line">-type TYPE</span><br><span class="line">-perm mode  : 搜索权限等于 mode 的文件</span><br><span class="line">-perm -mode : 搜索权限包含 mode 的文件</span><br><span class="line">-perm /mode : 搜索权限包含任一 mode 的文件</span><br></pre></td></tr></table></figure>

<h2 id="2，压缩与打包"><a href="#2，压缩与打包" class="headerlink" title="2，压缩与打包"></a>2，压缩与打包</h2><h3 id="（1）压缩文件的类型"><a href="#（1）压缩文件的类型" class="headerlink" title="（1）压缩文件的类型"></a>（1）压缩文件的类型</h3><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904135110684.png" alt="image-20220904135110684" style="zoom:67%;" />

<p>主要关注zip，gz，tar这几个相关的</p>
<h3 id="（2）压缩指令"><a href="#（2）压缩指令" class="headerlink" title="（2）压缩指令"></a>（2）压缩指令</h3><p><strong>gzip：</strong></p>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p><strong>bzip：</strong></p>
<p>提供比gzip更高的压缩比</p>
<p><strong>xz：</strong></p>
<p>提供比 bzip2 更佳的压缩比。可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<h3 id="（3）打包命令"><a href="#（3）打包命令" class="headerlink" title="（3）打包命令"></a>（3）打包命令</h3><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class="line">-z : 使用 zip；</span><br><span class="line">-j : 使用 bzip2；</span><br><span class="line">-J : 使用 xz；</span><br><span class="line">-c : 新建打包文件；</span><br><span class="line">-t : 查看打包文件里面有哪些文件；</span><br><span class="line">-x : 解打包或解压缩的功能；</span><br><span class="line">-v : 在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class="line">-f : filename: 要处理的文件；</span><br><span class="line">-C 目录 :  在特定目录解压缩。</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220904135616042.png" alt="image-20220904135616042" style="zoom:80%;" />

<h2 id="3，Bash"><a href="#3，Bash" class="headerlink" title="3，Bash"></a>3，Bash</h2><h3 id="（1）变量操作"><a href="#（1）变量操作" class="headerlink" title="（1）变量操作"></a>（1）变量操作</h3><p>对一个变量赋值直接使用 &#x3D;。对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；输出变量使用 echo 命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ x=abc</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量内容如果有空格，必须使用双引号或者单引号</li>
<li>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</li>
<li>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令:</li>
</ul>
<h3 id="（2）指令搜索顺序"><a href="#（2）指令搜索顺序" class="headerlink" title="（2）指令搜索顺序"></a>（2）指令搜索顺序</h3><ul>
<li>以绝对或相对路径来执行指令，例如 &#x2F;bin&#x2F;ls 或者 .&#x2F;ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内建的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h3 id="（3）数据流重定向"><a href="#（3）数据流重定向" class="headerlink" title="（3）数据流重定向"></a>（3）数据流重定向</h3><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">代码</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准输入 (stdin)</td>
<td align="center">0</td>
<td align="center">&lt; 或 &lt;&lt;</td>
</tr>
<tr>
<td align="center">标准输出 (stdout)</td>
<td align="center">1</td>
<td align="center">&gt; 或 &gt;&gt;</td>
</tr>
<tr>
<td align="center">标准错误输出 (stderr)</td>
<td align="center">2</td>
<td align="center">2&gt; 或 2&gt;&gt;</td>
</tr>
</tbody></table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<h2 id="4，管线指令"><a href="#4，管线指令" class="headerlink" title="4，管线指令"></a>4，管线指令</h2><p>管线是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管线。</p>
<p>在命令之间使用 | 分隔各个管线命令。</p>
<h3 id="（1）提取指令"><a href="#（1）提取指令" class="headerlink" title="（1）提取指令"></a>（1）提取指令</h3><p>cut 对数据进行切分，取出想要的部分。切分过程一行一行地进行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d : 分隔符</span><br><span class="line">-f : 经过 -d 分隔后，使用 -f n 取出第 n 个区间</span><br><span class="line">-c : 以字符为单位取出区间</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">示例 1: last 显示登入者的信息，取出用户名。</span><br><span class="line"></span><br><span class="line">$ last</span><br><span class="line">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged <span class="keyword">in</span></span><br><span class="line">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line">$ last | cut -d <span class="string">&#x27; &#x27;</span> -f 1</span><br><span class="line"></span><br><span class="line">示例 2: 将 <span class="built_in">export</span> 输出的信息，取出第 12 字符以后的所有字符串。</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">export</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTCONTROL=<span class="string">&quot;ignoredups&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTSIZE=<span class="string">&quot;1000&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HOME=<span class="string">&quot;/home/dmtsai&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HOSTNAME=<span class="string">&quot;study.centos.vbird&quot;</span></span><br><span class="line">.....(其他省略).....</span><br><span class="line">$ <span class="built_in">export</span> | cut -c 12-</span><br></pre></td></tr></table></figure>

<h3 id="（2）排序指令"><a href="#（2）排序指令" class="headerlink" title="（2）排序指令"></a>（2）排序指令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">-f : 忽略大小写</span><br><span class="line">-b : 忽略最前面的空格</span><br><span class="line">-M : 以月份的名字来排序，例如 JAN，DEC</span><br><span class="line">-n : 使用数字</span><br><span class="line">-r : 反向排序</span><br><span class="line">-u : 相当于 unique，重复的内容只出现一次</span><br><span class="line">-t : 分隔符，默认为 tab</span><br><span class="line">-k : 指定排序的区间</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例: /etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</span><br><span class="line"></span><br><span class="line">$ cat /etc/passwd | sort -t &#x27;:&#x27; -k 3</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span><br><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span><br><span class="line">arod:x:1002:1003::/home/arod:/bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="（3）双重输出重定向"><a href="#（3）双重输出重定向" class="headerlink" title="（3）双重输出重定向"></a>（3）双重输出重定向</h3><p>输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上</p>
<h3 id="（4）字符转换指令"><a href="#（4）字符转换指令" class="headerlink" title="（4）字符转换指令"></a>（4）字符转换指令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tr 用来删除一行中的字符，或者对字符进行替换。</span><br><span class="line">$ tr [-ds] SET1 ...</span><br><span class="line">-d :  删除行中 SET1 这个字符串</span><br><span class="line"></span><br><span class="line">示例，将 last 输出的信息所有小写转换为大写。</span><br><span class="line">$ last | tr <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">paste 直接将两行粘贴在一起。</span><br><span class="line">$ paste [-d] file1 file2</span><br><span class="line">-d : 分隔符，默认为 tab</span><br></pre></td></tr></table></figure>

<h3 id="（5）分区指令"><a href="#（5）分区指令" class="headerlink" title="（5）分区指令"></a>（5）分区指令</h3><p><strong>split</strong> 将一个文件划分成多个文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span><br><span class="line">-b : 以大小来进行分区，可加单位，例如 b, k, m 等</span><br><span class="line">-l : 以行数来进行分区。</span><br><span class="line">- PREFIX : 分区文件的前导名称</span><br></pre></td></tr></table></figure>

<h2 id="5，正则表达式"><a href="#5，正则表达式" class="headerlink" title="5，正则表达式"></a>5，正则表达式</h2><h3 id="（1）grep"><a href="#（1）grep" class="headerlink" title="（1）grep"></a>（1）grep</h3><p>g&#x2F;re&#x2F;p(globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span><br><span class="line">-c :  统计个数</span><br><span class="line">-i :  忽略大小写</span><br><span class="line">-n :  输出行号</span><br><span class="line">-v :  反向选择，也就是显示出没有 搜寻字符串 内容的那一行</span><br><span class="line">--color=auto : 找到的关键字加颜色显示</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">示例: 把含有 the 字符串的行提取出来(注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串)</span><br><span class="line"></span><br><span class="line">$ grep -n <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world Happy is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）printf"><a href="#（2）printf" class="headerlink" title="（2）printf"></a>（2）printf</h3><p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">著作权归https://pdai.tech所有。</span><br><span class="line">链接：https://pdai.tech/md/devops/linux/linux.html</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&#x27;%10s %5i %5i %5i %8.2f \n&#x27;</span> $(cat printf.txt)</span><br><span class="line">    DmTsai    80    60    92    77.33</span><br><span class="line">     VBird    75    55    80    70.00</span><br><span class="line">       Ken    60    90    70    73.33</span><br></pre></td></tr></table></figure>

<h3 id="（3）awk"><a href="#（3）awk" class="headerlink" title="（3）awk"></a>（3）awk</h3><p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为: $n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">示例: 取出登录用户的用户名和 IP</span><br><span class="line"></span><br><span class="line">$ last -n 5</span><br><span class="line">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged <span class="keyword">in</span></span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span><br><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span><br><span class="line">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...&#x27;</span> filename</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">示例: /etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</span><br><span class="line"></span><br><span class="line">$ cat /etc/passwd | awk <span class="string">&#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#x27;</span></span><br><span class="line">root 0</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br></pre></td></tr></table></figure>

<h2 id="6，进程管理"><a href="#6，进程管理" class="headerlink" title="6，进程管理"></a>6，进程管理</h2><h3 id="（1）查看进程"><a href="#（1）查看进程" class="headerlink" title="（1）查看进程"></a>（1）查看进程</h3><p><strong>ps：查看某个时间点的进程信息</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">示例一: 查看自己的进程</span><br><span class="line">ps -l</span><br><span class="line"></span><br><span class="line">示例二: 查看系统所有进程</span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line">示例三: 查看特定的进程</span><br><span class="line">ps aux | grep threadx</span><br></pre></td></tr></table></figure>

<p><strong>top：实时显示进程信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例: 两秒钟刷新一次</span><br><span class="line">top -d <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>pstree：查看进程树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例: 查看所有进程树</span><br><span class="line">pstree -A</span><br></pre></td></tr></table></figure>

<p><strong>netstat：查看占用端口的进程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例: 查看特定端口的进程</span><br><span class="line">netstat -anp | grep port</span><br></pre></td></tr></table></figure>



<h3 id="（2）进程状态"><a href="#（2）进程状态" class="headerlink" title="（2）进程状态"></a>（2）进程状态</h3><p>和操作系统类似，注意SIGCHLD，wait()，waitpid()</p>
<h3 id="（3）孤儿进程"><a href="#（3）孤儿进程" class="headerlink" title="（3）孤儿进程"></a>（3）孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程(进程号为 1)所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害</p>
<h3 id="（4）僵尸进程"><a href="#（4）僵尸进程" class="headerlink" title="（4）僵尸进程"></a>（4）僵尸进程</h3><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z(zombie)。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h1 id="二，内存分析工具pmap"><a href="#二，内存分析工具pmap" class="headerlink" title="二，内存分析工具pmap"></a>二，内存分析工具pmap</h1><h2 id="1，使用pamp命令返回值的行信息如下："><a href="#1，使用pamp命令返回值的行信息如下：" class="headerlink" title="1，使用pamp命令返回值的行信息如下："></a>1，使用pamp命令返回值的行信息如下：</h2><p>Address: 内存开始地址</p>
<p>Kbytes: 占用内存的字节数（KB）</p>
<p>RSS: 保留内存的字节数（KB）</p>
<p>Dirty: 脏页的字节数（包括共享和私有的）（KB）</p>
<p>Mode: 内存的权限：read、write、execute、shared、private (写时复制)</p>
<p>Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）</p>
<p>Offset: 文件偏移</p>
<p>Device: 设备名 (major:minor）</p>
<h2 id="2，示例-‘pmap-d-30242’"><a href="#2，示例-‘pmap-d-30242’" class="headerlink" title="2，示例 ‘pmap -d 30242’"></a>2，示例 ‘pmap -d 30242’</h2><p>展示进程内存 - 设备信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">著作权归https://pdai.tech所有。</span><br><span class="line">链接：https://pdai.tech/md/devops/linux/linux-pmap.html</span><br><span class="line"></span><br><span class="line">[root@pdai-centos ~]<span class="comment"># pmap -d 30242</span></span><br><span class="line">30242:   /usr/<span class="built_in">local</span>/qcloud/YunJing/YDEyes/YDService</span><br><span class="line">Address           Kbytes Mode  Offset           Device    Mapping</span><br><span class="line">0000000000400000   19416 r-x-- 0000000000000000 0fd:00001 YDService</span><br><span class="line">00000000018f5000    6520 rw--- 00000000012f5000 0fd:00001 YDService</span><br><span class="line">00007f42dd116000       4 ----- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42dd117000    8192 rw--- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42dd917000      88 r-x-- 0000000000000000 0fd:00001 libresolv-2.17.so</span><br><span class="line">00007f42dd92d000    2044 ----- 0000000000016000 0fd:00001 libresolv-2.17.so</span><br><span class="line">00007f42ddb2c000       4 r---- 0000000000015000 0fd:00001 libresolv-2.17.so</span><br><span class="line">00007f42ddb2d000       4 rw--- 0000000000016000 0fd:00001 libresolv-2.17.so</span><br><span class="line">00007f42ddb2e000       8 rw--- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42ddb30000      20 r-x-- 0000000000000000 0fd:00001 libnss_dns-2.17.so</span><br><span class="line">00007f42ddb35000    2048 ----- 0000000000005000 0fd:00001 libnss_dns-2.17.so</span><br><span class="line">00007f42ddf44000    1432 rw--- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42de0aa000       4 ----- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42de0ab000    8192 rw--- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f42de8ab000       4 ----- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f4307bc1000    1800 r-x-- 0000000000000000 0fd:00001 libc-2.17.so</span><br><span class="line">00007f4307d83000    2048 ----- 00000000001c2000 0fd:00001 libc-2.17.so</span><br><span class="line">00007f4307f83000      16 r---- 00000000001c2000 0fd:00001 libc-2.17.so</span><br><span class="line">00007f4307f87000       8 rw--- 00000000001c6000 0fd:00001 libc-2.17.so</span><br><span class="line">00007f4307f89000      20 rw--- 0000000000000000 000:00000   [ anon ]</span><br><span class="line">00007f4307f8e000      84 r-x-- 0000000000000000 0fd:00001 libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">00007f4307fa3000    2044 ----- 0000000000015000 0fd:00001 libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">00007f43081a2000       4 r---- 0000000000014000 0fd:00001 libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">00007f43081a3000       4 rw--- 0000000000015000 0fd:00001 libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">00007f43081a4000    1028 r-x-- 0000000000000000 0fd:00001 libm-2.17.so</span><br><span class="line">00007f43082a5000    2044 ----- 0000000000101000 0fd:00001 libm-2.17.so</span><br><span class="line">mapped: 1137256K    writeable/private: 489808K    shared: 4096K</span><br></pre></td></tr></table></figure>

<p><strong>最后一行的值</strong></p>
<ol>
<li><p><code>mapped</code> 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz</p>
</li>
<li><p><code>writeable/private</code>  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小</p>
</li>
<li><p><code>shared</code> 表示进程和其他进程共享的内存大小</p>
<p>4,不显示头尾行, 加 ‘-d’参数</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>Linux的思想是一切皆文件，那么进程对应的内存也是保存在文件系统中的，虽然&#x2F;proc目录是一个伪文件系统; 该文件从&#x2F;proc&#x2F;<em>pid</em>&#x2F;maps中获得数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">著作权归https://pdai.tech所有。</span><br><span class="line">链接：https://pdai.tech/md/devops/linux/linux-pmap.html</span><br><span class="line"></span><br><span class="line">[root@pdai-centos ~]<span class="comment"># cat /proc/30242/maps</span></span><br><span class="line">00400000-016f6000 r-xp 00000000 fd:01 545991                             /usr/<span class="built_in">local</span>/qcloud/YunJing/YDEyes/YDService</span><br><span class="line">018f5000-01f53000 rw-p 012f5000 fd:01 545991                             /usr/<span class="built_in">local</span>/qcloud/YunJing/YDEyes/YDService</span><br><span class="line">01f53000-01fda000 rw-p 00000000 00:00 0</span><br><span class="line">02206000-0d2de000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">c000000000-c004000000 rw-p 00000000 00:00 0</span><br><span class="line">7f42d4445000-7f42d4446000 ---p 00000000 00:00 0</span><br><span class="line">7f42d4446000-7f42d4c46000 rw-p 00000000 00:00 0</span><br><span class="line">7f42d4c46000-7f42d4c47000 ---p 00000000 00:00 0</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<h2 id="3，示例’pmap-x-30242’"><a href="#3，示例’pmap-x-30242’" class="headerlink" title="3，示例’pmap -x 30242’"></a>3，示例’pmap -x 30242’</h2><p>展示进程内存 - 拓展信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@pdai-centos ~]<span class="comment"># pmap -x 30242</span></span><br><span class="line">30242:   /usr/<span class="built_in">local</span>/qcloud/YunJing/YDEyes/YDService</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000000000400000   19416    4964       0 r-x-- YDService  <span class="comment"># YDService 代码段</span></span><br><span class="line">00000000018f5000    6520    2252     112 rw--- YDService  <span class="comment"># YDService 数据段</span></span><br><span class="line">0000000001f53000     540     220     220 rw---   [ anon ] </span><br><span class="line">0000000002206000  181088   62384   61208 rw---   [ anon ] <span class="comment"># YDService 堆（分配的内存）</span></span><br><span class="line">000000c000000000   65536    3780    3760 rw---   [ anon ]</span><br><span class="line">00007f42d4445000       4       0       0 -----   [ anon ]</span><br><span class="line">00007f42d4446000    8192      20      20 rw---   [ anon ]</span><br><span class="line">00007f42d4c46000       4       0       0 -----   [ anon ]</span><br><span class="line">00007f42d4c47000    8192      12      12 rw---   [ anon ]</span><br><span class="line">00007f42d5447000       4       0       0 -----   [ anon ]</span><br><span class="line">00007f42d5448000    8448      88      88 rw---   [ anon ]</span><br><span class="line">00007f42d5c88000       4       0       0 -----   [ anon ]</span><br><span class="line">00007f42d5c89000    8192      32      32 rw---   [ anon ]</span><br><span class="line">00007f42d6489000    4096    4096    1024 rw-s-   [ anon ]</span><br><span class="line">00007f42d6889000       4       0       0 -----   [ anon ]</span><br><span class="line">00007f42d688a000    8192      20      20 rw---   [ anon ]</span><br><span class="line">00007f42d708a000       4       0       0 -----   [ anon ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="4-示例-‘pmap-XX-30242’"><a href="#4-示例-‘pmap-XX-30242’" class="headerlink" title="4,示例 ‘pmap -XX 30242’"></a>4,示例 ‘pmap -XX 30242’</h2><p>展示进程内存 - 所有信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@pdai-centos ~]<span class="comment"># pmap -XX 30242</span></span><br><span class="line">30242:   /usr/<span class="built_in">local</span>/qcloud/YunJing/YDEyes/YDService</span><br><span class="line">         Address Perm   Offset Device    Inode    Size   Rss   Pss Shared_Clean Shared_Dirty Private_Clean Private_Dirty Referenced Anonymous AnonHugePages   Swap KernelPageSize MMUPageSize Locked                      VmFlagsMapping</span><br><span class="line">        00400000 r-xp 00000000  fd:01   545991   19416  4964  4964            0            0          4964             0       4964         0             0      0              4           4      0       rd ex mr mw me dw sd  YDService</span><br><span class="line">        018f5000 rw-p 012f5000  fd:01   545991    6520  2252  2252            0            0          2140           112       2252       120             0     28              4           4      0    rd wr mr mw me dw ac sd  YDService</span><br><span class="line">        01f53000 rw-p 00000000  00:00        0     540   220   220            0            0             0           220        220       220             0     36              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">        02206000 rw-p 00000000  00:00        0  181088 62384 62384            0            0          1176         61208      62248     62384             0 118704              4           4      0       rd wr mr mw me ac sd  [heap]</span><br><span class="line">      c000000000 rw-p 00000000  00:00        0   65536  4120  4120            0            0            20          4100       4120      4120             0   1012              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">    7f42d4445000 ---p 00000000  00:00        0       4     0     0            0            0             0             0          0         0             0      0              4           4      0             mr mw me ac sd</span><br><span class="line">    7f42d4446000 rw-p 00000000  00:00        0    8192    20    20            0            0             0            20         20        20             0      0              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">    7f42d4c46000 ---p 00000000  00:00        0       4     0     0            0            0             0             0          0         0             0      0              4           4      0             mr mw me ac sd</span><br><span class="line">    7f42d4c47000 rw-p 00000000  00:00        0    8192    12    12            0            0             0            12         12        12             0      8              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">    7f42d5447000 ---p 00000000  00:00        0       4     0     0            0            0             0             0          0         0             0      0              4           4      0             mr mw me ac sd</span><br><span class="line">    7f42d5448000 rw-p 00000000  00:00        0    8448    88    88            0            0             0            88         88        88             0     28              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">    7f42d5c88000 ---p 00000000  00:00        0       4     0     0            0            0             0             0          0         0             0      0              4           4      0             mr mw me ac sd</span><br><span class="line">    7f42d5c89000 rw-p 00000000  00:00        0    8192    32    32            0            0             0            32         32        32             0      4              4           4      0       rd wr mr mw me ac sd</span><br><span class="line">    7f42d6489000 rw-s 00000000  00:07 34628688    4096  4096  2560         3072            0             0          1024       4096         0             0      0              4           4      0 rd wr sh mr mw me ms sd mm  socket:[34628688]</span><br><span class="line">    7f42d6889000 ---p 00000000  00:00        0       4     0     0            0            0             0             0          0         0             0      0              4           4      0             mr mw me ac sd</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h1 id="三，Curl使用"><a href="#三，Curl使用" class="headerlink" title="三，Curl使用"></a>三，Curl使用</h1><h2 id="1，下载单个文件"><a href="#1，下载单个文件" class="headerlink" title="1，下载单个文件"></a>1，下载单个文件</h2><p>通过-o&#x2F;-O选项保存下载的文件到指定的文件中: -o: 将文件保存为命令行中指定的文件名的文件中 -O: 使用URL中默认的文件名保存文件到本地</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件下载到本地并命名为mygettext.html</span></span><br><span class="line">curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将文件保存到本地并命名为gettext.html</span></span><br><span class="line">curl -O http://www.gnu.org/software/gettext/manual/gettext.html</span><br></pre></td></tr></table></figure>

<h2 id="2，同时获取多个文件"><a href="#2，同时获取多个文件" class="headerlink" title="2，同时获取多个文件"></a>2，同时获取多个文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -O URL1 -O URL2</span><br></pre></td></tr></table></figure>

<h2 id="3，断点续传"><a href="#3，断点续传" class="headerlink" title="3，断点续传"></a>3，断点续传</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当文件在下载完成之前结束该进程</span></span><br><span class="line">$ curl -O http://www.gnu.org/software/gettext/manual/gettext.html</span><br><span class="line"><span class="comment">#############             20.1%</span></span><br><span class="line"><span class="comment"># 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载</span></span><br><span class="line">curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html</span><br><span class="line"><span class="comment">##############       </span></span><br></pre></td></tr></table></figure>

<h2 id="4，CURL授权"><a href="#4，CURL授权" class="headerlink" title="4，CURL授权"></a>4，CURL授权</h2><p>在访问需要授权的页面时，可通过-u选项提供用户名和密码进行授权</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -u username:password URL</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通常的做法是在命令行只输入用户名，之后会提示输入密码，这样可以保证在查看历史记录时不会将密码泄露</span></span><br><span class="line">curl -u username URL</span><br></pre></td></tr></table></figure>

<h2 id="5，从FTP服务器下载文件"><a href="#5，从FTP服务器下载文件" class="headerlink" title="5，从FTP服务器下载文件"></a>5，从FTP服务器下载文件</h2><p>CURL同样支持FTP下载，若在url中指定的是某个文件路径而非具体的某个要下载的文件名，CURL则会列出该目录下的所有文件名而并非下载该目录下的所有文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出public_html下的所有文件夹和文件</span></span><br><span class="line">curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载xss.php文件</span></span><br><span class="line">curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="6，上传文件到FTP服务器"><a href="#6，上传文件到FTP服务器" class="headerlink" title="6，上传文件到FTP服务器"></a>6，上传文件到FTP服务器</h2><p>通过 -T 选项可将指定的本地文件上传到FTP服务器上 复制代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将myfile.txt文件上传到服务器</span></span><br><span class="line">curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时上传多个文件</span></span><br><span class="line">curl -u ftpuser:ftppass -T <span class="string">&quot;&#123;file1,file2&#125;&quot;</span> ftp://ftp.testserver.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从标准输入获取内容保存到服务器指定的文件中</span></span><br><span class="line">curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt</span><br></pre></td></tr></table></figure>

































]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-5-Dubbo</title>
    <url>/2022/04/25/js-6-nacos/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，这是一级标题"><a href="#一，这是一级标题" class="headerlink" title="一，这是一级标题"></a>一，这是一级标题</h1><h2 id="1，这是二级标题"><a href="#1，这是二级标题" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-1"><a href="#（1），这是三级标题-1" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h1 id="二，这是一级标题"><a href="#二，这是一级标题" class="headerlink" title="二，这是一级标题"></a>二，这是一级标题</h1><h2 id="1，这是二级标题-1"><a href="#1，这是二级标题-1" class="headerlink" title="1，这是二级标题"></a>1，这是二级标题</h2><h3 id="（1），这是三级标题-2"><a href="#（1），这是三级标题-2" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="2，这是二级标题-1"><a href="#2，这是二级标题-1" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题-3"><a href="#（1），这是三级标题-3" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>js-3-springmvc</title>
    <url>/2022/02/06/js-2-springmvc/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：快速了解Spring的用法，能够对Spring形成自己的框架。本文的学习基于<a href="http://c.biancheng.net/spring_mvc/mvc.html">C语言中文网</a>，尚硅谷Spring讲解</p>
<span id="more"></span>

<h1 id="一，MVC设计模式简介"><a href="#一，MVC设计模式简介" class="headerlink" title="一，MVC设计模式简介"></a>一，MVC设计模式简介</h1><h2 id="1，认识MVC"><a href="#1，认识MVC" class="headerlink" title="1，认识MVC"></a>1，认识MVC</h2><p>MVC 设计模式一般指 MVC 框架，M（Model）指数据模型层，V（View）指视图层，C（Controller）指控制层。使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。</p>
<ul>
<li>视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。</li>
<li>控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。</li>
<li>数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。</li>
</ul>
<h2 id="2，MVC优缺点"><a href="#2，MVC优缺点" class="headerlink" title="2，MVC优缺点"></a>2，MVC优缺点</h2><p>优点</p>
<ul>
<li>多视图共享一个模型，大大提高了代码的可重用性</li>
<li>MVC 三个模块相互独立，松耦合架构</li>
<li>控制器提高了应用程序的灵活性和可配置性</li>
<li>有利于软件工程化管理</li>
</ul>
<p>总之，我们通过 MVC 设计模式最终可以打造出一个松耦合+高可重用性+高可适用性的完美架构。</p>
<p>缺点</p>
<ul>
<li>原理复杂</li>
<li>增加了系统结构和实现的复杂性</li>
<li>视图对模型数据的低效率访问</li>
</ul>
<p>MVC 并不适合小型甚至中型规模的项目，花费大量时间将 MVC 应用到规模并不是很大的应用程序，通常得不偿失，所以对于 MVC 设计模式的使用要根据具体的应用场景来决定。</p>
<h1 id="二，Spring-MVC是什么？"><a href="#二，Spring-MVC是什么？" class="headerlink" title="二，Spring MVC是什么？"></a>二，Spring MVC是什么？</h1><h2 id="1，认识Spring-MVC"><a href="#1，认识Spring-MVC" class="headerlink" title="1，认识Spring MVC"></a>1，认识Spring MVC</h2><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。</p>
<p>Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性</p>
<h2 id="2-Spring-MVC的优缺点"><a href="#2-Spring-MVC的优缺点" class="headerlink" title="2,Spring MVC的优缺点"></a>2,Spring MVC的优缺点</h2><ul>
<li>清晰地角色划分，Spring MVC 在 Model、View 和 Controller 方面提供了一个非常清晰的角色划分，这 3 个方面真正是各司其职，各负其责。</li>
<li>灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。</li>
<li>提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。</li>
<li>真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。</li>
<li>国际化支持</li>
<li>面向接口编程</li>
<li>与 Spring 框架无缝集成</li>
</ul>
<h1 id="三，第一个Spring-MVC程序"><a href="#三，第一个Spring-MVC程序" class="headerlink" title="三，第一个Spring MVC程序"></a>三，第一个Spring MVC程序</h1><h2 id="1，创建Web应用并引入Jar包"><a href="#1，创建Web应用并引入Jar包" class="headerlink" title="1，创建Web应用并引入Jar包"></a>1，创建Web应用并引入Jar包</h2><p>这些包中，前面的是Spring的核心包，后面两个是进行Spring MVC开发的包。（当然，如果项目是maven项目，相关依赖可以自行百度，但是要注意版本）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-1.png" alt="js-3-1"></p>
<h2 id="2，Spring-MVC配置"><a href="#2，Spring-MVC配置" class="headerlink" title="2，Spring MVC配置"></a>2，Spring MVC配置</h2><p>Spring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理。所以配置 Spring MVC，首先要定义 DispatcherServlet。跟所有 Servlet 一样，<strong>用户必须在 web.xml 中进行配置</strong>。</p>
<h3 id="1）在web-xml中定义DispatcherServlet"><a href="#1）在web-xml中定义DispatcherServlet" class="headerlink" title="1）在web.xml中定义DispatcherServlet"></a>1）在web.xml中定义DispatcherServlet</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意，如果该配置文件不是放在默认的 WEB-INF文件夹下的话，就需要下面的Init-param中的contextConfigLocation参数来设置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL，因为这里根本没限制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring MVC 初始化时，加载web.xml，然后根据配置的servlet信息，在应用程序的 WEB-INF 目录下查找配置文件，该配置文件的命名规则是“servletName-servlet.xml”，例如 springmvc-servlet.xml。</p>
<h3 id="2）创建Spring-MVC配置文件"><a href="#2）创建Spring-MVC配置文件" class="headerlink" title="2）创建Spring MVC配置文件"></a>2）创建Spring MVC配置文件</h3><p>在 WEB-INF 目录下创建 springmvc-servlet.xml 文件，如下所示。（这里和网上的还不一样，网上直接就上注解了，这里还没）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- LoginController控制器类，映射到&quot;/login&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/login&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;net.biancheng.controller.LoginController&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- LoginController控制器类，映射到&quot;/register&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/register&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;net.biancheng.controller.RegisterController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3，创建Controller"><a href="#3，创建Controller" class="headerlink" title="3，创建Controller"></a>3，创建Controller</h2><p>在src目录下创建com.zhao.controller，并在该包中创建 RegisterController 和 LoginController 两个<strong>传统风格</strong>（现在用的少）的控制器类（实现 Controller 接口），分别处理首页中“注册”和“登录”超链接的请求</p>
<p>RegisterController 的具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest arg0,</span></span></span><br><span class="line"><span class="params"><span class="function">            HttpServletResponse arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/WEB-INF/jsp/register.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoginController 的具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest arg0,</span></span></span><br><span class="line"><span class="params"><span class="function">            HttpServletResponse arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，创建View"><a href="#4，创建View" class="headerlink" title="4，创建View"></a>4，创建View</h2><p>index.jsp代码如下（这个页面的位置其实可以不用很讲究，此处还么有引入web环境，所以是直接打开此页面开始的）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    未注册的用户，请</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/register&quot;</span>&gt;</span> 注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span>！</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 已注册的用户，去</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/login&quot;</span>&gt;</span> 登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span>！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 WEB-INF 下创建 jsp 文件夹，将 login.jsp 和 register.jsp 放到 jsp 文件夹下。login.jsp 代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    登录页面！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">         pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    注册页面！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-部署运行"><a href="#5-部署运行" class="headerlink" title="5,部署运行"></a>5,部署运行</h3><p>将 springmvcDemo 项目部署到 Tomcat 服务器，首先访问 index.jsp 页面，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-2.png" alt="js-3-2"></p>
<p>在上图所示的页面中，当用户单击“注册”超链接时，根据 springmvc-servlet.xml 文件中的映射将请求转发给 RegisterController 控制器处理，处理后跳转到 &#x2F;WEB-INF&#x2F;jsp 下的 register.jsp 视图。同理，当单击“登录”超链接时，控制器处理后转到 &#x2F;WEB-INF&#x2F;jsp下的 login.jsp 视图。</p>
<h1 id="四，Spring-MVC-和Structs2的区别"><a href="#四，Spring-MVC-和Structs2的区别" class="headerlink" title="四，Spring MVC 和Structs2的区别"></a>四，Spring MVC 和Structs2的区别</h1><p>这里了解即可，这里不再花篇幅说明</p>
<h1 id="五，Spring-MVC视图解析器（ViewResolver）"><a href="#五，Spring-MVC视图解析器（ViewResolver）" class="headerlink" title="五，Spring MVC视图解析器（ViewResolver）"></a>五，Spring MVC视图解析器（ViewResolver）</h1><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-3.png" alt="js-3-3"></p>
<p>视图解析器（ViewResolver）是 Spring MVC 的重要组成部分，负责将逻辑视图名解析为具体的视图对象。Spring MVC提供了上面几种视图解析器，下面介绍1个常用的视图解析器，其他视图解析器如何配置这里不再赘述</p>
<h2 id="（1）InternalResourceViewResolver"><a href="#（1）InternalResourceViewResolver" class="headerlink" title="（1）InternalResourceViewResolver"></a>（1）InternalResourceViewResolver</h2><p>InternalResourceViewResolver 为“内部资源视图解析器”，是日常开发中最常用的视图解析器类型。它是 URLBasedViewResolver 的子类，拥有 URLBasedViewResolver 的一切特性。</p>
<p>InternalResourceViewResolver 能自动将返回的视图名称解析为 InternalResourceView 类型的对象。InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六，Spring-MVC执行流程"><a href="#六，Spring-MVC执行流程" class="headerlink" title="六，Spring MVC执行流程"></a>六，Spring MVC执行流程</h1><h2 id="1，图解执行流程"><a href="#1，图解执行流程" class="headerlink" title="1，图解执行流程"></a>1，图解执行流程</h2><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-4.png" alt="js-3-4" style="zoom:50%;" />

<p>SpringMVC 的执行流程如下。</p>
<ol>
<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li>
<li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链给DispatcherServlet（HandlerExecutionChain）。</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol>
<h2 id="2，Spring-MVC接口"><a href="#2，Spring-MVC接口" class="headerlink" title="2，Spring MVC接口"></a>2，Spring MVC接口</h2><p>Spring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）。下面对各个组件的功能说明如下。</p>
<h4 id="1）DispatcherServlet"><a href="#1）DispatcherServlet" class="headerlink" title="1）DispatcherServlet"></a>1）DispatcherServlet</h4><p>DispatcherServlet 是前端控制器，从图 1 可以看出，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p>
<h4 id="2）HandlerMapping"><a href="#2）HandlerMapping" class="headerlink" title="2）HandlerMapping"></a>2）HandlerMapping</h4><p>HandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。</p>
<h4 id="3）HandlerAdapter"><a href="#3）HandlerAdapter" class="headerlink" title="3）HandlerAdapter"></a>3）HandlerAdapter</h4><p>HandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。</p>
<h4 id="4）Handler"><a href="#4）Handler" class="headerlink" title="4）Handler"></a>4）Handler</h4><p>Handler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。</p>
<h4 id="5）View-Resolver"><a href="#5）View-Resolver" class="headerlink" title="5）View Resolver"></a>5）View Resolver</h4><p>View Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。</p>
<h4 id="6）View"><a href="#6）View" class="headerlink" title="6）View"></a>6）View</h4><p>View 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。</p>
<p>以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。这里只是大概的说明了一下，更加具体的应该在后面的运用中加深理解。</p>
<h3 id="3，更完整的执行流程（加上了拦截器啥的）"><a href="#3，更完整的执行流程（加上了拦截器啥的）" class="headerlink" title="3，更完整的执行流程（加上了拦截器啥的）"></a>3，更完整的执行流程（加上了拦截器啥的）</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-5.png" alt="js-3-5" style="zoom:67%;" />

<h1 id="七，-Controller和-RequestMapping注解"><a href="#七，-Controller和-RequestMapping注解" class="headerlink" title="七，@Controller和@RequestMapping注解"></a>七，@Controller和@RequestMapping注解</h1><h2 id="1，Controller注解"><a href="#1，Controller注解" class="headerlink" title="1，Controller注解"></a>1，Controller注解</h2><p>@Controller 注解用于声明某类的实例是一个控制器。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC 使用扫描机制找到应用中所有基于注解的控制器类，所以，为了让控制器类被 Spring MVC 框架扫描到，需要在配置文件中声明 spring-context，并使用 <code>&lt;context:component-scan/&gt;</code> 元素指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用扫描机制扫描控制器类，控制器类都在com.zhao.controller包及其子包下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.controller&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-RequestMapping注解"><a href="#2-RequestMapping注解" class="headerlink" title="2,RequestMapping注解"></a>2,RequestMapping注解</h2><p>一个Controller内有多个处理请求的方法，如 UserController 里通常有增加用户、修改用户信息、删除指定用户、根据条件获取用户列表等。每个方法负责不同的请求操作，而 @RequestMapping 就负责将请求映射到对应的controller法上。</p>
<p>@RequestMapping 注解可用于类或方法上。用于类上，表示类中的所有响应请求的方法都以该地址作为父路径。</p>
<p>下面介绍该注解的一些参数</p>
<h3 id="（1）value-属性"><a href="#（1）value-属性" class="headerlink" title="（1）value 属性"></a>（1）value 属性</h3><p>value 属性是 @RequestMapping 注解的默认属性，因此如果只有 value 属性时，可以省略该属性名，如果有其它属性，则必须写上 value 属性名称。如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;toUser&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;toUser&quot;)</span></span><br></pre></td></tr></table></figure>

<p>value 属性支持通配符匹配，如 @RequestMapping(value&#x3D;”toUser&#x2F;*”) 表示 <a href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p>
<h3 id="（2）path属性"><a href="#（2）path属性" class="headerlink" title="（2）path属性"></a>（2）path属性</h3><p>path 属性和 value 属性都用来作为映射使用。即 @RequestMapping(value&#x3D;”toUser”) 和 @RequestMapping(path&#x3D;”toUser”) 都能访问 toUser() 方法。</p>
<p>path 属性支持通配符匹配，如 @RequestMapping(path&#x3D;”toUser&#x2F;*”) 表示 <a href="http://localhost:8080/toUser/1">http://localhost:8080/toUser/1</a> 或 <a href="http://localhost:8080/toUser/hahaha">http://localhost:8080/toUser/hahaha</a> 都能够正常访问。</p>
<h3 id="（3）name属性"><a href="#（3）name属性" class="headerlink" title="（3）name属性"></a>（3）name属性</h3><p>name属性相当于方法的注释，使方法更易理解。如 @RequestMapping(value &#x3D; “toUser”,name &#x3D; “获取用户信息”)。</p>
<h3 id="（4）method属性"><a href="#（4）method属性" class="headerlink" title="（4）method属性"></a>（4）method属性</h3><p>method 属性用于表示该方法支持哪些 HTTP 请求。如果省略 method 属性，则说明该方法支持全部的 HTTP 请求。</p>
<p>@RequestMapping(value &#x3D; “toUser”,method &#x3D; RequestMethod.GET) 表示该方法只支持 GET 请求。也可指定多个 HTTP 请求，如 @RequestMapping(value &#x3D; “toUser”,method &#x3D; {RequestMethod.GET,RequestMethod.POST})，说明该方法同时支持 GET 和 POST 请求。</p>
<h3 id="（5）params属性"><a href="#（5）params属性" class="headerlink" title="（5）params属性"></a>（5）params属性</h3><p>params 属性用于指定请求中规定的参数，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;showUser&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码表示请求中必须包含 type 参数时才能执行该请求。即 <a href="http://localhost:8080/toUser?type=xxx">http://localhost:8080/toUser?type=xxx</a> 能够正常访问 toUser() 方法，而 <a href="http://localhost:8080/toUser">http://localhost:8080/toUser</a> 则不能正常访问 toUser() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;toUser&quot;,params = &quot;type=1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;showUser&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码表示请求中必须包含 type 参数，且 type 参数为 1 时才能够执行该请求。即 <a href="http://localhost:8080/toUser?type=1">http://localhost:8080/toUser?type=1</a> 能够正常访问 toUser() 方法，而 <a href="http://localhost:8080/toUser?type=2">http://localhost:8080/toUser?type=2</a> 则不能正常访问 toUser() 方法。</p>
<h3 id="（6）header属性"><a href="#（6）header属性" class="headerlink" title="（6）header属性"></a>（6）header属性</h3><p>header 属性表示请求中必须包含某些指定的 header 值。</p>
<p>@RequestMapping(value &#x3D; “toUser”,headers &#x3D; “Referer&#x3D;<a href="http://www.xxx.com&quot;/">http://www.xxx.com&quot;</a>) 表示请求的 header 中必须包含了指定的“Referer”请求头，以及值为“<a href="http://www.xxx.com”时,才能执行该请求./">http://www.xxx.com”时，才能执行该请求。</a></p>
<h3 id="（7）consumers属性"><a href="#（7）consumers属性" class="headerlink" title="（7）consumers属性"></a>（7）consumers属性</h3><p>consumers 属性用于指定处理请求的提交内容类型（Content-Type），例如：application&#x2F;json、text&#x2F;html。如<br>@RequestMapping(value &#x3D; “toUser”,consumes &#x3D; “application&#x2F;json”)。</p>
<h3 id="（8）produces属性"><a href="#（8）produces属性" class="headerlink" title="（8）produces属性"></a>（8）produces属性</h3><p>produces 属性用于指定返回的内容类型，返回的内容类型必须是 request 请求头（Accept）中所包含的类型。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json”)。</p>
<p>除此之外，produces 属性还可以指定返回值的编码。如 @RequestMapping(value &#x3D; “toUser”,produces &#x3D; “application&#x2F;json,charset&#x3D;utf-8”)，表示返回 utf-8 编码。</p>
<h2 id="3，通过请求URL进行映射"><a href="#3，通过请求URL进行映射" class="headerlink" title="3，通过请求URL进行映射"></a>3，通过请求URL进行映射</h2><p>使用 @RequestMapping 来完成映射，具体包括 4 个方面的信息项：请求 URL、请求参数、请求方法和请求头。这里先说明通过请求URL进行映射</p>
<h3 id="（1）方法级别注解"><a href="#（1）方法级别注解" class="headerlink" title="（1）方法级别注解"></a>（1）方法级别注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以使用如下 URL 访问 login 方法（请求处理方法），在访问 login 方法之前需要事先在 &#x2F;WEB-INF&#x2F;jsp&#x2F; 目录下创建 login.jsp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/springmvcDemo/index/login</span><br></pre></td></tr></table></figure>

<h3 id="（2）类级别注解"><a href="#（2）类级别注解" class="headerlink" title="（2）类级别注解"></a>（2）类级别注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类级别注解的情况下，控制器类中的所有方法都将映射为类级别的请求。用户可以使用如下 URL 访问 login 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/springmvcDemo/index/login</span><br></pre></td></tr></table></figure>

<h2 id="4，通过请求参数，请求方法进行映射"><a href="#4，通过请求参数，请求方法进行映射" class="headerlink" title="4，通过请求参数，请求方法进行映射"></a>4，通过请求参数，请求方法进行映射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index/success&quot; method=RequestMethod.GET, Params=&quot;username&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">success</span><span class="params">(<span class="meta">@RequestParam</span> String username)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，@RequestMapping 的 value 表示请求的 URL；method 表示请求方法，此处设置为 GET 请求，若是 POST 请求，则无法进入 success 这个处理方法中。params 表示请求参数，此处参数名为 username。</p>
<h2 id="5，编写请求处理方法"><a href="#5，编写请求处理方法" class="headerlink" title="5，编写请求处理方法"></a>5，编写请求处理方法</h2><h3 id="（1）请求处理方法中常出现的参数类型"><a href="#（1）请求处理方法中常出现的参数类型" class="headerlink" title="（1）请求处理方法中常出现的参数类型"></a>（1）请求处理方法中常出现的参数类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,请求处理方法中处理Servlet API（有很多，比如session）</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session,HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;skey&quot;</span>, <span class="string">&quot;session范围的值&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;rkey&quot;</span>, <span class="string">&quot;request范围的值&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）请求处理方法常见的返回类型"><a href="#（2）请求处理方法常见的返回类型" class="headerlink" title="（2）请求处理方法常见的返回类型"></a>（2）请求处理方法常见的返回类型</h3><p>求处理方法可以返回如下类型的对象：</p>
<ul>
<li>ModelAndView</li>
<li>Model</li>
<li>包含模型属性的 Map</li>
<li>View</li>
<li>代表逻辑视图名的 String</li>
<li>void</li>
<li>其它任意Java类型</li>
</ul>
<p>最常见的返回类型就是代表逻辑视图名称的 String 类型，例如前面几节中的请求处理方法。</p>
<h1 id="八，Spring-MVC传递参数"><a href="#八，Spring-MVC传递参数" class="headerlink" title="八，Spring MVC传递参数"></a>八，Spring MVC传递参数</h1><p>Spring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：</p>
<ul>
<li>通过实体 Bean 接收请求参数</li>
<li>通过处理方法的形参接收请求参数</li>
<li>通过 HttpServletRequest 接收请求参数</li>
<li>通过 @PathVariable 接收 URL 中的请求参数</li>
<li>通过 @RequestParam 接收请求参数</li>
<li>通过 @ModelAttribute 接收请求参数</li>
</ul>
<h2 id="（1）通过实体-Bean-接收请求参数"><a href="#（1）通过实体-Bean-接收请求参数" class="headerlink" title="（1）通过实体 Bean 接收请求参数"></a>（1）通过实体 Bean 接收请求参数</h2><p>实体 Bean 接收请求参数适用于 get 和 post 提交请求方式。需要注意，Bean 的属性名称必须与请求参数名称相同（比如name要和页面传过来的name是一样的才行，页面中的表单传递了两个参数，会被包装成一个user类）。示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestMapping(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(user.getName()) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.getPwd())) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&lt;%=request.getAttribute(&quot;messageError&quot;)%&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="（2）通过处理方法的形参接收请求参数"><a href="#（2）通过处理方法的形参接收请求参数" class="headerlink" title="（2）通过处理方法的形参接收请求参数"></a>（2）通过处理方法的形参接收请求参数</h2><p>通过处理方法的形参接收请求参数就是直接把表单参数写在控制器类相应方法的形参中，即形参名称与请求参数名称完全相同。该接收参数方式适用于 get 和 post 提交请求方式。示例代码如下（理解如上）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String name, String pwd, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(user.getName()) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(user.getPwd())) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="（3）通过HttpServletRequest接收请求参数"><a href="#（3）通过HttpServletRequest接收请求参数" class="headerlink" title="（3）通过HttpServletRequest接收请求参数"></a>（3）通过HttpServletRequest接收请求参数</h2><p>通过 HttpServletRequest 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request, Model model)</span> </span>&#123;</span><br><span class="line">    String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String pwd = request.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（4）通过-PathVariable接收URL中的请求参数"><a href="#（4）通过-PathVariable接收URL中的请求参数" class="headerlink" title="（4）通过@PathVariable接收URL中的请求参数"></a>（4）通过@PathVariable接收URL中的请求参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login/&#123;name&#125;/&#123;pwd&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@PathVariable</span> String name, <span class="meta">@PathVariable</span> String pwd, Model model)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123; </span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在访问“<a href="http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456%E2%80%9D%E8%B7%AF%E5%BE%84%E6%97%B6%EF%BC%8C%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86">http://localhost:8080/springMVCDemo02/user/register/bianchengbang/123456”路径时，上述代码会自动将</a> URL 中的模板变量 {name} 和 {pwd} 绑定到通过 @PathVariable 注解的同名参数上，即 name&#x3D;bianchengbang、pwd&#x3D;123456。</p>
<h2 id="（5）通过-RequestParam接收请求参数"><a href="#（5）通过-RequestParam接收请求参数" class="headerlink" title="（5）通过@RequestParam接收请求参数"></a>（5）通过@RequestParam接收请求参数</h2><p>在方法入参处使用 @RequestParam 注解指定其对应的请求参数。@RequestParam 有以下三个参数：</p>
<ul>
<li>value：参数名</li>
<li>required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常</li>
<li>defaultValue：参数默认值</li>
</ul>
<p>通过 @RequestParam 接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="meta">@RequestParam</span> String pwd, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name)&amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方式与“通过处理方法的形参接收请求参数”部分的区别如下：当请求参数与接收参数名不一致时，“通过处理方法的形参接收请求参数”不会报 404 错误，而“通过 @RequestParam 接收请求参数”会报 404 错误。</p>
<h2 id="（6）通过-ModelAttribute接收请求参数"><a href="#（6）通过-ModelAttribute接收请求参数" class="headerlink" title="（6）通过@ModelAttribute接收请求参数"></a>（6）通过@ModelAttribute接收请求参数</h2><p>@ModelAttribute 注解用于将多个请求参数封装到一个实体对象中，从而简化数据绑定流程，而且自动暴露为模型数据，在视图页面展示时使用。</p>
<p>而“通过实体 Bean 接收请求参数”中只是将多个请求参数封装到一个实体对象，并不能暴露为模型数据（需要使用 model.addAttribute 语句才能暴露为模型数据，数据绑定与模型数据展示后面教程中会讲解）。</p>
<p>通过 @ModelAttribute 注解接收请求参数适用于 get 和 post 提交请求方式，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@ModelAttribute(&quot;user&quot;)</span> User user, Model model)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bianchengbang&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>; <span class="comment">// 登录成功，跳转到 main.jsp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九，Spring-MVC重定向和转发"><a href="#九，Spring-MVC重定向和转发" class="headerlink" title="九，Spring MVC重定向和转发"></a>九，Spring MVC重定向和转发</h1><p>Spring MVC 请求方式分为转发、重定向 2 种，分别使用 forward 和 redirect 关键字在 controller 层进行处理。</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">转发</th>
<th align="left">重定向</th>
</tr>
</thead>
<tbody><tr>
<td>含义：</td>
<td align="left">转发是将用户对当前处理的请求转发给另一个视图或处理请求，以前的 request 中存放的信息不会失效。</td>
<td align="left">重定向是将用户从当前处理请求定向到另一个视图（例如 JSP）或处理请求，以前的请求（request）中存放的信息全部失效，并进入一个新的 request 作用域</td>
</tr>
<tr>
<td>对象：</td>
<td align="left">服务器</td>
<td align="left">客户端</td>
</tr>
<tr>
<td>过程：</td>
<td align="left">客户浏览器发送 http 请求，Web 服务器接受此请求，调用内部的一个方法在容器内部完成请求处理和转发动作，将目标资源发送给客户；在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request。</td>
<td align="left">客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的 location 地址，服务器根据此请求寻找资源并发送给客户。</td>
</tr>
<tr>
<td>理解:</td>
<td align="left">在客户浏览器的地址栏中显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</td>
<td align="left">这里 location 可以重定向到任意 URL，既然是浏览器重新发出了请求，那么就没有什么 request 传递的概念了。在客户浏览器的地址栏中显示的是其重定向的路径，客户可以观察到地址的变化。重定向行为是浏览器做了至少两次的访问请求。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转发到一个请求方法（同一个控制器类可以省略/index/）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foward:/index/isLogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/isLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">isLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重定向到一个请求方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index/isRegister&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/isRegister&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">isRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//转发到一个视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十，-Autowired和-Service注解"><a href="#十，-Autowired和-Service注解" class="headerlink" title="十，@Autowired和@Service注解"></a>十，@Autowired和@Service注解</h1><h2 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h2><p>@Autowired注解对类成员变量、方法及构造函数进行标注，完成自动装配的工作。也就是从容器中找对应的使用</p>
<p>@Service注解会将标注类自动注册到 Spring 容器中。</p>
<p>使用的时候在配置文件中添加下面的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;com.zhao.service&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h2><p>1，创建bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，在com.zhao.service中创建UserService.java接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3，在com.zhao.service中创建UserServiceImpl.java实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解保证这个类能被Spring扫描和管理</span></span><br><span class="line"><span class="meta">@servcie</span></span><br><span class="line"><span class="keyword">public</span> UserServiceImpl implements UserService&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhao&quot;</span>.equals(user.getUserName()) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(user.getPwd()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhao&quot;</span>.equals(user.getUserName()) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(user.getPwd()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4，在com.zhao.controller中创建UserController.java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="comment">//会使 UserService 的一个实例被注入到 UserController 实例中</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        User user =<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;zhao&quot;</span>);</span><br><span class="line">        userServcie.login(user);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;User user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        User user =<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;zhao&quot;</span>);</span><br><span class="line">        userServcie.register(user);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;User user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5，配置springmvc-servlet.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6，配置web.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 部署 DispatcherServlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理所有URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7，index.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    未注册的用户，请</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/user/register&quot;</span>&gt; 注册&lt;/a&gt;！</span><br><span class="line">    &lt;br /&gt; 已注册的用户，去</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath &#125;/user/login&quot;</span>&gt; 登录&lt;/a&gt;！</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>8，login.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    登录页面！ 欢迎 $&#123;user.name&#125; 登录</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>9，register.jsp文件内容</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">         pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    注册页面！</span><br><span class="line">    注册账号成功，用户名为： $&#123;user.name &#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-3-6.png" alt="js-3-6" style="zoom:80%;" />







































































































































































































]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>js-4-Redis</title>
    <url>/2022/04/25/js-5-Redis/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是理清redis常考点</p>
<span id="more"></span>

<h1 id="一，Redis基础概念和数据类型"><a href="#一，Redis基础概念和数据类型" class="headerlink" title="一，Redis基础概念和数据类型"></a>一，Redis基础概念和数据类型</h1><h2 id="1，Redis是什么？为什么要用？"><a href="#1，Redis是什么？为什么要用？" class="headerlink" title="1，Redis是什么？为什么要用？"></a>1，Redis是什么？为什么要用？</h2><p>Redis是一款内存高速缓存数据库，是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p>
<p>Redis有很多优势，比如数据类型丰富，操作都是原子性的，可以持久化，以及实现分布式</p>
<h2 id="2，Redis使用场景"><a href="#2，Redis使用场景" class="headerlink" title="2，Redis使用场景"></a>2，Redis使用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>热点数据的缓存</td>
<td>有两中方式：1，读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis；2， 插入数据时，同时写入Redis。</td>
</tr>
<tr>
<td>限时业务的使用</td>
<td>可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景</td>
</tr>
<tr>
<td>计数器相关问题</td>
<td>ncrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求</td>
</tr>
<tr>
<td>分布式锁</td>
<td>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0</td>
</tr>
<tr>
<td>延时操作</td>
<td>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。</td>
</tr>
<tr>
<td>排行榜相关</td>
<td>做一个SortedSet, 并以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，再根据username获取用户的hash信息</td>
</tr>
<tr>
<td>相互关系</td>
<td>微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</td>
</tr>
<tr>
<td>简单队列</td>
<td>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作</td>
</tr>
</tbody></table>
<h2 id="3，五种基本数据类型"><a href="#3，五种基本数据类型" class="headerlink" title="3，五种基本数据类型"></a>3，五种基本数据类型</h2><p>首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。</p>
<h3 id="（1）String"><a href="#（1）String" class="headerlink" title="（1）String"></a>（1）String</h3><p>String类型是二进制安全的， redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220907163155845.png" alt="image-20220907163155845" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取存储在给定键中的值</td>
<td>GET name</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
<td>SET name value</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值</td>
<td>DEL name</td>
</tr>
<tr>
<td>INCR</td>
<td>将键存储的值加1</td>
<td>INCR key</td>
</tr>
<tr>
<td>DECR</td>
<td>将键存储的值减1</td>
<td>DECR key</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将键存储的值加上整数</td>
<td>INCRBY key amount</td>
</tr>
<tr>
<td>DECRBY</td>
<td>将键存储的值减去整数</td>
<td>DECRBY key amount</td>
</tr>
</tbody></table>
<p><strong>实战场景</strong></p>
<ul>
<li><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li><strong>session</strong>：常见方案spring session + redis实现session共享，</li>
</ul>
<h3 id="（2）List"><a href="#（2）List" class="headerlink" title="（2）List"></a>（2）List</h3><p>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220907163657575.png" alt="image-20220907163657575" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>RPUSH</td>
<td>将给定值推入到列表右端</td>
<td>RPUSH key value</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将给定值推入到列表左端</td>
<td>LPUSH key value</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的右端弹出一个值，并返回被弹出的值</td>
<td>RPOP key</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的左端弹出一个值，并返回被弹出的值</td>
<td>LPOP key</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
<td>LRANGE key 0 -1</td>
</tr>
<tr>
<td>LINDEX</td>
<td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td>
<td>LINDEX key index</td>
</tr>
</tbody></table>
<ul>
<li><strong>实战场景</strong><ul>
<li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
<li><strong>消息队列</strong></li>
</ul>
</li>
</ul>
<h3 id="（3）Set"><a href="#（3）Set" class="headerlink" title="（3）Set"></a>（3）Set</h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220907165627100.png" alt="image-20220907165627100" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>SADD</td>
<td>向集合添加一个或多个成员</td>
<td>SADD key value</td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的成员数</td>
<td>SCARD key</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合中的所有成员</td>
<td>SMEMBERS key member</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>判断 member 元素是否是集合 key 的成员</td>
<td>SISMEMBER key member</td>
</tr>
</tbody></table>
<ul>
<li><strong>实战场景</strong><ul>
<li><strong>标签</strong>（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li>
<li><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</li>
</ul>
</li>
</ul>
<h3 id="（4）Zset"><a href="#（4）Zset" class="headerlink" title="（4）Zset"></a>（4）Zset</h3><p>Redis 的 Zset和 set 一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220907170419921.png" alt="image-20220907170419921" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD</td>
<td>将一个带有给定分值的成员添加到有序集合里面</td>
<td>ZADD zset-key 178 member1</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td>
<td>ZRANGE zset-key 0-1 withccores</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td>
<td>ZREM zset-key member1</td>
</tr>
</tbody></table>
<p><strong>实战场景</strong></p>
<ul>
<li><strong>排行榜</strong>：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行</li>
</ul>
<h3 id="（5）Hash"><a href="#（5）Hash" class="headerlink" title="（5）Hash"></a>（5）Hash</h3><p>一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220907170516147.png" alt="image-20220907170516147" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>HSET</td>
<td>添加键值对</td>
<td>HSET hash-key sub-key1 value1</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
<td>HGET hash-key key1</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列中包含的所有键值对</td>
<td>HGETALL hash-key</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列中，那么就移除这个键</td>
<td>HDEL hash-key sub-key1</td>
</tr>
</tbody></table>
<ul>
<li>实战场景<ul>
<li><strong>缓存</strong>： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li>
</ul>
</li>
</ul>
<h2 id="4，三种特殊数据类型"><a href="#4，三种特殊数据类型" class="headerlink" title="4，三种特殊数据类型"></a>4，三种特殊数据类型</h2><h3 id="（1）HyperLogLogs（基数统计）"><a href="#（1）HyperLogLogs（基数统计）" class="headerlink" title="（1）HyperLogLogs（基数统计）"></a>（1）HyperLogLogs（基数统计）</h3><p>A &#x3D; {1, 2, 3, 4, 5}， B &#x3D; {3, 5, 6, 7, 9}；那么基数（不重复的元素）&#x3D; 1, 2, 4, 6, 7, 9。这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p>
<h3 id="（2）Bitmap（位存储）"><a href="#（2）Bitmap（位存储）" class="headerlink" title="（2）Bitmap（位存储）"></a>（2）Bitmap（位存储）</h3><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p>
<p>可以用来统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！如果存储一年的打卡状态需要多少内存呢？ 365 天 &#x3D; 365 bit 1字节 &#x3D; 8bit 46 个字节左右！</p>
<h3 id="（3）geospatial（地理位置）"><a href="#（3）geospatial（地理位置）" class="headerlink" title="（3）geospatial（地理位置）"></a>（3）geospatial（地理位置）</h3><p>这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p>
<h1 id="二，Redis持久化"><a href="#二，Redis持久化" class="headerlink" title="二，Redis持久化"></a>二，Redis持久化</h1><h2 id="1，简介"><a href="#1，简介" class="headerlink" title="1，简介"></a>1，简介</h2><p>Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。</p>
<p>通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis。导致程序响应慢。</p>
<p>所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</p>
<h2 id="2，RDB持久化"><a href="#2，RDB持久化" class="headerlink" title="2，RDB持久化"></a>2，RDB持久化</h2><p>RDB 就是 Redis DataBase 的缩写，中文名为快照&#x2F;内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p>
<h3 id="（1）如何触发"><a href="#（1）如何触发" class="headerlink" title="（1）如何触发"></a>（1）如何触发</h3><p><strong>手动触发</strong>：</p>
<p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</p>
<p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件。阻塞只发生在fork阶段，一般时间很短。</p>
<p><strong>自动触发</strong>：</p>
<p>1，redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</p>
<p>2，执行debug reload命令重新加载redis时也会触发bgsave操作；</p>
<p>3，默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</p>
<h3 id="（2）在redis-conf中配置RDB"><a href="#（2）在redis-conf中配置RDB" class="headerlink" title="（2）在redis.conf中配置RDB"></a>（2）在redis.conf中配置RDB</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 周期性执行条件的设置格式为</span></span><br><span class="line"><span class="attr">save</span> <span class="string">&lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认的设置为：</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1 #如果900秒内有1条Key信息发生变化，则进行快照；</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 以下设置方式为关闭RDB快照功能</span></span><br><span class="line"><span class="attr">save</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/home/work/app/redis/data/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）几个问题"><a href="#（3）几个问题" class="headerlink" title="（3）几个问题"></a>（3）几个问题</h3><p><strong>问：由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？</strong></p>
<p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p>
<p><strong>问：在进行快照操作的这段时间，如果发生服务崩溃怎么办</strong>？</p>
<p>在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。</p>
<p><strong>问：可以每秒做一次快照吗</strong>？</p>
<p>不太好，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。</p>
<p>虽然 bgsave 执行时不阻塞主线程，但是，<strong>如果频繁地执行全量快照，也会带来两方面的开销</strong>：</p>
<ul>
<li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li>
</ul>
<h3 id="（4）优缺点"><a href="#（4）优缺点" class="headerlink" title="（4）优缺点"></a>（4）优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>RDB文件是某个时间节点的快照，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li>
<li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>RDB方式实时性不够，无法做到秒级的持久化；</li>
<li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li>
</ul>
<h2 id="3，AOF持久化"><a href="#3，AOF持久化" class="headerlink" title="3，AOF持久化"></a>3，AOF持久化</h2><p>AOF采用写后日志的方式，记录对数据操作，也就是将每一次操作命令存下来，恢复数据的时候再执行一遍。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220912165224082.png" alt="image-20220912165224082" style="zoom:80%;" />



<h3 id="（1）如何实现AOF"><a href="#（1）如何实现AOF" class="headerlink" title="（1）如何实现AOF"></a>（1）如何实现AOF</h3><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p>
<p><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</p>
<p><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</p>
<p><code>Always</code>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p>
<p><code>Everysec</code>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p>
<p><code>No</code>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p>
<h3 id="（2）redis-conf中配置AOF"><a href="#（2）redis-conf中配置AOF" class="headerlink" title="（2）redis.conf中配置AOF"></a>（2）redis.conf中配置AOF</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># appendonly参数开启AOF持久化</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># AOF持久化的文件名，默认是appendonly.aof</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 同步策略</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line"><span class="meta">no-appendfsync-on-rewrite</span> <span class="string">no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="meta">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 加载aof出错如何处理</span></span><br><span class="line"><span class="meta">aof-load-truncated</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件重写策略</span></span><br><span class="line"><span class="meta">aof-rewrite-incremental-fsync</span> <span class="string">yes</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）深入理解AOF重写"><a href="#（3）深入理解AOF重写" class="headerlink" title="（3）深入理解AOF重写"></a>（3）深入理解AOF重写</h3><p><strong>指令的简化</strong>：</p>
<p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220912163316880.png" alt="image-20220912163316880" style="zoom:80%;" />

<p><strong>重写时新数据如何处理？</strong></p>
<p>重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。</p>
<p>如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）</p>
<p>而在bgrewriteaof子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。</p>
<p>最后通过修改文件名的方式，保证文件切换的原子性。</p>
<p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220912165658434.png" alt="image-20220912165658434" style="zoom:80%;" />

<p><strong>为什么AOF重写不复用原AOF日志</strong>？</p>
<p>两方面原因：</p>
<ol>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li>
</ol>
<h2 id="4，RDB和AOF混用的方式"><a href="#4，RDB和AOF混用的方式" class="headerlink" title="4，RDB和AOF混用的方式"></a>4，RDB和AOF混用的方式</h2><p>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220918094900861.png" alt="image-20220918094900861" style="zoom:80%;" />

<h2 id="5，从持久化中恢复数据"><a href="#5，从持久化中恢复数据" class="headerlink" title="5，从持久化中恢复数据"></a>5，从持久化中恢复数据</h2><img src="https://raw.githubusercontent.com/zhao-xxxx/Picture/main/img/image-20220918100015090.png" alt="image-20220918100015090" style="zoom: 50%;" />

<p>有AOF则用AOF，没有则用RDB，因为AOF基本上最多损失1s的数据</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/02/06/js-1-spring/</url>
    <content><![CDATA[<p>title: Spring知识点<br>categories: Spring框架<br>tags: Spring5<br>top: xxx<br>date: 2022-02-06 16:04:38</p>
<p><strong>简介：</strong>Spring是目前java后端开发最核心，最基础的框架之一。网络上已经有很多资源，本文的主要目标为总结和整理学习中遇到的知识点，集百家之长和自己的实践，去粗取精。参考的资料有：，<a href="http://c.biancheng.net/spring/spring-abc.html">C语言中文网Spring教程</a>，<a href="http://www.voidme.com/spring">小白教程</a>，<a href="https://github.com/Snailclimb/JavaGuide">Java Guide</a></p>
<span id="more"></span>

<h1 id="一，认识Spring"><a href="#一，认识Spring" class="headerlink" title="一，认识Spring"></a>一，认识Spring</h1><h2 id="1，Spring是什么"><a href="#1，Spring是什么" class="headerlink" title="1，Spring是什么"></a>1，Spring是什么</h2><h3 id="（1），诞生于发展"><a href="#（1），诞生于发展" class="headerlink" title="（1），诞生于发展"></a>（1），诞生于发展</h3><p>早期的 J2EE（Java EE 平台）推崇以 EJB 为核心的开发方式，但这种开发方式在实际的开发过程中存在种种弊端，例如使用复杂、代码臃肿、代码侵入性强、开发周期长、移植难度大等。</p>
<p>Rod Johnson 在其 2002 年编著的畅销书《Expert One-on-One J2EE Design and Development》中，针对 EJB 各种臃肿的结构进行了逐一的分析和否定，并分别以更加简洁的方式进行了替换。这本书影响甚远，后来 Rod Johnson 将代码开源，并把这个新框架并命名为“Spring”，含义为：Spring 像一缕春风一样，扫平传统 J2EE 的寒冬。</p>
<p>2003 年 2 月，Spring 0.9 版本发布，；2004 年 4 月，Spring 1.0 版本正式发布。到目前为止，Spring 已经步入到了第 5 个大版本，也就是我们常说的 Spring 5。</p>
<h3 id="（2），Spring的含义"><a href="#（2），Spring的含义" class="headerlink" title="（2），Spring的含义"></a>（2），Spring的含义</h3><p><strong>广义：</strong>指代Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p><strong>狭义：</strong>特指 Spring Framework，通常我们将它称为 Spring 框架。Spring 有两个核心部分： IOC 和 AOP。</p>
<table>
<thead>
<tr>
<th>核心</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>IOC</td>
<td align="center">Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。</td>
</tr>
<tr>
<td>AOP</td>
<td align="center">Aspect Oriented Programming 的简写，译为“面向切面编程”。                                                                           AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。</td>
</tr>
</tbody></table>
<h3 id="（3），特点"><a href="#（3），特点" class="headerlink" title="（3），特点"></a>（3），特点</h3><ul>
<li>方便解耦，简化开发</li>
<li>方便集成各种优秀框架</li>
<li>降低 Java EE API 的使用难度</li>
<li>方便程序的测试</li>
<li>AOP 编程的支持</li>
<li>声明式事务的支持</li>
</ul>
<h2 id="2，Spring体系结构"><a href="#2，Spring体系结构" class="headerlink" title="2，Spring体系结构"></a>2，Spring体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-1.png" alt="js-1-1"></p>
<p>  从上图可以看出，Spring架构中有5个模块，在我们后面的学习中，经常导入的一些包属于哪个模块，要有了解。</p>
<h3 id="（1），Data-Access-x2F-Integration（数据访问／集成）"><a href="#（1），Data-Access-x2F-Integration（数据访问／集成）" class="headerlink" title="（1），Data Access&#x2F;Integration（数据访问／集成）"></a>（1），Data Access&#x2F;Integration（数据访问／集成）</h3><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，这里暂时不深入</p>
<h3 id="（2），Web-模块"><a href="#（2），Web-模块" class="headerlink" title="（2），Web 模块"></a>（2），Web 模块</h3><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Portlet 组件</p>
<h3 id="（3），Core-Container（Spring-的核心容器）"><a href="#（3），Core-Container（Spring-的核心容器）" class="headerlink" title="（3），Core Container（Spring 的核心容器）"></a>（3），Core Container（Spring 的核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。</p>
<ul>
<li>Beans 模块：提供了框架的基础部分，包括控制反转和依赖注入。</li>
<li>Core 核心模块：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Context 上下文模块：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li>
<li>SpEL 模块：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li>
</ul>
<h3 id="（4）AOP、Aspects、Instrumentation-和-Messaging"><a href="#（4）AOP、Aspects、Instrumentation-和-Messaging" class="headerlink" title="（4）AOP、Aspects、Instrumentation 和 Messaging"></a>（4）AOP、Aspects、Instrumentation 和 Messaging</h3><p> Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p>
<ul>
<li>AOP 模块：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>messaging 模块：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li>
</ul>
<h3 id="（5）Test模块"><a href="#（5）Test模块" class="headerlink" title="（5）Test模块"></a>（5）Test模块</h3><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能</p>
<h1 id="二，第一个Spring程序"><a href="#二，第一个Spring程序" class="headerlink" title="二，第一个Spring程序"></a>二，第一个Spring程序</h1><h2 id="1，开发环境"><a href="#1，开发环境" class="headerlink" title="1，开发环境"></a>1，开发环境</h2><h3 id="（1）java-8的安装和IDE的准备"><a href="#（1）java-8的安装和IDE的准备" class="headerlink" title="（1）java 8的安装和IDE的准备"></a>（1）java 8的安装和IDE的准备</h3><p>这里不再赘述。</p>
<h3 id="（2）Spring下载"><a href="#（2）Spring下载" class="headerlink" title="（2）Spring下载"></a>（2）Spring下载</h3><p>Spring 下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a>  根据操作系统下载对应的版本</p>
<p>以5.3.13为例，下载后的目录结构如下，其中：docs 包含 Spring 的 API 文档和开发规范；libs包含开发需要的 jar 包和源码包；schema包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-2.png"></p>
<p>在 libs 目录中，包含了 Spring 框架提供的所有 jar 文件，其中有 4 个 jar 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块，具体如下表所示。</p>
<table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>spring-core-x.x.xx.jar</td>
<td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td>
</tr>
<tr>
<td>spring-beans-x.x.xx.jar</td>
<td>所有应用都要用到的，它包含访问配置文件、创建和管理 Bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。</td>
</tr>
<tr>
<td>spring-context-x.x.xx.jar</td>
<td>Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等。</td>
</tr>
<tr>
<td>spring-expression-x.x.xx.jar</td>
<td>定义了 Spring 的表达式语言。</td>
</tr>
</tbody></table>
<p><strong>注：</strong>除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息。Apache Common Logging API 下载地址：<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">https://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p>
<h2 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2,hello world"></a>2,hello world</h2><h3 id="（1）新建一个java项目，并将上面提到的5个jar包添加"><a href="#（1）新建一个java项目，并将上面提到的5个jar包添加" class="headerlink" title="（1）新建一个java项目，并将上面提到的5个jar包添加"></a>（1）新建一个java项目，并将上面提到的5个jar包添加</h3><p>两种编译器添加jar包的方式不一样</p>
<p>eclipse：<a href="https://blog.csdn.net/qq_21808961/article/details/81215590">https://blog.csdn.net/qq_21808961/article/details/81215590</a></p>
<p>idea：<a href="https://blog.csdn.net/hwt1070359898/article/details/90517291">https://blog.csdn.net/hwt1070359898/article/details/90517291</a></p>
<h3 id="（2）创建普通类并添加方法"><a href="#（2）创建普通类并添加方法" class="headerlink" title="（2）创建普通类并添加方法"></a>（2）创建普通类并添加方法</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-3.png" alt="js-1-3"></p>
<h3 id="（3）创建Spring配置文件，并配置新建的对象"><a href="#（3）创建Spring配置文件，并配置新建的对象" class="headerlink" title="（3）创建Spring配置文件，并配置新建的对象"></a>（3）创建Spring配置文件，并配置新建的对象</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-4.png" alt="js-1-4"></p>
<h3 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-5.png" alt="js-1-5"></p>
<p><strong>注：</strong>截图来源为尚硅谷Spring教程。</p>
<p><strong>总结：</strong>在本小节中，我们对Spring框架的准备和使用有了简单的了解，一个最简单的Spring程序必须包含5个包，分别是core，beans，context，expressions，以及logging。配置好之后使用的步骤有：1，对于一个类（比如例子中的User）；2，可以创建一个配置文件进行管理（bean1.xml，这个配置文件的文件头的内容是固定的）；3，在主程序中使用ClassPathXmlApplicationContext(“配置文件路径”)来进行读取，并获得一个ApplicationContext对象，使用这个对象的getBean方法便可以新建一个对象。</p>
<h1 id="三，什么是Spring-IOC"><a href="#三，什么是Spring-IOC" class="headerlink" title="三，什么是Spring IOC"></a>三，什么是Spring IOC</h1><h2 id="1，什么是IoC"><a href="#1，什么是IoC" class="headerlink" title="1，什么是IoC"></a>1，什么是IoC</h2><p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p>
<p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p>
<h2 id="2，IoC原理"><a href="#2，IoC原理" class="headerlink" title="2，IoC原理"></a>2，IoC原理</h2><p>首先我们需要了解一下IoC思想的出现和发展，推荐<a href="https://www.cnblogs.com/superjt/p/4311577.html">这篇博文</a></p>
<p>然后，本质上Spring IoC就是将对象创建的过程托管给一个IoC容器来进行，和简单工厂模式类似，但是Spring中采用了反射机制，通过读取配置文件类判断要创建的类。推荐<a href="https://www.cnblogs.com/zhuoqingsen/p/8592951.html">这篇博文</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-6.png" alt="js-1-6"></p>
<p>上图则为Sprin创建对象的一个简单的过程，左上角ApplicationContext接受读取配置文件的内容，并使用getBean方法来实例化对象，此时getBean中的字符串是”person”，匹配到配置文件中id为person的标签，并根据该标签下的其他属性通过反射机制创建该对象，该对象是单例，效率比new 高</p>
<h2 id="3，依赖注入（引）"><a href="#3，依赖注入（引）" class="headerlink" title="3，依赖注入（引）"></a>3，依赖注入（引）</h2><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”</p>
<p>在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    String bid;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，B 中存在一个 A 类型的对象属性 a，此时我们就可以说 B 的对象依赖于对象 a。而依赖注入就是就是基于这种“依赖关系”而产生的</p>
<p>我们知道，控制反转核心思想就是由 Spring 负责对象的创建。在对象创建过程中，Spring 会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p>
<p>依赖注入本质上是 <a href="http://c.biancheng.net/spring/attr-injection.html">Spring Bean 属性注入</a>的一种，只不过这个属性是一个对象属性而已</p>
<h2 id="4，IoC容器的两种实现"><a href="#4，IoC容器的两种实现" class="headerlink" title="4，IoC容器的两种实现"></a>4，IoC容器的两种实现</h2><p>IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架中的 IoC 容器有BeanFactory 和 ApplicationContext。</p>
<h3 id="（1），BeanFactory"><a href="#（1），BeanFactory" class="headerlink" title="（1），BeanFactory"></a>（1），BeanFactory</h3><p> IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 。<strong>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</strong></p>
<h3 id="（2）-ApplicationContext："><a href="#（2）-ApplicationContext：" class="headerlink" title="（2） ApplicationContext："></a>（2） ApplicationContext：</h3><p> BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用。<strong>加载配置文件时候就会把在配置文件对象进行创建</strong>，并且它有实现类</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-7.png" alt="js-1-7"></p>
<p>这两个实现类的使用方式有些许不同，具体如下图：</p>
<table>
<thead>
<tr>
<th align="center">实现类</th>
<th align="center"><strong>描述</strong></th>
<th align="center">示例代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClassPathXmlApplicationContext</td>
<td align="center">加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(String configLocation);</td>
</tr>
<tr>
<td align="center">FileSystemXmlApplicationContext</td>
<td align="center">加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作</td>
<td align="center">ApplicationContext applicationContext &#x3D; new FileSystemXmlApplicationContext(String configLocation);</td>
</tr>
</tbody></table>
<blockquote>
<p>在上表的示例代码中，参数 configLocation 用于指定 Spring 配置文件的名称和位置，如 Beans.xml。</p>
</blockquote>
<h1 id="四，Spring中bean配置"><a href="#四，Spring中bean配置" class="headerlink" title="四，Spring中bean配置"></a>四，Spring中bean配置</h1><h2 id="1，Spring中bean管理——属性注入"><a href="#1，Spring中bean管理——属性注入" class="headerlink" title="1，Spring中bean管理——属性注入"></a>1，Spring中bean管理——属性注入</h2><p>前面说到，Spring中的bean在配置文件中进行了配置，那么属性的设置也在配置文件中进行，下面我们将从普通属性注入（构造器注入，setter注入，短命名空间注入），以及特殊属性注入（内部bean，集合，其他属性）</p>
<h3 id="（1）普通属性–构造器注入"><a href="#（1）普通属性–构造器注入" class="headerlink" title="（1）普通属性–构造器注入"></a>（1）普通属性–构造器注入</h3><p>使用构造函数实现属性注入大致步骤如下：</p>
<ol>
<li><p>在 Bean 中添加一个有参构造函数，构造函数内的每一个参数代表一个需要注入的属性；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，通过 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <constructor-arg> 元素，对构造函数内的属性进行赋值，Bean 的构造函数内有多少参数，就需要使用多少个 <constructor-arg> 元素。</p>
<p>下图就是一个使用构造器注入的例子，student有一个构造器，包含三个参数的初试化过程。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-8.png" alt="js-1-8"></p>
<h3 id="（2）setter注入（重点）"><a href="#（2）setter注入（重点）" class="headerlink" title="（2）setter注入（重点）"></a>（2）setter注入（<strong>重点</strong>）</h3><p>在 Spring 实例化 Bean 的过程中，IoC 容器首先会调用默认的构造方法（无参构造方法）实例化 Bean（Java 对象），然后通过 Java 的反射机制调用这个 Bean 的 setXxx() 方法，将属性值注入到 Bean 中。</p>
<p>使用 setter 注入的方式进行属性注入，大致步骤如下：</p>
<ol>
<li><p>在 Bean 中提供一个默认的无参构造函数（在没有其他带参构造函数的情况下，可省略），并为所有需要注入的属性提供一个 setXxx() 方法；</p>
</li>
<li><p>在 Spring 的 XML 配置文件中，使用 <beans> 及其子元素 <bean> 对 Bean 进行定义；</p>
</li>
<li><p>在 <bean> 元素内使用 <property> 元素对各个属性进行赋值。</p>
<p>下图为一个使用setter方法注入的例子，student类中的id，name，grade属性都有set方法</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-9.png" alt="js-1-9"></p>
<h3 id="（3）短命名空间注入"><a href="#（3）短命名空间注入" class="headerlink" title="（3）短命名空间注入"></a>（3）短命名空间注入</h3><h4 id="p命名空间注入"><a href="#p命名空间注入" class="headerlink" title="p命名空间注入"></a><strong>p命名空间注入</strong></h4><p>p 命名空间是 setter 方式属性注入的一种快捷实现方式。通过它，我们能够以 bean 属性的形式实现 setter 方式的属性注入，而不再使用嵌套的 <property> 元素，以实现简化 Spring 的 XML 配置的目的。</p>
<p>使用 p 命名空间注入依赖时，必须注意以下 3 点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）；</li>
<li>在使用 p 命名空间实现属性注入前，XML 配置的 <beans> 元素内必须先导入 p 命名空间的 XML 约束。</li>
</ul>
<p>下图是一个p标签的例子，其中在xml文件头部必须要导入以下 XML 约束，然后employee类中有empName，dept，empNo属性以及对应对应的get和set方法，dept是一个类。在bean文件的其他部分已经进行了配置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-10.png" alt="js-1-10"></p>
<p><strong>c命名空间注入</strong></p>
<p>c命名空间用的比较少，这里不再介绍</p>
<h2 id="2，Spring中bean管理——内部bean注入"><a href="#2，Spring中bean管理——内部bean注入" class="headerlink" title="2，Spring中bean管理——内部bean注入"></a>2，Spring中bean管理——内部bean注入</h2><h3 id="（1）setter-方式注入内部-Bean"><a href="#（1）setter-方式注入内部-Bean" class="headerlink" title="（1）setter 方式注入内部 Bean"></a>（1）setter 方式注入内部 Bean</h3><p>我们可以通过 setter 方式注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <property> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义。</p>
<p><strong>需要注意的是</strong>，内部 Bean 都是匿名的，不需要指定 id 和 name 的。即使制定了，IoC 容器也不会将它作为区分 Bean 的标识符，反而会无视 Bean 的 Scope 标签。因此内部 Bean 几乎总是匿名的，且总会随着外部的 Bean 创建。内部 Bean 是无法被注入到它所在的 Bean 以外的任何其他 Bean 的。</p>
<p>下图是一个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-11.png" alt="js-1-11"></p>
<h3 id="（2）构造函数方式注入内部-Bean"><a href="#（2）构造函数方式注入内部-Bean" class="headerlink" title="（2）构造函数方式注入内部 Bean"></a>（2）构造函数方式注入内部 Bean</h3><p>我们可以通过构造方法注入内部 Bean。此时，我们只需要在 <bean> 标签下的 <constructor-arg> 元素中，再次使用 <bean> 元素对内部 Bean 进行定义，格式如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-12.png" alt="js-1-12"></p>
<h2 id="3，Spring中bean管理——集合注入"><a href="#3，Spring中bean管理——集合注入" class="headerlink" title="3，Spring中bean管理——集合注入"></a>3，Spring中bean管理——集合注入</h2><p>这里的集合包含以下几种</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><list></td>
<td>用于注入 list 类型的值，允许重复</td>
</tr>
<tr>
<td><set></td>
<td>用于注入 set 类型的值，不允许重复</td>
</tr>
<tr>
<td><map></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型</td>
</tr>
<tr>
<td><props></td>
<td>用于注入 key-value 的集合，其中 key 和 value 都是字符串类型</td>
</tr>
</tbody></table>
<h3 id="（1）集合中存放普通属性"><a href="#（1）集合中存放普通属性" class="headerlink" title="（1）集合中存放普通属性"></a>（1）集合中存放普通属性</h3><p>如下图，javaCollection类中，有四个参数，course，list，maps和sets，并且都有对应的get和set方法，那么使用property标签进行赋值，四种类型情况如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-13.png" alt="js-1-13"></p>
<h3 id="（2）集合中存放对象类型"><a href="#（2）集合中存放对象类型" class="headerlink" title="（2）集合中存放对象类型"></a>（2）集合中存放对象类型</h3><p>如下图，配置了三个course的实例，那么在javaCollection类中，进行配置的话，具体方式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-14.png" alt="js-1-14"></p>
<h3 id="（3）把集合注入部分提取出来"><a href="#（3）把集合注入部分提取出来" class="headerlink" title="（3）把集合注入部分提取出来"></a>（3）把集合注入部分提取出来</h3><p>首先是在配置文件中引入名称空间 util，然后util标签写好这个list（或者其他集合），在类中引用即可，这样写的话，可读性更高</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4，Spring中bean管理——其他类型属性注入"><a href="#4，Spring中bean管理——其他类型属性注入" class="headerlink" title="4，Spring中bean管理——其他类型属性注入"></a>4，Spring中bean管理——其他类型属性注入</h2><p>除了普通属性、对象属性（Bean）、集合等属性外，Spring 也能够将其他类型的属性注入到 Bean 中，例如 Null 值、字面量、复合物属性等。</p>
<h3 id="（1）注入Null值"><a href="#（1）注入Null值" class="headerlink" title="（1）注入Null值"></a>（1）注入Null值</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-15.png" alt="js-1-15"></p>
<h3 id="（2）注入空字符串"><a href="#（2）注入空字符串" class="headerlink" title="（2）注入空字符串"></a>（2）注入空字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-16.png" alt="js-1-16"></p>
<h3 id="（3）注入字面量"><a href="#（3）注入字面量" class="headerlink" title="（3）注入字面量"></a>（3）注入字面量</h3><p>在 XML 配置中“&lt;”、“&gt;”、“&amp;”等特殊字符是不能直接保存的，否则 XML 语法检查时就会报错。此时，我们可以通过以下两种方式将包含特殊符号的属性注入 Bean 中。</p>
<p>A，使用转义字符</p>
<p>在 XML 中，特殊符号经过转义可以进行赋值，这个转义的规则和HTML中的非常类似</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-17.png" alt="js-1-17"></p>
<p>B，使用短字符串 <![CDATA[]]> </p>
<p>通过短字符串 <![CDATA[]]> 将包含特殊符号的属性值包裹起来，可以让 XML 解析器忽略对其中内容的解析，以属性原本的样子注入到 Bean 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-18.png" alt="js-1-18"></p>
<p>（4）级联赋值</p>
<p>我们可以在 <bean> 的 <property> 子元素中，为它所依赖的 Bean 的属性进行赋值，这就是所谓的“级联属性赋值”。使用级联属性赋值时，需要注意以下 3点：</p>
<ul>
<li>Java 类中必须有 setter 方法；</li>
<li>Java 类中必须有无参构造器（默认存在）；</li>
<li>依赖其他 Bean 的类中，必须提供一个它依赖的 Bean 的 getXxx() 方法。</li>
</ul>
<p>如下图，exampleBean中有dependBean属性，最开始是在外面初始化，value值是“依赖Bean内部赋值”，然后是内部进行了级联属性赋值，最终的值更新为“级联属性赋值”</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-19.png" alt="js-1-19"></p>
<h1 id="五，Spring中bean的管理"><a href="#五，Spring中bean的管理" class="headerlink" title="五，Spring中bean的管理"></a>五，Spring中bean的管理</h1><h2 id="1，Spring-Bean的作用域"><a href="#1，Spring-Bean的作用域" class="headerlink" title="1，Spring Bean的作用域"></a>1，Spring Bean的作用域</h2><h3 id="（1）Bean的作用域的类型"><a href="#（1）Bean的作用域的类型" class="headerlink" title="（1）Bean的作用域的类型"></a>（1）Bean的作用域的类型</h3><p>我们可以在 <bean> 元素中添加 scope 属性来配置 Spring Bean 的作用范围。例如，如果每次获取 Bean 时，都需要一个新的 Bean 实例，那么应该将 Bean 的 scope 属性定义为 prototype，如果 Spring 需要每次都返回一个相同的 Bean 实例，则应将 Bean 的 scope 属性定义为 singleton。</p>
<p>Spring中，共有6中类型的作用域（这里我们只需要认识singleton和prototype即可）</p>
<table>
<thead>
<tr>
<th align="left">作用范围</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">默认值，单例模式，表示在 Spring 容器中只有一个 Bean 实例</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。  与 singleton 类似，但 singleton 表示每个 IoC 容器中仅有一个 Bean 实例，而一个 Web 应用中可能会存在多个 IoC 容器，但一个 Web 应用只会有一个 ServletContext，也可以说 application 才是 Web 应用中货真价实的单例模式。</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>在以上 6 种 Bean 作用域中，除了 singleton 和 prototype 可以直接在常规的 Spring IoC 容器（例如 ClassPathXmlApplicationContext）中使用外，剩下的都只能在基于 Web 的 ApplicationContext 实现（例如 XmlWebApplicationContext）中才能使用，否则就会抛出一个 IllegalStateException 的异常。</p>
<h3 id="（3）-singleton-和-prototype-区别"><a href="#（3）-singleton-和-prototype-区别" class="headerlink" title="（3） singleton 和 prototype 区别"></a>（3） singleton 和 prototype 区别</h3><p>第一 singleton 单实例， prototype 多实例 </p>
<p>第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象</p>
<h2 id="2，Bean的生命周期"><a href="#2，Bean的生命周期" class="headerlink" title="2，Bean的生命周期"></a>2，Bean的生命周期</h2><p>Spring中的bean的生命周期分为5个部分：1)bean的实例化 ；2) Bean的属性赋值；3）bean的初试化  ；4）bean的使用 ；5）bean的销毁</p>
<p>Spring 根据 Bean 的作用域来选择 Bean 的管理方式，</p>
<ul>
<li>对于 singleton 作用域的 Bean 来说，Spring IoC 容器能够精确地控制 Bean 何时被创建、何时初始化完成以及何时被销毁；</li>
<li>对于 prototype 作用域的 Bean 来说，Spring IoC 容器只负责创建，然后就将 Bean 的实例交给客户端代码管理，Spring IoC 容器将不再跟踪其生命周期</li>
</ul>
<h3 id="（1）Spring-生命周期流程"><a href="#（1）Spring-生命周期流程" class="headerlink" title="（1）Spring 生命周期流程"></a>（1）Spring 生命周期流程</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-20.png" alt="js-1-20"></p>
<p>这里每一步都有<a href="http://c.biancheng.net/spring/life-cycle.html">解释</a>，但是这里我们注意到：<u>如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</u></p>
<h3 id="（2）bean的生命周期设置"><a href="#（2）bean的生命周期设置" class="headerlink" title="（2）bean的生命周期设置"></a>（2）bean的生命周期设置</h3><p>有三种方式可以实现控制bean的生命周期，分别是1）通过接口实现；2）通过XML实现；3）使用注解实现。实际使用时，优先级为注解&gt;接口&gt;XML配置，这里我们以注解方式为例，来说明Bean实际的生命周期过程</p>
<p>通过 JSR-250 的 @PostConstruct 和 @PreDestroy 注解，指定 Bean 的生命周期回调方法。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@PostConstruct</td>
<td>指定初始化回调方法，这个方法会在 Spring Bean 被初始化后被调用，执行一些自定义的回调操作。</td>
</tr>
<tr>
<td>@PreDestroy</td>
<td>指定销毁回调方法，这个方法会在 Spring Bean 被销毁前被调用，执行一些自定义的回调操作。</td>
</tr>
</tbody></table>
<p>1，在 net.biancheng.c 包下，创建一个名为 AnnotationLifeCycleBean 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">//网站名称</span></span><br><span class="line">    <span class="keyword">private</span> String webName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeCycleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步，执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webName</span><span class="params">(String webname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webName = webname;</span><br><span class="line">		System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2，在 src 目录下，新建一个 Spring 配置文件 Beans.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过 XML 配置指定生命周期回调方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3，在 net.biancheng.c 包下，创建一个名为 MainApp 的 Java 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(MainApp.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取 ClassPathXmlApplicationContext 容器</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        LifeCycleBean LifeCycleBean = context.getBean(<span class="string">&quot;LifeCycleBean&quot;</span>, LifeCycleBean.class);</span><br><span class="line">       System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">        <span class="comment">//手动销毁 Bean</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置的话，打印的结果和上面的顺序一样，具体过程如下：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） </p>
<p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p>
<p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法） </p>
<p>（4） bean 可以使用了（对象获取到了） </p>
<p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h3 id="（3），Spring-后置处理器"><a href="#（3），Spring-后置处理器" class="headerlink" title="（3），Spring 后置处理器"></a>（3），Spring 后置处理器</h3><p>BeanPostProcessor 接口也被称为后置处理器，通过该接口可以自定义调用初始化前后执行的操作方法。该接口中包含了两个方法：</p>
<p> 1）postProcessBeforeInitialization() 方法：在 Bean 实例化、属性注入后，初始化前调用。          </p>
<p> 2）postProcessAfterInitialization() 方法：在 Bean 实例化、属性注入、初始化都完成后调用。</p>
<p>当需要添加多个后置处理器实现类时，默认情况下 Spring 容器会根据后置处理器的定义顺序来依次调用。也可以通过实现 Ordered 接口的 getOrder 方法指定后置处理器的执行顺序。该方法返回值为整数，默认值为 0，取值越大优先级越低。实现了后置处理器后，bean 生命周期有七步：</p>
<p>（1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（ 5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization （6） bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<p>在上一个例子的基础上，我们可以添加处理器，首先是添加一个InitHandler类，并实现BeanPostProcessor, Ordered两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitHandler</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;LifeCycleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.LifeCycleBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;webName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C语言中文网3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注册处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.InitHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么最后的运行结构就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-21.png" alt="js-1-21"></p>
<h2 id="3，bean的自动装配"><a href="#3，bean的自动装配" class="headerlink" title="3，bean的自动装配"></a>3，bean的自动装配</h2><h3 id="（1）背景："><a href="#（1）背景：" class="headerlink" title="（1）背景："></a>（1）背景：</h3><p>在以往的配置中，在 Bean 与 Bean 之间建立依赖关系的行为称为“装配”。在前面的内容中，我们可以在XML中通过<constructor-arg>和 <property>的ref属性，手动维护Bean与Bean之间的依赖关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过 &lt;property&gt; 元素维护 Employee 和 Dept 的依赖关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小规模的依赖关系可以手动操作，但是大规模的依赖，需要使用自动装配功能。</p>
<h3 id="（2）自动装配"><a href="#（2）自动装配" class="headerlink" title="（2）自动装配"></a>（2）自动装配</h3><p>bean 标签属性 autowire，配置自动装配 。autowire 属性常用两个值： </p>
<p>byName  表示按属性名称自动装配，XML 文件中 Bean 的 id 或 name 必须与类中的属性名称相同。</p>
<p>byType 表示按类中对象属性数据类型进行自动装配。即使 XML 文件中 Bean 的 id 或 name 与类中的属性名不               同，只要 Bean 的 class 属性值与类中的对象属性的类型相同，就可以完成自动装配。</p>
<p>对上面两种情况，下面给了对应的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">//。。。省略的其他属性</span></span><br><span class="line">    <span class="comment">//部门信息</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//省略构造器和其他属性get，set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,由于开启了自动装配，那么employee类在进行属性注入的时候，如果需要配置Dept，容器就会寻找到容器中id=&quot;dept&quot;的类，调用set方法进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部门 Dept 的 Bean 定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--雇员 Employee 的 Bean 定义,这里是byType进行装配，寻找容器中class属性为Dept的类，调用set进行配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.c.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>byName<br>从Spring环境中获取目标对象时，目标对象中的属性会根据名称在整个Spring环境中查找标签的id属性值。如果有相同的，那么获取这个对象，实现关联。整个Spring环境：表示所有的spring配置文件中查找，那么id不能有重复的。</p>
<p>byType<br>从Spring环境中获取目标对象时，目标对象中的属性会根据类型在整个spring环境中查找标签的class属性值。如果有相同的，那么获取这个对象，实现关联。</p>
<p>如果存在多个相同类型的bean对象，会出错；如果属性为单一类型的数据，那么查找到多个关联对象会发生错误；如果属性为数组或集合(泛型)类型，那么查找到多个关联对象不会发生异常。</p>
</blockquote>
<h2 id="4，基于注解的自动装配"><a href="#4，基于注解的自动装配" class="headerlink" title="4，基于注解的自动装配"></a>4，基于注解的自动装配</h2><p>Spring 通过注解实现自动装配的步骤如下：1，引入依赖；2，开启组件扫描；3，使用注解定义 Bean；4，依赖注入</p>
<h3 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>除了 spring 的四个基础 jar 包和 commons-logging-xxx.jar 外，想要使用注解实现 Spring 自动装配，还需要引入Spring 提供的 spring-aop 的 Jar 包。</p>
<h3 id="（2）开启组件扫描"><a href="#（2）开启组件扫描" class="headerlink" title="（2）开启组件扫描"></a>（2）开启组件扫描</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能，此时会扫描net.baincheng.c包下的所有代码，如果有注解标记的实体，便会装配到容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：在使用 <a href="context:component-scan">context:component-scan</a> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。（也就是第4行添加的内容）</p>
<h3 id="（3）使用注解定义Bean"><a href="#（3）使用注解定义Bean" class="headerlink" title="（3）使用注解定义Bean"></a>（3）使用注解定义Bean</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td>@Repository</td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Service</td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td>@Controller</td>
<td>该注解通常作用在控制层（如 Struts2 的 Action、SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<h3 id="（4）基于注解的方式实现依赖注入"><a href="#（4）基于注解的方式实现依赖注入" class="headerlink" title="（4）基于注解的方式实现依赖注入"></a>（4）基于注解的方式实现依赖注入</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>可以应用到 Bean 的属性变量、setter 方法、非 setter 方法及构造函数等，默认按照 Bean 的类型进行装配。@Autowired注解默认按照 Bean 的类型进行装配，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合 @Qualifier 注解一起使用</td>
</tr>
<tr>
<td>@Resource</td>
<td>作用与 Autowired 相同，区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 的名称进行装配。@Resource 中有两个重要属性：name 和 type。<br>1，Spring 将 name 属性解析为 Bean 的实例名称，type 属性解析为 Bean 的实例类型。<br/>2，如果指定 name 属性，则按实例名称进行装配；<br/>3，如果指定 type 属性，则按 Bean 类型进行装配；<br/>4，如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</td>
</tr>
</tbody></table>
<h3 id="（5）示例"><a href="#（5）示例" class="headerlink" title="（5）示例"></a>（5）示例</h3><p>A，创建Spring-autowire-demo工程，并导入要求的6个包（基本的5个加上Spring-aop-xxxx）</p>
<p>B，创建com.zhao.spring.dao包，并创建名为UserDao的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，创建com.zhao.spring.dao.impl包，在其中创建UserDao的实现类UserDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        system.out.print(<span class="string">&quot;进行了Dao层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，创建com.zhao.spring.servcie包，在其中创建UserServcie接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，创建com.zhao.spring.service.impl包，并创建UserServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> UserServcieImpl implements UserService&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">getUserDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.print(<span class="string">&quot;进行了Service层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>F,创建com.zhao.spring.controller包，并在包下创建UserController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;userController&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span><span class="comment">//能实现和@Autowired一样的效果</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServcie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.out;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了Controller层访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>G，在src目录下，创建配置文件Beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao.spirng&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>H，在com.zhao.spring包下，创建MainApplication.class，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        UserController userController = context.getBean(<span class="string">&quot;userController&quot;</span>,UserController.class);</span><br><span class="line">        userController.doStr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I，最后控制台输出应该是下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进行了Dao层访问</span><br><span class="line">进行了Service层访问</span><br><span class="line">进行了Controller层访问</span><br></pre></td></tr></table></figure>

<h2 id="5，外部属性文件的配置链接"><a href="#5，外部属性文件的配置链接" class="headerlink" title="5，外部属性文件的配置链接"></a>5，外部属性文件的配置链接</h2><p>在操作数据库时，我们经常会用到连接池对数据库链接进行管理，其中比较常用的就是Druid，有两种方式在Spring配置该数据库连接池。</p>
<p>（1）直接配置数据库信息</p>
<p>首先，引入Druid连接池依赖jar包</p>
<p>然后，在xml文件中配置连接池</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/userDb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）引入外部属性文件配置数据库连接池</p>
<p>首先，新建jdbc.properties配置文件，文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql://localhost:3306/userDb</span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>然后，把外部 properties 属性文件引入到 spring 配置文件中（注意引入 context 名称空间）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六，AOP面向切面编程"><a href="#六，AOP面向切面编程" class="headerlink" title="六，AOP面向切面编程"></a>六，AOP面向切面编程</h1><h2 id="1，认识AOP"><a href="#1，认识AOP" class="headerlink" title="1，认识AOP"></a>1，认识AOP</h2><h3 id="（1）目标"><a href="#（1）目标" class="headerlink" title="（1）目标"></a>（1）目标</h3><p>假设现在有一个电商系统，我们根据业务使用 OOP（面向对象）思想，将应用划分为多个不同的业务模块，例如订单模块、商品模块等。但是，除了这些功能模块，我们还需要一些一些非业务的通用功能，例如日志管理、权限管理、事务管理、异常管理等。这些功能可能贯穿所有业务模块。</p>
<p>理论上可以将这些非业务功能抽象为公共方法，但是这样代码间的耦合性就会非常高。我们想能不能让业务只专注与业务，添加非业务代码不会影响业务本身。</p>
<h3 id="（2）面向切面编程（AOP）"><a href="#（2）面向切面编程（AOP）" class="headerlink" title="（2）面向切面编程（AOP）"></a>（2）面向切面编程（AOP）</h3><p>AOP 的全称是“Aspect Oriented Programming”，译为“面向切面编程”，和 OOP（面向对象编程）类似，它也是一种编程思想。</p>
<p>与 OOP 中纵向的父子继承关系不同，AOP 是通过横向的抽取机制实现的。它将应用中的一些非业务的通用功能抽取出来单独维护，并通过声明的方式（例如配置文件、注解等）定义这些功能要以何种方式作用在那个应用中，而不是在业务模块的代码中直接调用。</p>
<p>这虽然设计公共函数有几分类似，但传统的公共函数除了在代码直接硬调用之外并没有其他手段。AOP 则为这一问题提供了一套灵活多样的实现方法（例如 Proxy 代理、拦截器、字节码翻译技术等），可以在无须修改任何业务代码的基础上完成对这些通用功能的调用和修改。</p>
<h3 id="（3）AOP实现（框架）"><a href="#（3）AOP实现（框架）" class="headerlink" title="（3）AOP实现（框架）"></a>（3）AOP实现（框架）</h3><table>
<thead>
<tr>
<th align="left">AOP 框架</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Spring AOP</td>
<td>是一款基于 AOP 编程的框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。  Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。Spring AOP 支持 2 种代理方式，分别是基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理。</td>
</tr>
<tr>
<td align="left">AspectJ</td>
<td>是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。  AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。</td>
</tr>
</tbody></table>
<h3 id="（4）AOP术语"><a href="#（4）AOP术语" class="headerlink" title="（4）AOP术语"></a>（4）AOP术语</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint（连接点）</td>
<td>AOP 的核心概念，指的是程序执行期间明确定义的一个点，例如方法的调用、类初始化、对象实例化等。 <strong>通俗说</strong>，类里面的可以被增强的方法（or变量），称之为连接点。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>又称切点，指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。<strong>通俗说</strong>，就是实际被增强的方法。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>指拦截到 Joinpoint 之后要执行的代码，即对切入点增强的内容。<strong>通俗说</strong>，实际增强的逻辑部分就称为通知</td>
</tr>
<tr>
<td>Target（目标）</td>
<td>指代理的目标对象，通常也被称为被通知（advised）对象。</td>
</tr>
<tr>
<td>Weaving（织入）</td>
<td>指把增强代码应用到目标对象上，生成代理对象的过程。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>指生成的代理对象。</td>
</tr>
<tr>
<td>Aspect（切面）</td>
<td>切面是切入点（Pointcut）和通知（Advice）的结合。<strong>通俗说，</strong>就是把通知应用到切入点的过程</td>
</tr>
</tbody></table>
<h2 id="2，Spring-AOP"><a href="#2，Spring-AOP" class="headerlink" title="2，Spring AOP"></a>2，Spring AOP</h2><h3 id="（1）Spring-AOP的代理机制"><a href="#（1）Spring-AOP的代理机制" class="headerlink" title="（1）Spring AOP的代理机制"></a>（1）Spring AOP的代理机制</h3><p>Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。</p>
<p>Spring AOP 的底层是通过以下 2 种动态代理机制，为目标对象（Target Bean）执行横向织入的。</p>
<table>
<thead>
<tr>
<th>代理技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 动态代理</td>
<td>Spring AOP 默认的动态代理方式，若目标对象实现了若干接口，Spring 使用 JDK 的 java.lang.reflect.Proxy 类进行代理。(也就是通过接口来实现一个对象来进行操作)</td>
</tr>
<tr>
<td>CGLIB 动态代理</td>
<td>若目标对象没有实现任何接口，Spring 则使用 CGLIB 库生成目标对象的子类，以实现对目标对象的代理。（创建一个类的子类来进行增强操作）</td>
</tr>
</tbody></table>
<p>对于使用JDK的 java.lang.reflect.Proxy 类进行代理，主要是考Proxy类的newProxyInstance 方法实现，该方法有三个参数，<u>第一参数</u>，类加载器；<u>第二参数</u>，增强方法所在的类，这个类实现的接口，支持多个接口；<u>第三参数</u>，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance (ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h);</span><br></pre></td></tr></table></figure>

<p>下面就贴一段代码帮助理解这样的代理具体是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，创建接口，定义方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2,创建接口实现类，实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3,使用Proxy类创建接口代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="comment">//这里的dao也就是加了增强逻辑了的</span></span><br><span class="line">        <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4,这里是代理对象的逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先这个有参构造器，是用来接受需要创建代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里填写增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="comment">//执行方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line">        <span class="comment">//被增强的方法执行（也就是调用原来的增强的方法）</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）Spring-AOP连接点"><a href="#（2）Spring-AOP连接点" class="headerlink" title="（2）Spring AOP连接点"></a>（2）Spring AOP连接点</h3><p>Spring AOP 并没有像其他 AOP 框架（例如 AspectJ）一样提供了完成的 AOP 功能，它是 Spring 提供的一种简化版的 AOP 组件。其中最明显的简化就是，Spring AOP 只支持一种连接点类型：方法调用。您可能会认为这是一个严重的限制，但实际上 Spring AOP 这样设计的原因是为了让 Spring 更易于访问。</p>
<p>方法调用连接点是迄今为止最有用的连接点，通过它可以实现日常编程中绝大多数与 AOP 相关的有用的功能。如果需要使用其他类型的连接点（例如成员变量连接点），我们可以将 Spring AOP 与其他的 AOP 实现一起使用，最常见的组合就是 Spring AOP + ApectJ。 </p>
<h3 id="（3）Spring-AOP通知类型"><a href="#（3）Spring-AOP通知类型" class="headerlink" title="（3）Spring AOP通知类型"></a>（3）Spring AOP通知类型</h3><table>
<thead>
<tr>
<th>通知类型</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
<td>在目标方法执行前实施增强。</td>
</tr>
<tr>
<td>后置通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行后实施增强。</td>
</tr>
<tr>
<td>后置返回通知</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
<td>在目标方法执行完成，并返回一个返回值后实施增强。</td>
</tr>
<tr>
<td>环绕通知</td>
<td>org.aopalliance.intercept.MethodInterceptor</td>
<td>在目标方法执行前后实施增强。</td>
</tr>
<tr>
<td>异常通知</td>
<td>org.springframework.aop.ThrowsAdvice</td>
<td>在方法抛出异常后实施增强。</td>
</tr>
<tr>
<td>引入通知</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
<td>在目标类中添加一些新的方法和属性。</td>
</tr>
</tbody></table>
<h2 id="3，Spring集成AspectJ"><a href="#3，Spring集成AspectJ" class="headerlink" title="3，Spring集成AspectJ"></a>3，Spring集成AspectJ</h2><p>Spring AOP 是一个简化版的 AOP 实现，并没有提供完整版的 AOP 功能。通常情况下，Spring AOP 是能够满足我们日常开发过程中的大多数场景的，但在某些情况下，我们可能需要使用 Spring AOP 范围外的某些 AOP 功能。例如 Spring AOP 仅支持执行公共（public）非静态方法的调用作为连接点，如果我们需要向受保护的（protected）或私有的（private）的方法进行增强，此时就需要使用功能更加全面的 AOP 框架来实现，其中使用最多的就是 AspectJ。</p>
<p>AspectJ 是一个基于 Java 语言的全功能的 AOP 框架，它并不是 Spring 组成部分，是一款独立的 AOP 框架。但由于 AspectJ 支持通过 Spring 配置 AspectJ 切面，因此它是 Spring AOP 的完美补充，通常情况下，我们都是将 AspectJ 和 Spirng 框架一起使用，简化 AOP 操作。</p>
<h3 id="（1）引入依赖-1"><a href="#（1）引入依赖-1" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><p>使用AspectJ需要引入一些依赖，这些包可以自行下载（红色为必须新增的，绿色则看情况）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-22.png" alt="js-1-22"></p>
<h3 id="（2）基于XML的AOP开发"><a href="#（2）基于XML的AOP开发" class="headerlink" title="（2）基于XML的AOP开发"></a>（2）基于XML的AOP开发</h3><p><u>A，引入aop命名空间（在xml文件头中引入）</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>B，定义切面</u></p>
<p>在 Spring 配置文件中，使用 &lt;aop:aspect&gt; 元素定义切面。该元素可以将定义好的 Bean 转换为切面 Bean，所以使用 &lt;aop:aspect&gt; 之前需要先定义一个普通的 Spring Bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用来定义该切面的唯一标识名称，ref 用于引用普通的 Spring Bean。</p>
<p><u>C，定义切入点&lt;aop:pointcut&gt;</u> </p>
<p>&lt;aop:pointcut&gt; 用来定义切入点，用来表示对哪个类中的那个方法进行增强。它既可以在 &lt;aop:pointcut&gt; 元素中使用，也可以在&lt;aop:pointcut&gt; 元素下使用。</p>
<ul>
<li>当&lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素定义时，表示该切入点是全局切入点，它可被多个切面所共享；</li>
<li>当 &lt;aop:pointcut&gt; 元素作为&lt;aop:pointcut&gt; 元素的子元素时，表示该切入点只对当前切面有效。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* net.biancheng.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，id 用于指定切入点的唯一标识名称，execution 用于指定切入点关联的切入点表达式。</p>
<p>execution 的语法格式格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([权限修饰符] [返回值类型] [类的完全限定名] [方法名称]([参数列表]) </span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>返回值类型、方法名、参数列表是必须配置的选项，而其它参数则为可选配置项。</li>
<li>返回值类型：<code>*</code>表示可以为任何返回值。如果返回值为对象，则需指定全路径的类名。</li>
<li>类的完全限定名：指定包名 + 类名。</li>
<li>方法名：<code>*</code>代表所有方法，<code>set*</code> 代表以 set 开头的所有方法。</li>
<li>参数列表：<code>(..)</code>代表所有参数；<code>(*)</code>代表只有一个参数，参数类型为任意类型；<code>(*,String)</code>代表有两个参数，第一个参数可以为任何值，第二个为 String 类型的值。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-23.png" alt="js-1-23"></p>
<p><u>D，定义通知</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;aBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 后置通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 环绕通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异常通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最终通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointCut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    .... </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>E，示例</u></p>
<p>E-1. 新建一个名为 my-spring-asepctj-demo 的 Java 项目，并将以下依赖 Jar 包导入到该项目中。</p>
<ul>
<li>commons-logging-1.2.jar</li>
<li>spring-aop-5.3.13.jar</li>
<li>spring-aspects-5.3.13.jar</li>
<li>spring-beans-5.3.13.jar</li>
<li>spring-context-5.3.13.jar</li>
<li>spring-core-5.3.13.jar</li>
<li>spring-expression-5.3.13.jar</li>
<li>aspectjweaver-1.9.7.jar</li>
</ul>
<p>E-2. 在 com.zhao.spring.dao 包下，创建一个名为 OrderDao 的接口，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-3.在 com.zhao.spring.dao.impl 包下，创建 OrderDao 的实现类 OrderDaoImpl，这是一个被增强类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 add() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行 OrderDao 中的 delete() 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-4. 在com.zhao.spring 包下，创建一个名为 MyOrderAspect 的类，这是一个增强类，用来实现一些增强方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderAspect</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终增强……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---前……&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强---后……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常增强…… 异常信息为：&quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置返回增强…… 方法返回值为：&quot;</span> + returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-5. 在 src 目录下创建一个 Spring 配置文件 Beans2.xml，配置内容如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义 Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.dao.impl.OrderDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myOrderAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhao.spring.MyOrderAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开始配置增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面是两个切面，前一个代表了对add方法进行增强，后一个代表对OrderDao类的所有方法进行增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;beforePointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.add(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;afterPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zhao.spring.dao.OrderDao.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面的这个aop:aspect使用了myOrderAspect增强类中的方法-&gt;</span></span><br><span class="line"><span class="comment">        &lt;aop:aspect ref=&quot;myOrderAspect&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;!--前置增强，这里使用before方法对add方法进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--后置返回增强，这个使用afterReturning方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterReturnPointCut&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">returning</span>=<span class="string">&quot;returnValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最终通知，这个使用after方法对add和delete方法都进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;afterPointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--环绕通知，这个使用aroud方法对add进行了增强--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;beforePointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>E-6. 在 net.biancheng.c 包下，创建一个名 MainApp 的类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans2.xml&quot;</span>);</span><br><span class="line">        OrderDao orderDao = context2.getBean(<span class="string">&quot;orderDao&quot;</span>, OrderDao.class);</span><br><span class="line">        orderDao.add();</span><br><span class="line">        System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">        orderDao.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-7. 执行 MainApp 中的 main 方法，控制台输出如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置增强……</span><br><span class="line">环绕增强---前……</span><br><span class="line">正在执行 OrderDao 中的 add() 方法</span><br><span class="line">环绕增强---后……</span><br><span class="line">最终增强……</span><br><span class="line">====</span><br><span class="line">正在执行 OrderDao 中的 delete() 方法</span><br><span class="line">后置返回增强…… 方法返回值为：1</span><br><span class="line">最终增强……</span><br></pre></td></tr></table></figure>

<h3 id="（3）基于AspectJ注解的AOP开发"><a href="#（3）基于AspectJ注解的AOP开发" class="headerlink" title="（3）基于AspectJ注解的AOP开发"></a>（3）基于AspectJ注解的AOP开发</h3><p>如果所有的配置都是在xml文件中进行，未免会使得配置文件变得非常臃肿。而AspectJ 框架为 AOP 开发提供了一套 @AspectJ 注解。它允许我们直接在 Java 类中通过注解的方式对切面（Aspect）、切入点（Pointcut）和增强（Advice）进行定义，Spring 框架可以根据这些注解生成 AOP 代理。这些注解主要是以下几种类别：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>用于定义一个切面。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>用于定义一个切入点。</td>
</tr>
<tr>
<td>@Before</td>
<td>用于定义前置通知，相当于 BeforeAdvice。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>用于定义后置通知，相当于 AfterReturningAdvice。</td>
</tr>
<tr>
<td>@Around</td>
<td>用于定义环绕通知，相当于 MethodInterceptor。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>用于定义抛出通知，相当于 ThrowAdvice。</td>
</tr>
<tr>
<td>@After</td>
<td>用于定义最终通知，不管是否异常，该通知都会执行。</td>
</tr>
</tbody></table>
<p>使用时，需要设置的几个点如下：</p>
<p><u>A，启用@AspectJ注解支持（两种形式）</u></p>
<p>1）使用 Java 配置类启用</p>
<p>我们可以在 Java 配置类（标注了 @Configuration 注解的类）中，使用 @EnableAspectJAutoProxy 和 @ComponentScan 注解启用 @AspectJ 注解支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;xxx&quot;)</span> <span class="comment">//注解扫描,扫描你想要管理的包及其下面的文件</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启 AspectJ 的自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）基于XML配置启用（<strong>！常用</strong>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启AspectJ 自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>B，定义切面（使用@Aspect注解）</u></p>
<p>一般使用两个注解来顶一个切面（切面一般是增强类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 定义成 Bean，这样再上一步被扫描后，该类就会作为一个bean被Spring管理</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>C，定义切点（使用@Pointcut切点）</u></p>
<p>在 AspectJ 中，我们可以使用 @Pointcut 注解用来定义一个切点。其中execution的格式参考上一节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意！！！方法必须是private，返回值类型为 void，名称自定义，没有参数</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(*net.biancheng..*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我除了可以通过切入点表达式（execution）直接对切点进行定义外，还可以通过切入点方法的名称来引用其他的切入点。在使用方法名引用其他切入点时，还可以使用“&amp;&amp;”、“||”和“!”等表示“与”、“或”、“非”的含义，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 net.biancheng.c.dao包下 UserDao 类中的 get() 方法定义为一个切点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 net.biancheng.c.dao包下 UserDao 类中的 delete() 方法定义为一个切点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.delete(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 除了 net.biancheng.c.dao包下 UserDao 类中 get() 方法和 delete() 方法外，其他方法都定义为切点</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ！ 表示 非 ，即 &quot;不是&quot; 的含义，求补集</span></span><br><span class="line"><span class="comment">* * &amp;&amp; 表示 与，即 ”并且“ ，求交集</span></span><br><span class="line"><span class="comment">* || 表示 或，即 “或者”，求并集</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Pointcut(value =&quot;!pointCut1() &amp;&amp; !pointCut2()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>D，定义通知</u></p>
<p>AspectJ 为我们提供了以下 6 个注解，来定义 6 种不同类型的通知（Advice），如下表。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Before</td>
<td>用于定义前置通知，相当于 BeforeAdvice。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>用于定义后置通知，相当于 AfterReturningAdvice。</td>
</tr>
<tr>
<td>@Around</td>
<td>用于定义环绕通知，相当于 MethodInterceptor。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>用于定义抛出通知，相当于 ThrowAdvice。</td>
</tr>
<tr>
<td>@After</td>
<td>用于定义最终通知，不管是否异常，该通知都会执行。</td>
</tr>
<tr>
<td>@DeclareParents</td>
<td>用于定义引介通知，相当于 IntroductionInterceptor（不要求掌握）。</td>
</tr>
</tbody></table>
<p>以上这些通知注解中都有一个 value 属性，这个 value 属性的取值就是这些通知（Advice）作用的切点（PointCut），它既可以是切入点表达式，也可以是切入点的引用（切入点对应的方法名称），示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Pointcut(value =&quot;execution(* net.biancheng.c.dao.UserDao.delete(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut2</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Pointcut(value =&quot;!pointCut1() &amp;&amp; !pointCut2()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用切入点引用</span></span><br><span class="line"><span class="meta">@Before(&quot;MyAspect.pointCut3()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕增强……&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用切入点表达式</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* net.biancheng.c.dao.UserDao.get(..))&quot; ,returning = &quot;returnValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法返回值为：&quot;</span>+returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>E，示例</u></p>
<p>E-1，在com.zhao.dao包下创建UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-2，在com.zhao.dao.impl包下创建UserDaoImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span><span class="comment">//将这个类交给Spring容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行add方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行delete方法&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-3，在Spring的配置文件中开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启AspectJ 自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>E-4,在com.zhao.aspect包下创建MyAspect切面类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册成 Bean</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//定义为切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span></span>&#123;</span><br><span class="line">    <span class="comment">//对于add方法，我们使用注解直接对这个切点进行增强</span></span><br><span class="line">    <span class="meta">@Before(&quot;excution(* com.zhao.dao.UserDao.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinpoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置增强&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于delete方法，我们使用先定义切入点，在引用切入点的方式进行增强，这样的增强方式能更加灵活的设置要增强的       方法</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.zhao.dao.UserDao.delete(..)))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(MyAspect.pointCut1())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强……1&quot;</span>);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕增强……2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-5,在com.zhao包下，创建MainApp类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        UserDao userDao = context.getBean(<span class="string">&quot;userDao&quot;</span>, UserDao.class);</span><br><span class="line">        userDao.add();</span><br><span class="line">        userDao.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E-6,打印结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前置增强……execution(void com.zhao.dao.UserDao.add())</span><br><span class="line">正在执行 UserDao 的 add 方法</span><br><span class="line">环绕增强……1</span><br><span class="line">正在执行 UserDao 的 delete 方法</span><br><span class="line">环绕增强……2</span><br></pre></td></tr></table></figure>

<h1 id="七，Spring集成JDBC"><a href="#七，Spring集成JDBC" class="headerlink" title="七，Spring集成JDBC"></a>七，Spring集成JDBC</h1><h2 id="1，Spring配置使用JdbcTemplate"><a href="#1，Spring配置使用JdbcTemplate" class="headerlink" title="1，Spring配置使用JdbcTemplate"></a>1，Spring配置使用JdbcTemplate</h2><h3 id="（1）引入"><a href="#（1）引入" class="headerlink" title="（1）引入"></a>（1）引入</h3><p>Spring 提供了一个 Spring JDBC 模块，它对 JDBC API 进行了封装，其的主要目的降低 JDBC API 的使用难度，以一种更直接、更简洁的方式使用 JDBC API。</p>
<p>使用 Spring JDBC，开发人员只需要定义必要的参数、指定需要执行的 SQL 语句，即可轻松的进行 JDBC 编程，对数据库进行访问。Spring JDBC 提供了多个实用的数据库访问工具，以简化 JDBC 的开发，其中使用最多就是 JdbcTemplate。</p>
<h3 id="（2）JdbcTemplate中的方法介绍"><a href="#（2）JdbcTemplate中的方法介绍" class="headerlink" title="（2）JdbcTemplate中的方法介绍"></a>（2）JdbcTemplate中的方法介绍</h3><p>JdbcTemplate 的全限定命名为 org.springframework.jdbc.core.JdbcTemplate，配置必要的参数后，便可以使用它来实现和数据库的交互。它提供了大量的查询和更新数据库的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String sql)</td>
<td>（1）用于执行新增、更新、删除等语句；sql：需要执行的 SQL 语句；args 表示需要传入到 SQL 语句中的参数。</td>
</tr>
<tr>
<td>public int update(String sql,Object… args)</td>
<td>同（1）</td>
</tr>
<tr>
<td>public void execute(String sql)</td>
<td>（2）可以执行任意 SQL，一般用于执行 DDL 语句； sql：需要执行的 SQL 语句；action 表示执行完 SQL 语句后，要调用的函数。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>同（2）</td>
</tr>
<tr>
<td>public <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</td>
<td>（3）用于执行查询语句；  sql：需要执行的 SQL 语句； rowMapper：用于确定返回的集合（List）的类型； args：表示需要传入到 SQL 语句的参数。</td>
</tr>
<tr>
<td>public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object… args)</td>
<td>同（3）</td>
</tr>
<tr>
<td>public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)</td>
<td>用于批量执行新增、更新、删除等语句； sql：需要执行的 SQL 语句；argTypes：需要注入的 SQL 参数的 JDBC 类型；batchArgs：表示需要传入到 SQL 语句的参数。</td>
</tr>
</tbody></table>
<p><strong>补充</strong>：</p>
<p>DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段，数据库，表，列，索引等数据库对象。常用的语句关键字主要包括create,drop,alter等。<br>        DML（Data Manipulation Language）语句：数据操纵语句，用于添加，删除，更新和查询数据库记录，并检查数据完整性。常用的语句关键字主要包括insert，delete,update,select等。<br>        DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库，表，字段，用户的访问权限和安全级别。主要的语句关键字包括grant,revoke等。</p>
<h3 id="（3）使用示例"><a href="#（3）使用示例" class="headerlink" title="（3）使用示例"></a>（3）使用示例</h3><p>步骤：1）创建数据库表；2）引入包；3）创建jdbc.properties；4）创建Beans.xml，开启组件扫描，进行数据库配置，以及配置JdbcTemplate Bean；5）新建bean，数据访问Dao接口，Dao接口实现类，以及servcie，然后主程序中使用。</p>
<p><u>A，创建数据库表</u></p>
<p>在Mysql语句中执行以下语句创建User表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `user_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;用户 ID&#x27;,</span><br><span class="line">  `user_name` varchar(255) DEFAULT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `status` varchar(255) DEFAULT NULL COMMENT &#x27;用户状态&#x27;,</span><br><span class="line">  PRIMARY KEY (`user_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><u>B，创建my-spring-jdbc-demo，导入以下包</u></p>
<p><img src="C:\Users\zhao\Desktop\js-1-24.png" alt="js-1-24"></p>
<p><u>C，在项目src目录下创建 jdbc.properties，对数据库链接进行配置</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_jdbc_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

<p><u>D，在src目录下创建配置文件 Beans.xml（注意2~8行命名空间增加的内容）</u></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入 jdbc.properties 中的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据源 Bean，&gt;</span></span><br><span class="line"><span class="comment">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;!--下面四个参数根据实际情况调整--&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--数据库连接地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义JdbcTemplate Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将数据源的 Bean 注入到 JdbcTemplate 中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在以上配置中，我们共定义了两个 Bean，</p>
<ul>
<li>dataSource 为数据库连接池对象的 Bean。</li>
<li>jdbcTemplate 则为 JdbcTemplate 的 Bean，它由一个名为 datasSource 的属性。</li>
</ul>
<p>Spring 默认使用 DriverManagerDataSource 对数据库连接池进行管理，我们可以在 Spring 的 XML 配置文件中定义 DriverManagerDataSource 的 Bean，并注入到 JdbcTempate 的 Bean 中。</p>
<p>  <u>E，在com.zhao.entity包下，创建User.java</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">//下面省略了对应的get/set,toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>F，在com.zhao.dao下，创建UserDao接口</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;<span class="comment">//add,delete和update用的方法一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(User user)</span></span>;<span class="comment">//getUser和count用的方法一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getList</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>G，在com.zhao.dao.impl包下，创建 UserDao 的实现类 UserDaoImpl</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE `user` SET status=? WHERE user_name=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, user.getStatus(), user.getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT COUNT(*) FROM `user` where `status`=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class, user.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getList</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM `user` where `status`=?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User.class), user.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT into `user` (`user`.user_name,`user`.`status`) VALUES(?,?);&quot;</span>;</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>H，在 com.zhao.service 包下，创建一个名为 UserService 的 Service 接口</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>I,在 com.zhao.service.impl 包下，创建 UserService 的实现类 UserServiceImpl</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.update(user);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.count(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getList(user);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAddUser</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> </span>&#123;</span><br><span class="line">        userDao.batchAddUser(batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><u>J,在 com.zhao 包下，创建一个名为 MainApp 的类</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        UserService userService = context2.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">      </span><br><span class="line">       </span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setUserName(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        user1.setStatus(<span class="string">&quot;在线&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> u = userService.updateUser(user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户成功&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Object[] o1 = &#123;<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        Object[] o2 = &#123;<span class="string">&quot;小龙&quot;</span>, <span class="string">&quot;离线&quot;</span>&#125;;</span><br><span class="line">        Object[] o3 = &#123;<span class="string">&quot;小林&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        Object[] o4 = &#123;<span class="string">&quot;小李&quot;</span>, <span class="string">&quot;在线&quot;</span>&#125;;</span><br><span class="line">        batchArgs.add(o1);</span><br><span class="line">        batchArgs.add(o2);</span><br><span class="line">        batchArgs.add(o3);</span><br><span class="line">        batchArgs.add(o4);</span><br><span class="line">        userService.batchAddUser(batchArgs);</span><br><span class="line">        System.out.println(<span class="string">&quot;批量增加完毕&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        User user2 = <span class="keyword">new</span> User();</span><br><span class="line">        user2.setStatus(<span class="string">&quot;在线&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i1 = userService.countUser(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;在线用户的个数为：&quot;</span> + i1);</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList = userService.getUserList(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;在线用户列表查询成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user4 : userList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户 ID:&quot;</span> + user4.getUserId() + <span class="string">&quot;，用户名：&quot;</span> + user4.getUserName() + <span class="string">&quot;，状态：&quot;</span> + user4.getStatus());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2，Spring事务管理"><a href="#2，Spring事务管理" class="headerlink" title="2，Spring事务管理"></a>2，Spring事务管理</h2><h3 id="（1）事务的特性"><a href="#（1）事务的特性" class="headerlink" title="（1）事务的特性"></a>（1）事务的特性</h3><p>事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。</p>
<ul>
<li>原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。</li>
<li>一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。</li>
<li>持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</li>
</ul>
<h3 id="（2）事务的隔离级别"><a href="#（2）事务的隔离级别" class="headerlink" title="（2）事务的隔离级别"></a>（2）事务的隔离级别</h3><p><a href="http://blog.itpub.net/26736162/viewspace-2638951/">点击这里</a> 可查看详细说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-25.png" alt="js-1-25"></p>
<p>在 SQL 标准中定义了 4 种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<p> SQL 标准定义的四个隔离级别为： Read Uncommitted （ 未提交读 ） 、 Read Committed （提交读）、 Repeatable Read （可重复读）、 Serializable （可串行化） ，隔离级别越高，并发性能越低。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-26.png" alt="js-1-26"></p>
<p><strong>Spring事务传播机制</strong></p>
<p>@Transactional(propagation&#x3D;Propagation.REQUIRED)<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br>        @Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务<br>        @Transactional(propagation&#x3D;Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br>        @Transactional(propagation&#x3D;Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常<br>        @Transactional(propagation&#x3D;Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br>        @Transactional(propagation&#x3D;Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</p>
<p><a href="https://blog.csdn.net/qq_26323323/article/details/81908955">参考示例</a></p>
<h3 id="（3）PlatformTransactionManager接口（事务管理器）"><a href="#（3）PlatformTransactionManager接口（事务管理器）" class="headerlink" title="（3）PlatformTransactionManager接口（事务管理器）"></a>（3）PlatformTransactionManager接口（事务管理器）</h3><p>Spring 并不会直接管理事务，而是通过事务管理器对事务进行管理的。</p>
<p>在 Spring 中提供了一个 org.springframework.transaction.PlatformTransactionManager 接口，这个接口被称为 Spring 的事务管理器，其源码和三个接口的功能如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//用于获取事务的状态信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//用于提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;<span class="comment">//	用于回滚事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该接口对于不同的持久化框架或平台有不同的实现，对于JDBC来说，实现类是org.springframework.jdbc.datasource.DataSourceTransactionManager</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）TransactionDefinition-接口"><a href="#（4）TransactionDefinition-接口" class="headerlink" title="（4）TransactionDefinition 接口"></a>（4）TransactionDefinition 接口</h3><p>Spring 将 XML 配置中的事务信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。</p>
<p>TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;<span class="comment">//获取事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;<span class="comment">//获取事务的隔离级别</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取事务的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;<span class="comment">//获取事务的超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;<span class="comment">//获取事务是否只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）TransactionStatus-接口"><a href="#（5）TransactionStatus-接口" class="headerlink" title="（5）TransactionStatus 接口"></a>（5）TransactionStatus 接口</h3><p>TransactionStatus 接口提供了一些简单的方法，来控制事务的执行、查询事务的状态，接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;<span class="comment">//获取是否是新事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;<span class="comment">//获取是否存在保存点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;<span class="comment">//设置事务回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;<span class="comment">//获取事务是否回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;<span class="comment">//获取事务是否完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3，Spring基于XML实现事务管理"><a href="#3，Spring基于XML实现事务管理" class="headerlink" title="3，Spring基于XML实现事务管理"></a>3，Spring基于XML实现事务管理</h2><p>XML似乎用的不多（因为注解式更加简洁），日后再补充</p>
<h2 id="4，Spring基于注解实现事务管理"><a href="#4，Spring基于注解实现事务管理" class="headerlink" title="4，Spring基于注解实现事务管理"></a>4，Spring基于注解实现事务管理</h2><h3 id="（1）引入tx命名空间"><a href="#（1）引入tx命名空间" class="headerlink" title="（1）引入tx命名空间"></a>（1）引入tx命名空间</h3><p>Spring 提供的声明式事务管理是依赖于 Spring AOP 实现的，因此我们在 XML 配置文件中还应该添加与 aop 命名空间相关的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）在bean的配置文件中开启注解事务"><a href="#（2）在bean的配置文件中开启注解事务" class="headerlink" title="（2）在bean的配置文件中开启注解事务"></a>（2）在bean的配置文件中开启注解事务</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;tx:annotation-driven&gt; 也需要通过 transaction-manager 属性来定义一个事务管理器，这个参数的取值默认为transactionManager。如果我们使用的事务管理器的 id 与默认值相同，则可以省略对该属性的配置，形式如下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-Transactional-注解"><a href="#3-使用-Transactional-注解" class="headerlink" title="(3)使用 @Transactional 注解"></a>(3)使用 @Transactional 注解</h3><p>@Transactional 注解是 Spring 声明式事务编程的核心注解，该注解既可以在类上使用，也可以在方法上使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若 @Transactional 注解在类上使用，则表示类中的所有方法都支持事务；若 @Transactional 注解在方法上使用，则表示当前方法支持事务。Spring 在容器中查找所有使用了 @Transactional 注解的 Bean，并自动为它们添加事务通知，通知的事务属性则是通过 @Transactional 注解的属性来定义的。</p>
<p>@Transactional 注解包含多个属性，其中常用属性如下表。</p>
<table>
<thead>
<tr>
<th>事务属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>propagation</td>
<td>指定事务的传播行为。</td>
</tr>
<tr>
<td>isolation</td>
<td>指定事务的隔离级别。</td>
</tr>
<tr>
<td>read-only</td>
<td>指定是否为只读事务。</td>
</tr>
<tr>
<td>timeout</td>
<td>表示超时时间，单位为“秒”；声明的事务在指定的超时时间后，自动回滚，避免事务长时间不提交会回滚导致的数据库资源的占用。</td>
</tr>
<tr>
<td>rollback-for</td>
<td>指定事务对于那些类型的异常应当回滚，而不提交。</td>
</tr>
<tr>
<td>no-rollback-for</td>
<td>指定事务对于那些异常应当继续运行，而不回滚。</td>
</tr>
</tbody></table>
<h3 id="4）示例"><a href="#4）示例" class="headerlink" title="(4）示例"></a>(4）示例</h3><p>A，新建数据库表</p>
<p>有三个表，简单说一下：1）<strong>account</strong> ：id, user_id, total, used, residue。2）<strong>order</strong> : id, order_id, user_id, product_id, count, money, status。3）<strong>storage</strong> : id, product_id, total, used, residue。</p>
<p>B，导入依赖</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/js-1-27.png" alt="js-1-27"></p>
<p>C，在com.zhao.entity包下，创建名为Order的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//订单 id</span></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="comment">//用户 id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">//商品 id</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">//订单商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer count;</span><br><span class="line">    <span class="comment">//订单金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">    <span class="comment">//订单状态</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，在com.zhao.entity包下，创建名为Account的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//用户 id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">//账户总金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line">    <span class="comment">//已用账户金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal used;</span><br><span class="line">    <span class="comment">//剩余账户金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal residue;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E,在com.zhao.entity下，创建名为Storage的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增 id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//商品 id</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">//商品库存总数</span></span><br><span class="line">    <span class="keyword">private</span> Integer total;</span><br><span class="line">    <span class="comment">//已用商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer used;</span><br><span class="line">    <span class="comment">//剩余商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer residue;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//get和set方法这里省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>F，在com.zhao.dao下，创建OrderDao，AccountDao和StorageDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">    <span class="comment">//修改订单状态,将订单状态从未完成（0）修改为已完成（1）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateOrderStatus</span><span class="params">(String orderId, Integer status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">//根据用户查询账户金额</span></span><br><span class="line">    <span class="function">Account <span class="title">selectByUserId</span><span class="params">(String userId)</span></span>;</span><br><span class="line">   <span class="comment">//扣减账户金额</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decrease</span><span class="params">(String userId, BigDecimal money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StorageDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询商品的库存</span></span><br><span class="line">    <span class="function">Storage <span class="title">selectByProductId</span><span class="params">(String productId)</span></span>;</span><br><span class="line">    <span class="comment">//扣减商品库存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decrease</span><span class="params">(Storage record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>G,进行数据库和Beans.xml的配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//在src目录下，创建jdbc.properties配置文件，内容如下</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/spring-tx-db</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在src下创建Beans.xml，其中按顺序进行操作：1）引入命名空间；2）开启组件扫描；3）引入jdbc的配置并定义数据源bean</p>
<p>4）定义jdbcTemplate Bean（注入数据源bean） 5）配置事务管理器并开启事务注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;net.biancheng.c&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--引入 jdbc.properties 中的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据源 Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义 JdbcTemplate Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将数据源的 Bean 注入到 JdbcTemplate 中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>H,在com.zhao.dao.impl包下，创建上面接口的三个实现类：OrderDaoImpl，AccountDaoImpl和StorageDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into `order` (order_id,user_id, product_id, `count`, money, status) values (?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, order.getOrderId(), order.getUserId(), order.getProductId(), order.getCount(), order.getMoney(), order.getStatus());</span><br><span class="line">        <span class="keyword">return</span> update;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrderStatus</span><span class="params">(String orderId, Integer status)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot; update `order`  set status = 1 where order_id = ? and status = ?;&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, orderId, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">selectByUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;  select * from account where user_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">(String userId, BigDecimal money)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;UPDATE account SET residue = residue - ?, used = used + ? WHERE user_id = ?;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, money, money, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageDaoImpl</span> <span class="keyword">implements</span> <span class="title">StorageDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Storage <span class="title">selectByProductId</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select *   from storage where product_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Storage&gt;(Storage.class), productId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decrease</span><span class="params">(Storage record)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot; update storage set  used =? ,residue=? where product_id=?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(sql, record.getUsed(), record.getResidue(), record.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I，在com.zhao.service和com.zhao.service.impl中分别实现OrderServcie接口和OrderServiceImpl实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建订单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;orderService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在方法上使用 @Transactional 注解，隔离级别设置为DEFAULT，传播机制设置为REQUIRED</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED, timeout = 10, readOnly = false)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动生成订单 id</span></span><br><span class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmssSSS&quot;</span>);</span><br><span class="line">        String format = df.format(<span class="keyword">new</span> Date());</span><br><span class="line">        String orderId = order.getUserId() + order.getProductId() + format;</span><br><span class="line">        System.out.println(<span class="string">&quot;自动生成的订单 id 为：&quot;</span> + orderId);</span><br><span class="line">        order.setOrderId(orderId);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始创建订单数据，订单号为：&quot;</span> + orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建订单数据</span></span><br><span class="line">        orderDao.createOrder(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;订单数据创建完成，订单号为：&quot;</span> + orderId);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查询商品库存，商品 id 为：&quot;</span> + order.getProductId());</span><br><span class="line">        Storage storage = storageDao.selectByProductId(order.getProductId());</span><br><span class="line">        <span class="keyword">if</span> (storage != <span class="keyword">null</span> &amp;&amp; storage.getResidue().intValue() &gt;= order.getCount().intValue()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;商品库存充足，正在扣减商品库存&quot;</span>);</span><br><span class="line">            storage.setUsed(storage.getUsed() + order.getCount());</span><br><span class="line">            storage.setResidue(storage.getTotal().intValue() - storage.getUsed());</span><br><span class="line">            <span class="keyword">int</span> decrease = storageDao.decrease(storage);</span><br><span class="line">            System.out.println(<span class="string">&quot;商品库存扣减完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;警告：商品库存不足，正在执行回滚操作！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;开始查询用户的账户金额&quot;</span>);</span><br><span class="line">        Account account = accountDao.selectByUserId(order.getUserId());</span><br><span class="line">        <span class="keyword">if</span> (account != <span class="keyword">null</span> &amp;&amp; account.getResidue().intValue() &gt;= order.getMoney().intValue()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;账户金额充足，正在扣减账户金额&quot;</span>);</span><br><span class="line">            accountDao.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">            System.out.println(<span class="string">&quot;账户金额扣减完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;警告：账户余额不足，正在执行回滚操作！&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;账户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始修改订单状态，未完成》》》》》已完成&quot;</span>);</span><br><span class="line">        orderDao.updateOrderStatus(order.getOrderId(), <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改订单状态完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>J，最后，创建一个MainApp类来执行整个操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context2 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        OrderService orderService = context2.getBean(<span class="string">&quot;orderService&quot;</span>, OrderService.class);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        <span class="comment">//设置商品 id</span></span><br><span class="line">        order.setProductId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//商品数量</span></span><br><span class="line">        order.setCount(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//商品金额</span></span><br><span class="line">        order.setMoney(<span class="keyword">new</span> BigDecimal(<span class="number">600</span>));</span><br><span class="line">        <span class="comment">//设置用户 id</span></span><br><span class="line">        order.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//订单状态为未完成</span></span><br><span class="line">        order.setStatus(<span class="number">0</span>);</span><br><span class="line">        orderService.createOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行后的输出应该是下面这样</span></span><br><span class="line">自动生成的订单 id 为：<span class="number">1120220111173635296</span></span><br><span class="line">开始创建订单数据，订单号为：<span class="number">1120220111173635296</span></span><br><span class="line">订单数据创建完成，订单号为：<span class="number">1120220111173635296</span></span><br><span class="line">开始查询商品库存，商品 id 为：<span class="number">1</span></span><br><span class="line">商品库存充足，正在扣减商品库存</span><br><span class="line">商品库存扣减完成</span><br><span class="line">开始查询用户的账户金额</span><br><span class="line">账户金额充足，正在扣减账户金额</span><br><span class="line">账户金额扣减完成</span><br><span class="line">开始修改订单状态，未完成》》》》》已完成</span><br><span class="line">修改订单状态完成！</span><br><span class="line"><span class="comment">//如果再次执行整个MainApp中的方法的话，是无法成功实现的，如下</span></span><br><span class="line">自动生成的订单 id 为：<span class="number">1120220111175556986</span></span><br><span class="line">开始创建订单数据，订单号为：<span class="number">1120220111175556986</span></span><br><span class="line">订单数据创建完成，订单号为：<span class="number">1120220111175556986</span></span><br><span class="line">开始查询商品库存，商品 id 为：<span class="number">1</span></span><br><span class="line">商品库存充足，正在扣减商品库存</span><br><span class="line">商品库存扣减完成</span><br><span class="line">开始查询用户的账户金额</span><br><span class="line">警告：账户余额不足，正在执行回滚操作！</span><br></pre></td></tr></table></figure>































<h1 id="八，Spring整合日志框架"><a href="#八，Spring整合日志框架" class="headerlink" title="八，Spring整合日志框架"></a>八，Spring整合日志框架</h1>]]></content>
  </entry>
  <entry>
    <title>xm-2-MyBatis-Plus</title>
    <url>/2022/02/06/%E4%B8%8D%E5%81%9A%E4%BA%86/xm-2-MyBatis-Plus/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，基础知识之字词积累"><a href="#一，基础知识之字词积累" class="headerlink" title="一，基础知识之字词积累"></a>一，基础知识之字词积累</h1><h2 id="1，《斑比出生了》"><a href="#1，《斑比出生了》" class="headerlink" title="1，《斑比出生了》"></a>1，《斑比出生了》</h2><h3 id="（1），几种类型的词语"><a href="#（1），几种类型的词语" class="headerlink" title="（1），几种类型的词语"></a>（1），几种类型的词语</h3><h2 id="2，这是二级标题"><a href="#2，这是二级标题" class="headerlink" title="2，这是二级标题"></a>2，这是二级标题</h2><h3 id="（1），这是三级标题"><a href="#（1），这是三级标题" class="headerlink" title="（1），这是三级标题"></a>（1），这是三级标题</h3><p>内容</p>
<h2 id="3，一些快捷键"><a href="#3，一些快捷键" class="headerlink" title="3，一些快捷键"></a>3，一些快捷键</h2><p>1，<em>斜体是Ctrl+I</em></p>
<p>2，<strong>粗体是Ctr+B</strong></p>
<p>3，<u>下划线是Ctrl+U</u></p>
<p>4，<del>删除线是Alt+Shift+5</del></p>
<blockquote>
<p>5，文字引用是Ctrl+Shift+Q（主要功能是引用一些特定的内容）</p>
</blockquote>
<p>6，在某一行添加代码，使用<code>int a = 2;</code>，快捷键是Ctrl+Shift+&#96;</p>
<p>7,添加多行代码，比如下面，快捷键是Ctrl+Shift+K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>8，添加数学公式，快捷键是Ctrl+Shift+M，<br>$$<br>y &#x3D;x ^ 2<br>$$<br>9，添加超链接的快捷键是Ctrl+K，<a href="www.baidu.com">百度一下</a></p>
<p>10，图片的命名格式：文章标题缩写+数字（比如，单体模式，其中的第一张图为：dtms-1）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong算法秘籍阅读笔记</title>
    <url>/2022/02/07/sf-1-labuladong/</url>
    <content><![CDATA[<p><strong>简介：</strong>该博客为学习labuladong算法笔记过程中的记录和思考，并根据自己的特点（非科班，算法基础薄弱，准备时间短）来进行针对性学习，目标是能够总结出适合自己的一套思路和方法。</p>
<span id="more"></span>

<h1 id="一，刷题思维"><a href="#一，刷题思维" class="headerlink" title="一，刷题思维"></a>一，刷题思维</h1><h2 id="1，数据结构的存储方式"><a href="#1，数据结构的存储方式" class="headerlink" title="1，数据结构的存储方式"></a>1，数据结构的存储方式</h2><h3 id="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）"><a href="#（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储-）" class="headerlink" title="（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）"></a>（1），数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储  ）</h3><p>散列表、栈、队列、堆、树、图等等各种数据结构 ，都是基于数组和链表的</p>
<h3 id="（2）数组和链表的优缺点"><a href="#（2）数组和链表的优缺点" class="headerlink" title="（2）数组和链表的优缺点"></a>（2）数组和链表的优缺点</h3><p><strong>数组</strong>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。<u>但正因为连</u><br><u>续存储，内存空间必须⼀次性分配够，所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全</u><br><u>部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以</u><br><u>保持连续，时间复杂度 O(N)。</u>  </p>
<p><strong>链表</strong>因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素<br>的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。<u>但是正因为存储空间不连续，<br>你⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位<br>置的指针，会消耗相对更多的储存空间</u></p>
<h2 id="2，数据结构的基本操作"><a href="#2，数据结构的基本操作" class="headerlink" title="2，数据结构的基本操作"></a>2，数据结构的基本操作</h2><h3 id="（1）数据结构的终极目的"><a href="#（1）数据结构的终极目的" class="headerlink" title="（1）数据结构的终极目的"></a>（1）数据结构的终极目的</h3><p>在不同的应⽤场景，尽可能⾼效地增删查改。  </p>
<h3 id="（2）操作的类型"><a href="#（2）操作的类型" class="headerlink" title="（2）操作的类型"></a>（2）操作的类型</h3><p>如何遍历 + 访问？我们仍然从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。<br>线性就是 for&#x2F;while 迭代为代表，⾮线性就是递归为代表。再具体⼀步，⽆⾮以下⼏种框架  ：</p>
<p>A，数组遍历框架（典型的线性迭代结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.lenght; i++)&#123;</span><br><span class="line">        <span class="comment">//访问并操作arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，链表遍历框架，兼具迭代和递归结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != <span class="keyword">null</span>;p = p.next)&#123;</span><br><span class="line">        <span class="comment">//访问并操作p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，二叉树遍历框架，典型的非线性递归遍历结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D,二叉树框架扩展为N叉树遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问并操作root.val</span></span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>E，N叉树遍历扩展为图的遍历</p>
<p>与N叉树类似，但是要避免出现环型的遍历，所以要添加一个布尔类型的Visited来标记是否遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArcNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Boolean visited;<span class="comment">//这里图中的每个节点的visited初始值为false</span></span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历有好几种，深度优先，广度优先，以及非递归，这里类似于N叉树，写深度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ArcNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.visited == <span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//访问并操作root.val</span></span><br><span class="line">     	root.visited = <span class="keyword">true</span>;</span><br><span class="line">   	 	<span class="keyword">for</span>(TreeNode child : root.children)&#123;</span><br><span class="line">        	traverse(child);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-算法刷题指南"><a href="#3-算法刷题指南" class="headerlink" title="3,算法刷题指南"></a>3,算法刷题指南</h2><p>首先，<strong>数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法</strong>  ，所以在刷算法之前，应该了解常用的数据结构以及它们的基本操作和优缺点（散列表、栈、队列、堆、树、图等等）</p>
<p>然后，<strong>先刷⼆叉树，</strong>因为二叉树是最容易帮助人建立起框架思维的，对于一道二叉树相关的题，可以分为几个阶段：1，认识出这是一个能通过二叉树解决的问题；2，能写出答题的总体步骤（前序，中序，还是后序？），之中的一些细节就算写错，也不会错到哪儿去；3，扩展到解决其他问题（动态规划，回溯算法等等）</p>
<p><strong>注：</strong>这里我的理解是，二叉树作为一个在整个算法系统中的中间位置，能够很高的起到锻炼的作用，熟悉了二叉树后，简单的题目中的思路可以从二叉树中提取，复杂的题目可以从二叉树中扩展。</p>
<h1 id="二，计算机算法的本质"><a href="#二，计算机算法的本质" class="headerlink" title="二，计算机算法的本质"></a>二，计算机算法的本质</h1><h2 id="1，核心"><a href="#1，核心" class="headerlink" title="1，核心"></a>1，核心</h2><p>算法的本质就是穷举。(当然，某些问题可以通过总结规律解决，某些问题可以通过数学算法解决，但是绝大多数问题都是穷举)</p>
<p>但是此处的穷举并不是指暴力破解那样的寻找，因为一个问题的答案往往有很多条路，所以“穷举”思维，是包含两个层次的含义，如何穷举<strong>和</strong>如何聪明的穷举**，每道题的难点是不一样的</p>
<h3 id="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"><a href="#（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。" class="headerlink" title="（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。"></a>（1）什么算法的难点在「如何穷举」呢？⼀般是递归类问题，最典型的就是动态规划系列问题。</h3><blockquote>
<p>（P19）前⽂ 动态规划核⼼套路 阐述了动态规划系列问题的核⼼原理，⽆⾮就是先写出暴⼒穷举解法（状态转移⽅程），加个备忘录就成⾃顶向下的动态规划解法了，再改⼀改就成⾃底向上的迭代解法了，动态规划的降维打击 ⾥也讲过如何分析优化动态规划算法的空间复杂度  </p>
<p>上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧⼀听就会<br>了。但很多读者留⾔说明⽩了这些原理，遇到动态规划题⽬还是不会做，因为第⼀步的暴⼒解法都写不出<br>来。</p>
<p>这很正常，因为动态规划类型的题⽬可以千奇百怪，找状态转移⽅程才是难点，所以才有了 动态规划设计⽅<br>法：最⻓递增⼦序列 这篇⽂章，告诉你递归穷举的核⼼是数学归纳法，明确函数的定义，然后利⽤这个定义<br>写递归函数，就可以穷举出所有可⾏解。  </p>
</blockquote>
<h3 id="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"><a href="#（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。" class="headerlink" title="（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。"></a>（2）什么算法的难点在「如何聪明地穷举」呢？⼀些⽿熟能详的⾮递归算法技巧，都可以归在这⼀类。</h3><blockquote>
<p>（p19）⽐如前⽂ Union Find 并查集算法详解 告诉你⼀种⾼效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我⽤ DFS&#x2F;BFS 暴⼒搜索（穷举）肯定可以做到，但⼈家 Union Find 算法硬是⽤数组模拟树结构，给你把连通性相关的操作复杂度给⼲到 O(1) 了。这就属于聪明地穷举，你学过就会⽤，没学过恐怕很难想出这种思路。</p>
<p>再⽐如贪⼼算法技巧，前⽂ 当⽼司机学会贪⼼算法 就告诉你，所谓贪⼼算法就是在题⽬中发现⼀些规律（专业点叫贪⼼选择性质），使得你不⽤完整穷举所有解就可以得出答案。</p>
<p>⼈家动态规划好⽍是⽆冗余地穷举所有解，然后找⼀个最值，你贪⼼算法可好，都不⽤穷举所有解就可以找<br>到答案，所以前⽂ 贪⼼算法解决跳跃游戏 中贪⼼算法的效率⽐动态规划还⾼。</p>
<p>再⽐如⼤名鼎鼎的 KMP 算法，你写个字符串暴⼒匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复⽤⼀些信息，减少了冗余计算，前⽂ KMP 字符匹配算法 就是使⽤状态机的思路实现<br>的 KMP 算法。  </p>
</blockquote>
<h1 id="三，基础数据结构"><a href="#三，基础数据结构" class="headerlink" title="三，基础数据结构"></a>三，基础数据结构</h1><h2 id="1，数组-x2F-链表"><a href="#1，数组-x2F-链表" class="headerlink" title="1，数组&#x2F;链表"></a>1，数组&#x2F;链表</h2><h3 id="（1）前缀和数组"><a href="#（1）前缀和数组" class="headerlink" title="（1）前缀和数组"></a>（1）前缀和数组</h3><p>前缀和，指的是在在计算中，如果要频繁的读取一段区间内的值，那么设定一个基准点，将该基准点以及到各个索引之间的值先计算出来并记录，这样再进行新区间值的计算的时候，能够避免重复计算。</p>
<p><u><strong>力扣303题——区域和检索-数组不可变</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-1.png" alt="sf-1-1"></p>
<p>如果是不考虑时间复杂度，那么每次计算两个索引范围之间的和，都会进行一次数组的遍历，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.nums = nums;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		res += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目要求降低时间复杂度，那么我们要尽量避免同样的操作，前缀和数组就能帮助我们解决这样的问题，主要思路是，建立一个新的数组preSum，然后对于原来的数组nums，以0位基准，将不同范围的nums数组和存储在preSum中，也就是preSum[1]-&gt;sum[0]，preSum[4]-&gt;sum[0] + sum[1]+sum[2] + preSum[3]，那么求索引1~3之间的和，即可用preSum[3+1] - preSum[1]即可。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前缀和数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] preSum;</span><br><span class="line">	<span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">			preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣304题——二维区域和检索-矩阵不可变</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-2.png" alt="sf-1-2"></p>
<p>此题和上一题类似，还是需要先计算矩阵的前缀和，只是此处的前缀和和上题不同，那么在这里我们需要什么样的前缀和呢？基准点是哪个呢?我们先看一下下面的计算过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-3.png" alt="sf-1-3"></p>
<p>​    要计算红框里的数组和（坐标：2,1,4,3），它的值就等于黄框（0,0,4,3）减去粉框（0,0,1,3）减去绿框（0,0,4,0）最后加上紫框（0,0,1,0），这样我们就将基准点设置好了，同时我们也知道，需要计算的前缀和为坐标为（0,0,x,y）的框的和（x，y为不同的坐标点），利用这些坐标和，就可以算出所有的小框里的数字和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">	<span class="comment">// preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] preSum;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 构造前缀和矩阵</span></span><br><span class="line">		preSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="comment">// 计算每个矩阵 [0, 0, i, j] 的元素和</span></span><br><span class="line">			preSum[i][j] = preSum[i-<span class="number">1</span>][j] + preSum[i][j-<span class="number">1</span>] + matrix[i- <span class="number">1</span>][j - <span class="number">1</span>] - preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算⼦矩阵 [x1, y1, x2, y2] 的元素和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ⽬标矩阵之和由四个相邻矩阵运算获得</span></span><br><span class="line">		<span class="keyword">return</span> preSum[x2+<span class="number">1</span>][y2+<span class="number">1</span>] - preSum[x1][y2+<span class="number">1</span>] - preSum[x2+<span class="number">1</span>][y1] +preSum[x1][y1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><u>力扣560——和为k的子数组</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-4.png" alt="sf-1-4"></p>
<p>这道题基础的做法是采用穷举所有子数组的做法，并检查他们是否和为K。但是这种做法太简单了，我们可以尝试用前缀和，有了前缀和在穷举子数组，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// 构造前缀和</span></span><br><span class="line">	<span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">	preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 穷举所有⼦数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)	</span><br><span class="line">			<span class="comment">// ⼦数组 nums[j..i-1] 的元素和</span></span><br><span class="line">			<span class="keyword">if</span> (preSum[i] - preSum[j] == k)</span><br><span class="line">				res++;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这里的时间复杂度还是o(N^2)，空间复杂度是o(N)（空间复杂度都挺高了时间复杂度没降下来说不过去），那么我们需要进行进一步的改良，一个思路是，我们能不能在计算前缀和的同时，判断该前缀和是否存在一个对应的相差为K的前缀和，如果有则统计次数加1，如果没有则跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.length;</span><br><span class="line">	<span class="comment">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class="line">	HashMap&lt;Integer, Integer&gt;</span><br><span class="line">		preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// base case	</span></span><br><span class="line">    preSum.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		sum0_i += nums[i];</span><br><span class="line">		<span class="comment">// 这是我们想找的前缀和 nums[0..j]</span></span><br><span class="line">		<span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">		<span class="comment">// 如果前⾯有这个前缀和，则直接更新答案</span></span><br><span class="line">		<span class="keyword">if</span> (preSum.containsKey(sum0_j))</span><br><span class="line">			res += preSum.get(sum0_j);</span><br><span class="line">		<span class="comment">// 把前缀和 nums[0..i] 加⼊并记录出现次数</span></span><br><span class="line">		preSum.put(sum0_i,</span><br><span class="line">			preSum.getOrDefault(sum0_i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）差分数组"><a href="#（2）差分数组" class="headerlink" title="（2）差分数组"></a>（2）差分数组</h3><p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和 。本节与前缀和数组类似，讲的是差分数组，指的是频繁对原始数组的某个区间的元素进⾏增减，最后的数组内容发生了改变。</p>
<p>**<u>引例</u>**：⼀个数组 nums，然后⼜要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减3，再给 nums[0..4] 全部加 2，再给…  最后的数组是什么样的呢？一般情况下，我们不断的循环遍历修改数组就行，但这样每次的时间复杂度都是O(n)，效率不高</p>
<p>所以我们需要使用<strong>差分数组</strong>，差分数组指的是构造一个新的数组diff[]，diff[i] &#x3D; nums[i] - nums[i - 1]（如图）,并且根据差分数组可以反推出原数组（设一个数组res[]，res[0] &#x3D; diff[0]，这样的话原数组res[i] &#x3D; res[i - 1] + diff[i]，其中i &gt;&#x3D; 1），</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-5.png" alt="sf-1-5"></p>
<p>差分数组在频繁的修改某个区间的值中能够降低复杂度，比如要将区间 i ~ j 中的所有数都加3，那么可以将差分数组diff[i] +&#x3D; 3，diff[j] -&#x3D; 3，这样恢复为原数组的时候就可以实现这样的效果。原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] +&#x3D; 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -&#x3D; 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，就是对nums[i..j] 中的所有元素都加 3 。</p>
<p>差分数组的这些初始化操作，变化操作，以及恢复操作可以抽象为一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] diff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Difference</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;<span class="comment">//assert对一个boolean表达式进行检查，一个正确运行的程序保证boolean值为true，若为false，则说明程序不正确，系统需要提供警告信息并且退出程序。</span></span><br><span class="line">        diff = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            diff[i] = nums[i] -nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处val可以是负数，另外如果j大于diff.length的话，就表明i之后的数组都要增加val</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    	diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.length)&#123;</span><br><span class="line">        	diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result()&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣370——区间加法</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-6.png" alt="sf-1-6"></p>
<p>这道题使用引例中实现的类即可。代码如下（省略了类的定义）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length,<span class="keyword">int</span>[][] updates)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    Difference difference = <span class="keyword">new</span> Difference(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] update : updates)&#123;</span><br><span class="line">        difference.increment(update[<span class="number">0</span>], update[<span class="number">1</span>], update[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1109——航班预订统计</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-7.png" alt="sf-1-7"></p>
<p>本体也就是差分数组的变体，写法与上题大致相同，但是这里注意，航班的编号是1 ~ n！，对应数组中的0 ~ n-1!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(<span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Different different = <span class="keyword">new</span> Different(res);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] booking : bookings)&#123;</span><br><span class="line">        different.increment(booking[<span class="number">0</span>] - <span class="number">1</span>,booking[<span class="number">1</span>] - <span class="number">1</span>,booking[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> different.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1094——拼车</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-8.png" alt="sf-1-8"></p>
<p>本题同样是差分数组的扩展，对于这种明显的问题，我们需要明确的是我们在模板中的nums[]，[i，j，val]数组，以及res[]数组的含义。在本题中，明显能发现trip[a,b,c]这个三维数组对应的是变化的标记，那么nums[]数组就是每站车上的人数（初始为0），最后的res[]就是车开了一遍后每站都有多少人。<u>我们判断能否一次性把顾客运送完，就先假设容量无限大，计算出res[],最后遍历res[]看途中是否有不符合条件的情况即可。</u>本题中没有直接说有多少车站，但是说明了车站的范围在0~1000之间，那么可设nums[1001]（初试值为0），代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(<span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1001</span>];</span><br><span class="line">    Difference df = <span class="keyword">new</span> Difference(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] trip : trips)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = trip[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里注意，j站的时候已经下车啦</span></span><br><span class="line">        <span class="keyword">int</span> j = trip[<span class="number">2</span>] - <span class="number">1</span>;</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = df.result();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity &lt; res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）滑动窗口"><a href="#（3）滑动窗口" class="headerlink" title="（3）滑动窗口"></a>（3）滑动窗口</h3><p><strong>引入：</strong>指的是一类问题，通过维护⼀个窗⼝，不断滑动，然后更新答案  。该算法时间复杂度为O（N），比字符串暴利算法高效很多。但是该思路存在很多细节问题：⽐如说如何向窗⼝中添加新元素，如何缩⼩窗⼝，在窗⼝滑动的哪个阶段更新结果 …除此之外，出现了Bug调试也很困难。</p>
<p>所以根据labuladong笔记，其中总结了一个框架（包含了debug的输出提示），遇到相关类型，默写该框架，修改三个地方即可解决大部分滑动窗口题。(后面会有几道力扣的题进行使用展示)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need ,window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">//右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">        <span class="comment">//下面更新窗口数据</span></span><br><span class="line">        ...update...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面是debug输出的位置    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>,left,right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">           <span class="comment">//d 是将移出窗口的字符</span></span><br><span class="line">           <span class="keyword">char</span> d = s[left];</span><br><span class="line">           <span class="comment">//左移窗口</span></span><br><span class="line">           left++;</span><br><span class="line">           <span class="comment">//进行窗口内数据的一系列更新</span></span><br><span class="line">           ...update...</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>滑动窗⼝很多时候都是在处理字符串相关的问题，Java 处理字符串不⽅便，所以本⽂代码为 C++ 实<br>现。不会⽤到什么编程⽅⾯的奇技淫巧，但是还是简单介绍⼀下⼀些⽤到的数据结构，以免有的读者因为语<br>⾔的细节问题阻碍对算法思想的理解：  </p>
<p>unordered_map 就是哈希表（字典），它的⼀个⽅法 count(key) 相当于 Java 的 containsKey(key)<br>可以判断键 key 是否存在。<br>        可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个<br>key，并把 map[key] 赋值为 0。<br>        所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) +1)。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingWindow</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组/字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量统计 子数组/子区间 是否有效</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义变量保存结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右指针遍历到数组尾</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">//增加当前右指针对应的数值</span></span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="comment">//当在该区间内 sum 超出定义范围</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                <span class="comment">//移动左指针并调整值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//到 while 结束时，我们找到了一个符合题意要求的 子数组/子串，更新结果</span></span><br><span class="line">            res = </span><br><span class="line">            <span class="comment">//移动右指针，去探索下一个区间</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：ren-feiye</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/subarray-product-less-than-k/solution/jian-dan-yi-dong-xiang-xi-zhu-jie-shuang-jvy3/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣76——最小覆盖子串</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-9.png" alt="sf-1-9"></p>
<p>这道题我们将代码先贴在下面，然后结合图片观察滑动窗口实现的原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,先更新start和len的值，然后左移窗口，取left处的字符d，然后自增1。更新操作：判断need中是否有字符d，存在的话（如果window中的d的次数和need中的一样，则valid自减1，）则window中的d的出现次数自减1。若字符d导致了valid自减1，start记录的位置是将其包含在内的。</span></span><br><span class="line">        <span class="keyword">while</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若跳出了上面的循环，则取s的子串</span></span><br><span class="line">    <span class="keyword">return</span> len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，本题中的代码的运行流程应该是下面这样，读者可以自己手动过一遍，加强印象</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-10.png" alt="sf-1-10"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-11.png" alt="sf-1-11"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-12.png" alt="sf-1-12"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-13.png" alt="sf-1-13"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-14.png" alt="sf-1-14"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-15.png" alt="sf-1-15"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-16.png" alt="sf-1-16"></p>
<blockquote>
<p>使⽤ Java 的读者要尤其警惕语⾔特性的陷阱。Java 的 Integer，String 等类型判定相等应该⽤<br>equals ⽅法⽽不能直接⽤等号 &#x3D;&#x3D;，这是 Java包装类的⼀个隐晦细节。所以在左移窗⼝更新数据的时<br>候，不能直接改写为 window.get(d) &#x3D;&#x3D; need.get(d)，⽽要⽤window.get(d).equals(need.get(d))，之后的题⽬代码同理。  </p>
</blockquote>
<p><strong><u>力扣567——字符串排列</u></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-17.png" alt="sf-1-17" style="zoom:67%;" />

<p>说明：本题第目的就是给你⼀个 s1 和⼀个 s2，请问你 s2中是否存在⼀个⼦串，包含 s1 中所有字符且不包含其他字符？  这里注意，s1中可以包含相同的字符串。</p>
<p>这道题应用在框架中要注意几点：1）窗口在往右扩大时，是一样的，将对应的字母都要包含的窗口中。2）收缩窗口时便有所不同，首先窗口的关闭条件应该是，while（right - left &gt;&#x3D; t.size()），这样才能保证及时缩小窗口。3）在缩小的过程中，一旦valid &#x3D;&#x3D; need.size()  ，便表明找到了最后的答案。    具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1，初试化名为window的map，初始化名为need的map并将T存进去，然后left，right，valid分别代表左指针，右指针（左闭右开），以及window中存在的T的字符的个数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，start用来记录找到的子串的起始位置，len初始化为一个极大的值（比如将INT_MAX设置为1000）</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; len = INT_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3,right值小于字符串S的长度时进行循环</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4，右移窗口，先取right处的字符c，并自增1（这便保证了指针区间的左闭右开）。更新操作：判断字符c是否存在于need中，存在则存于window中并计数（若次数和need中的一致，则valid自增1，表明某个特定的字符已经完全存在于window中）</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5,这里窗口收缩的条件不同，right和left限制了一个与目标字符串相同大小的窗口，并且本题不需要记录该字符串的位置，所以也不需要start和len</span></span><br><span class="line">        <span class="comment">// while(valid == need.size())</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">		   <span class="comment">//这里注意，valid值如果与need的值相同，则表明当前窗口下的size个字符都是我们需要的字符</span></span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面的循环没有返回true，那就一定是false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣438——找到字符串中所有字母异位词</strong></u></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-18.png" alt="sf-1-18" style="zoom:67%;" />

<p>说明：本题扩大窗口没有特殊的地方，收缩窗口时注意记录子串的起始索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.<span class="built_in">add</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>力扣3——最长不重复子串</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-19.png" alt="sf-1-19"></p>
<p>说明：本题没有固定的字符串对应，所以不需要need数组，也不需要valid来记录情况，但是需要window数组来记录窗口中字符的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minWindow</span><span class="params">(string s, string t)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">char</span> d = s[left];</span><br><span class="line">             left++;</span><br><span class="line">			window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）二分搜索框架"><a href="#（4）二分搜索框架" class="headerlink" title="（4）二分搜索框架"></a>（4）二分搜索框架</h3><p><strong>引入</strong>：⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。⽽且，我们就是要深⼊细节，⽐如不等号是否应该带等号，mid 是否应该加⼀等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的⼆分查找算法  。下面是二分查找的框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">     	<span class="keyword">int</span> mid = left + (right - left)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。本⽂都会使⽤ else if，旨在讲清楚，读者理解后可⾃⾏简化。<br>    其中 … 标记的部分，就是可能出现细节问题的地⽅，当你⻅到⼀个⼆分查找的代码时，⾸先注意这⼏个地⽅。后⽂⽤实例分析这些地⽅能有什么样的变化。<br>    另外声明⼀下，计算 mid 时需要防⽌溢出，代码中 left + (right - left) &#x2F; 2 就和 (left +right) &#x2F; 2 的结果相同，但是有效防⽌了 left 和 right 太⼤直接相加导致溢出。  </p>
<p>接下来说明几个二分搜索的应用场景：</p>
<p><strong><u>寻找一个数（基本的二分搜索）</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left =  mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该算法有几个注意的地方：    1）while判断条件是（left &lt;&#x3D; right），而不是（left &lt; right），我们使用的闭区间搜索（因为right赋值为nums.length - 1)，若此时left和right都是2的话，while(left &lt; right)这个判断语句就会错过2这个下标所代表的位置；      2）当判断过mid位置的数字后，left和right的更新就对应的+1和-1；      3）该算法无法处理有多个结果的情况，比如在数组nums &#x3D; [1,2,2,2,3]中搜索数字2，只能得到索引2，无法得到左侧的索引1和右侧的索引2.</p>
<p><strong><u>寻找左侧边界的二分搜索</u></strong></p>
<p>下面的算法是左右都是闭区间检查，那么rigth的初试值就是nums.length - 1，while的终止条件就是left &#x3D; right + 1。这里要注意，循环的退出条件既然变成了left &#x3D; right + 1，那么如果一个数组中的左右元素都比target小，left就会比right大，所以最后那里需要进行判读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_boud</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.lenght - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || nums[left] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>寻找右侧边界的二分查找</u></strong></p>
<p>下面是两边闭区间的形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; taeget)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            rigth = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是左侧还是右侧边界的搜索，其实可以抽象为一定范围内的找极值的行为，比如对于nums &#x3D; [1,2,3,3,3,5,7]，想搜索target &#x3D; 3，搜索左侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-20.png" alt="sf-1-20"></p>
<p>搜索右侧边界的二分搜索形式如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-21.png" alt="sf-1-21"></p>
<p>是不是有一种做函数题的感觉</p>
<h3 id="（5）二分搜索题型"><a href="#（5）二分搜索题型" class="headerlink" title="（5）二分搜索题型"></a>（5）二分搜索题型</h3><p>⽂总结的⼆分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够⽤到⼆分搜索 。所以接下来需要一套二分搜索算法应用的套路（思路）</p>
<p><strong>首先</strong>，什么样的题可以使用二分搜索的技巧呢？一般是符合以下条件的题：</p>
<p>可以从题目中抽象出一个自变量x，关于x的函数f(x)，以及一个目标值target，同时x，f(x)，target需要满足以下条件</p>
<p>1，f(x)必须是在x上的单调函数（单增单减都可以）</p>
<p>2，题目要求计算f(x) &#x3D;&#x3D; target时的x的值</p>
<p>对于上一节的例子（就是nums &#x3D; [1,2,3,3,3,5,7]，搜索左侧target &#x3D; 3），可以抽象为下面这样的形式（虽然没必要）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid, nums) == target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid, nums) &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.length || f(left, nums) != target)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，对于一个需要二分搜索解决的问题，我们的思考点应该是几个方面，具体见下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1,根据题意确定x的最小值是多少</span></span><br><span class="line">    <span class="keyword">int</span> left = ...;</span><br><span class="line">    <span class="comment">//2,根据题意确定x的最小值是多少（这个是闭区间写法）</span></span><br><span class="line">    <span class="keyword">int</span> right = ...;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= rigth)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid) &lt; target)&#123;</span><br><span class="line">            <span class="comment">//3,怎么让f(x)大一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) &gt; target)&#123;</span><br><span class="line">            <span class="comment">//4,怎么让f(x)小一点</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(mid) == target)&#123;</span><br><span class="line">            <span class="comment">//5,题目求的左边界还是右边界（注意是闭区间写法）</span></span><br><span class="line">            </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6,闭区间需要判断是都超出范围</span></span><br><span class="line">    <span class="keyword">if</span> ...;</span><br><span class="line">    <span class="keyword">return</span> ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，想用二分搜索来解决问题的话，主要有以下几步：</p>
<ul>
<li>确定 x, f(x), target 分别是什么，并写出函数 f 的代码  </li>
<li>找到 x 的取值范围作为⼆分搜索的搜索区间，初始化 left 和 right 变量。  </li>
<li>根据题⽬的要求，确定应该使⽤搜索左侧还是搜索右侧的⼆分搜索算法，写出解法代码</li>
</ul>
<p><strong>力扣875——爱吃香蕉的珂珂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</span><br><span class="line"></span><br><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 6</span><br><span class="line">输出: 23</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= piles.length &lt;= 10^4</span><br><span class="line">piles.length &lt;= H &lt;= 10^9</span><br><span class="line">1 &lt;= piles[i] &lt;= 10^9</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        Tool tool  = <span class="keyword">new</span> Tool();</span><br><span class="line">        <span class="keyword">int</span>[] res = tool.getMaxandMin(piles);</span><br><span class="line">        <span class="keyword">int</span> min = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = res[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = max;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getTime(piles,mid) &lt; h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) &gt; h)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getTime(piles,mid) == h)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] getMaxandMin(<span class="keyword">int</span>[] piles)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &gt; max)&#123;</span><br><span class="line">                max = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(piles[i] &lt; min)&#123;</span><br><span class="line">                min = piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = min;</span><br><span class="line">        res[<span class="number">1</span>] = max;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> speed)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            res += (pile % speed == <span class="number">0</span>) ? (pile / speed) : (pile / speed + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣1011——在D天内送达包裹的能力</u></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line">返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= days &lt;= weights.length &lt;= 5 * 104</span><br><span class="line">1 &lt;= weights[i] &lt;= 500</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">5000000</span>;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights,mid) == -<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tool.getDay(weights, mid) &lt; days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights, mid) &gt; days)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tool.getDay(weights,mid) == days)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">5000000</span>) <span class="keyword">return</span> <span class="number">5000000</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDay</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weights[i] &gt; capacity)&#123;</span><br><span class="line">                loc = -<span class="number">1</span>;</span><br><span class="line">                day = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp + weights[i] &gt; capacity)&#123;</span><br><span class="line">                day++;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                loc = i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += weights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt; weights.length &amp;&amp; loc != -<span class="number">1</span>)&#123;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）优势洗牌"><a href="#（6）优势洗牌" class="headerlink" title="（6）优势洗牌"></a>（6）优势洗牌</h3><p>该点与双指针关联，这里暂时不添加</p>
<h3 id="（7）原地修改数组"><a href="#（7）原地修改数组" class="headerlink" title="（7）原地修改数组"></a>（7）原地修改数组</h3><p><u><strong>力扣26——删除排序数组中的重复项</strong></u></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-22.png" alt="sf-1-22"></p>
<p><strong>说明</strong>：由于不能新建数组，所以只能通过指针去探测并记录，在此基础上更新。一个指针无法确定新的元素和应该插入的位置，所以这里需要使用双指针，一个记录插入的位置，一个进行探测，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">           slow ++;</span><br><span class="line">           nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>力扣83——删除排序链表中的重复元素</u></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-23.png" alt="sf-1-23"></p>
<p><strong>说明</strong>：本题和上一题（力扣26）其实是一样的，只是把数据结构换成了链表，并且多了删除链表的操作，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.val != slow.val)&#123;</span><br><span class="line">            slow.next = fast;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣27——移除元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-24.png" alt="sf-1-24"></p>
<p>说明：此题和前面是类似的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣283——移动零)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-25.png" alt="sf-1-25"></p>
<p><strong>说明</strong>：同样用快慢指针就可以了，两种方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,可以使用快慢指针，首先将low指针定位打0的位置出，然后移动fast指针寻找非0的元素进行调换即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] != <span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; nums.length &amp;&amp; nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[low] = nums[fast];</span><br><span class="line">                nums[fast] = <span class="number">0</span>;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2, 将问题转化，将所有非零元素往前移，然后再将后面多出的元素设为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = removeElement(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(; p &lt; nums.length; p++)&#123;</span><br><span class="line">        nums[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>,fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow &lt; nums.length &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）单链表解题技巧总结"><a href="#（8）单链表解题技巧总结" class="headerlink" title="（8）单链表解题技巧总结"></a>（8）单链表解题技巧总结</h3><p>单链表中，比较常用的操作有：1）合并两个有序链表    2）合并 k 个有序链表    3）寻找单链表的倒数第 k 个节点    4）寻找单链表的中点    5）寻找单链表的中点    6）寻找单链表的中点 。这些解法都⽤到了双指针技巧  ，下面以具体的题来说明</p>
<p><strong>（力扣21——合并两个有序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-26.png" alt="sf-1-26"></p>
<p><strong>说明</strong>：本题可以实现只遍历一次（开辟新的空间），需要使用三个指针，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(list1 == null || list2 == null)&#123;</span></span><br><span class="line">        <span class="comment">//     if(list1 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list1;</span></span><br><span class="line">        <span class="comment">//     &#125;else if(list2 != null)&#123;</span></span><br><span class="line">        <span class="comment">//         return list2;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// ListNode p1 = list1;</span></span><br><span class="line">        <span class="comment">// ListNode p2 = list2;</span></span><br><span class="line">        <span class="comment">// ListNode head = null;</span></span><br><span class="line">        <span class="comment">// ListNode p = null;</span></span><br><span class="line">        <span class="comment">//if(p1.val &lt;= p2.val)&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p1;</span></span><br><span class="line">        <span class="comment">//    p1 = p1.next;</span></span><br><span class="line">        <span class="comment">//&#125;else&#123;</span></span><br><span class="line">        <span class="comment">//    head = p = p2;</span></span><br><span class="line">        <span class="comment">//    p2 = p2.next;</span></span><br><span class="line">        <span class="comment">//&#125;  </span></span><br><span class="line">	  ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">	  ListNode p1 = list1, p2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &lt;= p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣23——合并K个升序链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-27.png" alt="sf-1-27"></p>
<p><strong>说明</strong>：本题和上题类似，关键是快速找到不同链表指针指向位置的最小值，我在自己做的时候，每次挑选最小的节点都要遍历一遍当前节点，如下，时间复杂度（on2）空间复杂度都很高，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line"></span><br><span class="line">        ListNode[] plist = <span class="keyword">new</span> ListNode[lists.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">            plist[i] = lists[i];</span><br><span class="line">            <span class="keyword">if</span>(lists[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), p = head;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; plist.length - <span class="number">1</span>)&#123;</span><br><span class="line">            min = tool.getMin(plist);</span><br><span class="line">            p.next = plist[min];</span><br><span class="line">            p = p.next;</span><br><span class="line">            plist[min] = plist[min].next;</span><br><span class="line">            <span class="keyword">if</span>(plist[min] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode temp : plist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p.next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(ListNode[] comp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; comp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( comp[i] != <span class="keyword">null</span> &amp;&amp; min == -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(comp[i] != <span class="keyword">null</span> &amp;&amp;  (comp[i].val &lt; comp[min].val) &amp;&amp; min != -<span class="number">1</span>)&#123;</span><br><span class="line">                min = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题解用了<strong>优先级队列（二叉堆）</strong>这种数据结构，时间复杂度仅有O(Nlogk)，其中 k 是链表的条数，N 是这些链表<br>的节点总数。代码如下：（这里使用了java的类，如果题目要求实现一个优先级队列，java有相关的实现类，原理的话<a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">看这篇文章</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">mergeLists</span><span class="params">(ListNode[] lists, lists)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//1，设置虚拟头结点，统一操作</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">//2，使用了java的PriorityQueue（优先级队列），第二个参数是lamda表达式，表明现在是按升序排列</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, (a,b)-&gt;(a.val - b.val))</span><br><span class="line">    <span class="comment">//3，将K个链表的头结点加入pq这个最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//pq的poll()方法可以提取出堆头元素</span></span><br><span class="line">        ListNode node = pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p指针推进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣19——删除链表的倒数第N个节点）</strong></p>
<p><strong>前言</strong>：链表不同于数组，可以快速定位到特定的位置。如果要定位某些特殊的位置（比如倒数第k个节点），最高效的方式也至少需要一次遍历中找到对应位置（采用双指针），一般思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的倒数第K个节点</span></span><br><span class="line"><span class="function">ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">//p1先走k步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">//p1和p2同时走n - k步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p2现在指向第n - k个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>—————————————————————我是分割线————————————————————————</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-28.png" alt="sf-1-28"></p>
<p>说明：本题采用上面的思路进行啦，不过要删除倒数第N个节点，我们需要找到的是倒数第N+1个节点，那么就把前一个指针往前放一位就可以了（第6行中的p1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode p1 = dummy,p2 = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣876——链表的中间节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-29.png" alt="sf-1-29"></p>
<p><strong>说明</strong>：其实这题和上一道题类似，都是用双指针，只是这道题比较含蓄，需要找中点，其实也就是两个指针，快的那个比慢的多走一倍即可，这样慢的那个就在中间的位置。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="comment">//这里的思路挺有意思，你必须保证fast能走两步，你的slow才能走一步，fast走两步可以落在null上，但是不能第一步就在null上</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣141——相交链表）</strong><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-30.png" alt="sf-1-30"></p>
<p><strong>说明</strong>：<u>判断链表是否包含环</u>也是链表题型中的一个重要的课题，参考上面的代码，其实也可以用快慢指针来寻找，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，快慢指针初始化指向head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">//2，快指针走到末尾时停止（它也可能没末尾）</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//3，走的步伐不一样</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">//4，两个指针相遇，那就说明有换</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这儿那就是没环了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣——剑指offer——链表中环的入口节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-31.png" alt="sf-1-31"></p>
<p><strong>说明</strong>：此题可以转化一下，类比于上面的一题的思路，我们让slow和fast两个速率不同的指针移动，如果fast指针最终指向了null，那么说明没有环；反之，如果存在环，两个指针进入环后，必定会在起点相遇</p>
<p>为什么不是在其他地方相遇呢？这个就很有意思了，类似于小学学的行程问题，这里我就不画图了，直接用labuladong公众号中的图说明，分为几个步骤：1)当两个指针在C点相遇时，假设走了slow指针走了k步，那么fast走了2k步，<strong>多走的k就是环长度的整数倍</strong>（考虑环只有一个元素的特殊情况便可理解）；2）将slow重新放到A点，那么slow走到B点需要k-m步，此时fast指针就和slow指针<strong>同样的速度</strong>走，就会在B点相遇。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-32.png" alt="sf-1-32"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lpublic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head,fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>力扣160——两个链表是否相交</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-33.png" alt="sf-1-33"></p>
<p><strong>说明</strong>：本题多种思路，首先利用上一题的判断环入口可以实现，也就是将第一条链表的尾接在第二条链表的头上。</p>
<p>第二种思路，统计长度，然后将两个链表的指针放在相同的起始点上，进而进行比较。下面是这种思路的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>,len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;p2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)&#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（9）递归操作链表"><a href="#（9）递归操作链表" class="headerlink" title="（9）递归操作链表"></a>（9）递归操作链表</h3><p><strong>（力扣——206）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-34.png" alt="sf-1-34"></p>
<p><strong>说明</strong>：本题有两种做法，非递归和递归方法，先说比较简单但不是重点的非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归解法，这里比较好理解就不多解释了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p1 = head, p2 = head.next, p3 = head.next.next;</span><br><span class="line">        p1.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            <span class="keyword">if</span>(p3 == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p3;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归解法，看下面的补充进行理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充</strong>：整个reverse函数的目标是——输⼊⼀个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点，我们可以根据以下几个图来理解整个步骤</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-35.png" alt="sf-1-35"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-36.png" alt="sf-1-36"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-37.png" alt="sf-1-37"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-38.png" alt="sf-1-38"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-40.png" alt="sf-1-40"></p>
<p><strong>（反转链表的前N个节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-39.png" alt="sf-1-39"></p>
<p>说明：这个似乎在力扣上没有对应的题，这里在上题的基础上，可以写出下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode successor = <span class="keyword">null</span>;<span class="comment">//这里设计一个后驱节点</span></span><br><span class="line"><span class="comment">//反转以head为起点的n个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseN</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//记录第n + 1个节点（也处理了一个节点的情况）</span></span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以head.next为起点，需要反转前n - 1个节点</span></span><br><span class="line">    ListNode last = reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反转完过后，将节点指向互换，并将head指向后一个节点（就像图中的1指向4）</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣92——反转链表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-41.png" alt="sf-1-41"></p>
<p><strong>说明</strong>：此题在使用前面函数的基础上，用递归的思想能够很快写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，如果left为1，其实就是上题的反转形式</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，我们要想办法把left变为1，那么也就是把head的位置往后移动，head每往后移动一个位置，其实反转的区间的相对位置就会减1.</span></span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，队列-x2F-栈（不知道为啥就跳到3了）"><a href="#3，队列-x2F-栈（不知道为啥就跳到3了）" class="headerlink" title="3，队列&#x2F;栈（不知道为啥就跳到3了）"></a>3，队列&#x2F;栈（不知道为啥就跳到3了）</h2><h3 id="（1）队列实现栈，以及栈实现队列"><a href="#（1）队列实现栈，以及栈实现队列" class="headerlink" title="（1）队列实现栈，以及栈实现队列"></a>（1）队列实现栈，以及栈实现队列</h3><p><strong>（力扣232——用栈实现队列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-42.png" alt="sf-1-42"></p>
<p><strong>说明</strong>：实现和这个代码，我们需要使用到java中的Stack类，这是一个Vector的子类，它的方法有：1）boolean empty()，判断栈是否为空，空返回true；2）Object peek()，返回栈顶元素，但不删除；3）Object pop(Object element)，返回栈顶元素，并删除；4）Object push(Object element)，将元素入栈并返回元素；5）int search(Object element)，寻找某元素并返回到栈顶的偏移量。了解了这个，那这道题就好办了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> Stack&lt;Integer&gt; s1, s2;</span><br><span class="line">    <span class="comment">//先在构造器中初始化两个栈，栈需要用泛型来制定存储的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入队列就直接进入s1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出队列，先调用peek将s1中的元素放到s2,s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回栈顶，那就需要先把s1的元素放到s2，s2的栈顶就是最先进入队列的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty()) s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣225——用队列实现栈）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-43.png" alt="sf-1-43"></p>
<p><strong>说明</strong>：这里需要使用到java中的Queue这个类，它的方法有：1）offer()，从队尾压入元素，返回压入的那个元素；2）poll()，删除并返回对队头被删除的那个元素；3）peek()，获取并返回队头元素。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> top_elem = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列中新添加的元素在队尾，其实就是栈顶元素，所以用top_elem记录一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.offer(x);</span><br><span class="line">        top_elem = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取栈顶元素直接返回top_elem</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top_elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//想要出栈，直接把队尾之前的元素统统出队再入队，最后队头就是栈顶元素，但是我们出的时候不要一次性出完，还得     //更新一下top_elem的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            q.offer(q.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        top_elem = q.peek();</span><br><span class="line">        q.offer(q.poll());</span><br><span class="line">        <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接判断队是不是空就行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（2）括号匹配问题"><a href="#（2）括号匹配问题" class="headerlink" title="（2）括号匹配问题"></a>（2）括号匹配问题</h3><p><strong>（力扣20——有效的括号）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-44.png" alt="sf-1-44"></p>
<p><strong>说明</strong>：单纯的统计左括号和有括号的数量是否相同是不行滴，因为位置有可能对不上，既然出现了位置，那么就能使用栈的特性来进行括号的匹配，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意两点：1）java中Stack的泛型指定只能使用包装类，不过由于自动装箱和自动转换，这个倒是影响不大；2）Stack类的方法要记清楚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; left = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                left.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!left.empty() &amp;&amp; leftOf(c) == left.peek())&#123;</span><br><span class="line">                    left.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣921——使括号有效的最小添加）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-45.png" alt="sf-1-45"></p>
<p><strong>说明</strong>：原题还说了字符串中只包含’(‘和’)’两种字符。其实和上一题类似，只是这里要设置一个计数器，我们遇到左括号入栈，遇到有括号则检查是不是有对应的左括号（没有的话，计数器加一），最后当遍历完字符串后，计数器再加上栈剩余的元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使用栈来解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) stack.push(c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2，不使用栈,以左括号为基准，通过维护对右括号的需求数 need，来计算最⼩的插⼊次数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) need++;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            	need--;</span><br><span class="line">                <span class="comment">//当need为-1的时候，意味着需要插入左括号了</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1541——平衡括号字符串的最好插入次数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-46.png" alt="sf-1-46"></p>
<p><strong>说明</strong>：如果按照上一题的维护res和need变量的话，要考虑几个特殊情况：1）一个左括号对应两个右括号，那么遇到左括号，need值应该+2；2）如果need值为-1的话，那么多了一个右括号，此时res应该+1，表明需要一个左括号，并且need重设为1；3）反观第1）步，如果对有括号的需求为奇数，那么只需要插入一个右括号，所以这里需要进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, need = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : ss)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                need += <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//res其实对应了右括号的插入，这里need为奇数，表明前面需要一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                need--;</span><br><span class="line">                <span class="comment">//这里res表明了需要一个左括号的插入，同时需要多对应一个右括号</span></span><br><span class="line">                <span class="keyword">if</span>(need == -<span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    need = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + need;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）单调栈"><a href="#（3）单调栈" class="headerlink" title="（3）单调栈"></a>（3）单调栈</h3><p><strong>引入</strong>：单调栈实际上就是栈，只是利⽤了⼀些巧妙的逻辑，使得每次新元素⼊栈后，栈内的元素都保持有序（单调<br>递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈⽤途不太⼴泛，只处理⼀种典型的问题，叫做 Next Greater Element。本⽂⽤讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略  </p>
<p><strong>模板</strong>：给你⼀个数组 nums，请你返回⼀个等⻓的结果数组，结果数组中对应索引存储着下⼀个更⼤元素，如果没有<br>更⼤的元素，就存 -1  。（比如输入nums &#x3D; [2,1,2,4,3]，返回[4,2,4,-1,-1]，也就是第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1 ）</p>
<p>其实没那么复杂，把这一串数字的每一个从后往前放到栈中，然后新的数字来了以后，看栈中的数字大小怎么样，如果比当前的数字小就出栈，否则，你就是它要找的那个数字呀！（这里注意栈空就是表明应该是-1）</p>
<p>倒着⼊栈，其实是正着出栈。while 循环是把两个「个⼦⾼」元素之间的元素排除，因为他们的存在没有意义，前⾯挡着个「更⾼」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">find</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek())&#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">           stack.push(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣739——每日温度)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-47.png" alt="sf-1-47"></p>
<p>这里我们把栈里记录的信息改为下标，就可以实现算出气温高的天数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = temperatures.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt;= temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = stack.isEmpty() ? <span class="number">0</span> : stack.peek() - i;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣503——处理环形数组）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-48.png" alt="sf-1-48"></p>
<p><strong>说明</strong>：这题在之前的基础上又麻烦了，两个思路：一个是将数组翻倍，这样的话可以直接套用上面的模板；另一个思路是通过%运算符来实现环形效果。两种方式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，扩展数组的写法，这个还比较简单好理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] numsEx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            numsEx[i] = nums[i];</span><br><span class="line">            numsEx[i + nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = numsEx.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; numsEx[i] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                res[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(numsEx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2，使用循环数组模拟扩展的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i % n] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i % n] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）单调队列解决滑动窗口"><a href="#（4）单调队列解决滑动窗口" class="headerlink" title="（4）单调队列解决滑动窗口"></a>（4）单调队列解决滑动窗口</h3><p><strong>引入</strong>：这里只讲一道题，<strong>力扣239——滑动窗口最大值</strong>，这道题需要使用单调队列来解决，单调队列指的是：一个队列，其中的元素全都是单调递增（或递减）的。</p>
<p><strong>题目</strong>：给你输⼊⼀个数组 nums 和⼀个正整数 k，有⼀个⼤⼩为 k 的窗⼝在 nums 上从左⾄右滑动，请你输出每次<br>窗⼝中 k 个元素的最⼤值。  示例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-50.png" alt="sf-1-50"></p>
<p><strong>步骤</strong>：</p>
<p><u>A，搭建解题框架</u></p>
<p>本题的难点在于如何在 O(1) 时间算出每个「窗⼝」中的最⼤值，使得整个算法在线性时间完成。这种问题的⼀个特殊点在于，「窗⼝」是不断滑动的，也就是你得动态地计算窗⼝中的最⼤值。</p>
<p>假设我们已经有一个单调队列 MonotonicQueue类，有添加元素（push），返回当前最大元素（max），删除元素（pop）方法，并且时间复杂度都是O(1)，使用这个类可以搭出框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;<span class="comment">//两个参数，一个是数组，一个是我们要扫描的窗口</span></span><br><span class="line">    MonotonicQueue window = <span class="keyword">new</span> MononicQueue();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先在窗口中预备好k - 1个元素</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//进入了这个分支就意味着要开始滑动了，先进入一个</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            <span class="comment">//然后找到当前窗口最大值</span></span><br><span class="line">            res.add(window.max());</span><br><span class="line">            <span class="comment">//最后退出一个（注意这里是退出指定的元素哦）</span></span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            arr[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-51.png" alt="sf-1-51" style="zoom:67%;" />

<p><u>B，实现单调队列数据结构</u></p>
<p>「单调队列」的核⼼思路和「单调栈」类似：1）push ()⽅法依然在队尾添加元素，但是要把前⾯⽐⾃⼰⼩的元素<br>都删掉，这样这窗口中的元素入队后，队头始终是最大的按个元素（如果队头和新来新来的元素一样大，那可就千万别动了）；2）max()方法的话，就直接取队头咯；3）pop()方法的话，先判断一下队头元素是不是和之前插入的元素一样，一样再出队，不然可能早就没了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.getLast() &lt; n)&#123;</span><br><span class="line">            q.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        a.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == q.getFirst())&#123;</span><br><span class="line">            q.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，实现 MonotonicQueue 时，我们使⽤了 Java 的 LinkedList，因为链表结构⽀持在头部和尾部快速增删元素；⽽在解法代码中的 res 则使⽤的 ArrayList 结构，因为后续会按照索引取元素，所以数组结构更合适</p>
<h3 id="（5）数组去重"><a href="#（5）数组去重" class="headerlink" title="（5）数组去重"></a>（5）数组去重</h3><p>数组去重其实前面已经练习过，这里是两道增强的题，加上前面的题，应该可以解决大部分问题</p>
<p><strong>（力扣316——去除重复字母）</strong></p>
<p>本题与力扣1081题解法相同</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-52.png" alt="sf-1-52" style="zoom:80%;" />

<p><strong>说明</strong>：本题有两个难点：1）去重字符串中的字符串顺序不能打乱s中字符出现的相对顺序；2）在符合上一条的去重字符串中，字典序最小的为输出（比如示例1，bca和abc都是去重的，但是abc的字典序更小）</p>
<p>这里最好自己手动分析一下，值得注意的是，如果没有1,4，步骤，那么s &#x3D; “bcac”的结果就是ac</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">//1,新建一个数组来统计字符串中不同字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] instack = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//2，每个字符串在进行判断时，都需要将次数-1，这样剩下的数字才能准确反映还有多少，如果这个字母已经在instack数组中了，那么就不用检查了</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span>(instack[c]) <span class="keyword">continue</span>;</span><br><span class="line">		   <span class="comment">//3,要保证字典序，那么入栈的时候，尽量要将小的放底下</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.isEmpty() &amp;&amp; stk.peek() &gt; c)&#123;</span><br><span class="line">                <span class="comment">//4，对于栈中更大的元素，如果以后还有这个元素，则可以出栈，但是如果没有就别出了，这里也不是continue嗷，因为这个元素是确实需要的去重的一份子</span></span><br><span class="line">                <span class="keyword">if</span>(count[stk.peek()] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//5，出栈了就变为false</span></span><br><span class="line">                instack[stk.pop()] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            instack[c] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6，最终栈中的元素出栈，顺序是反的，还得翻转一下</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4，数据结构设计"><a href="#4，数据结构设计" class="headerlink" title="4，数据结构设计"></a>4，数据结构设计</h2><p>数据结构设计题主要就是给你提需求，让你实现 API，⽽且要求这些 API 的复杂度尽可能低 ，一般来说设计题中哈希表的出现频率很⾼，⼀般都是各类其他数据结构和哈希表组合，从⽽改善这些基本数据结构的特性。</p>
<h3 id="（1）实现LRU算法（最近最少使用算法）"><a href="#（1）实现LRU算法（最近最少使用算法）" class="headerlink" title="（1）实现LRU算法（最近最少使用算法）"></a>（1）实现LRU算法（<strong>最近最少使用算法</strong>）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-53.png" alt="sf-1-53"></p>
<p><strong>思路</strong>：</p>
<p>题目要求：1）put和get方法的时间复杂度为O(1)；2）该catch中的元素必须有时序；3）catch中需要快速找到某个key是否已经存在并得到对应的val；4）每次访问catch中的某个key，这个元素的时序要改为最近使用，也就是快速把这个元素抽出来换位置。为了实现这个目标，我们需要使用<strong>哈希链表（双向链表+哈希表）</strong>，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-54.png" alt="sf-1-54" style="zoom:50%;" />

<p>上面的数据结构中，如何满足上面的条件？1）默认从链表尾部添加元素的话，那么越靠近尾部是越近使用的（已经存在的可以先拆下来放到尾部去）；2）对于某个key，可以通过hash表快速定位到链表中对应的节点，免去遍历链表的时间；3）双向链表支持任意位置的插入和删除。</p>
<p>下面我们看看分步骤的代码实现：</p>
<p>A，构建双链表节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = k;</span><br><span class="line">         <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B，使用Node构建双链表（该结构要有 表尾添加，删除，表头删除，返回长度等API），双链表可以不用记录前驱结点实现操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，需要有头结点来统一操作</span></span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="comment">//2，链表的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3，链表初始化</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，在链尾加入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.pre = x; </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，删除元素，注意这里能使用该方法表明一定要有x这个节点，判断不在这里判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.pre;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6，删除链头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == tail)&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7，返回链表大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> size;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，与哈希表进行结合（这里先是使用上面的数据结构把LRUCatch的数据结构搭建）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，上一步的get和put方法，如果直接写会很容易出现问题，我们应该先抽象几个要使用的方法出来，从而是的get和put不直接操作map和catch，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1,key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get 和 put方法的实现</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//4个要使用的方法</span></span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E，综合C和D中的内容，写出get和put方法，put方法有点复杂，先画一个运行流程图</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-55.png" alt="sf-1-55" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCatch</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，key-&gt;Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">//2，Node(k1, v1) &lt;-&gt; Node(k2, v2)</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList <span class="keyword">catch</span>;</span><br><span class="line">    <span class="comment">//3，最大容量</span></span><br><span class="line">    <span class="keyword">private</span> intcap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCatch</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4，get 和 put方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.contiansKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            deleteKey(key);</span><br><span class="line">            addRecently(key, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cap == cache.size())&#123;</span><br><span class="line">            removeLeastRecently();</span><br><span class="line">        &#125;</span><br><span class="line">        addRecently(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5，几个抽象出来的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将某个   key 提升为最近使⽤的 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 重新插到队尾</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 添加最近使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">		<span class="comment">// 链表尾部就是最近使⽤的元素</span></span><br><span class="line">		cache.addLast(x);</span><br><span class="line">		<span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">		map.put(key, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除某⼀个   key */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		Node x = map.get(key);</span><br><span class="line">		<span class="comment">// 从链表中删除</span></span><br><span class="line">		cache.remove(x);</span><br><span class="line">		<span class="comment">// 从 map 中删除</span></span><br><span class="line">		map.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 删除最久未使⽤的元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 链表头部的第⼀个元素就是最久未使⽤的</span></span><br><span class="line">		Node deletedNode = cache.removeFirst();</span><br><span class="line">		<span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">		<span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">		map.remove(deletedKey);</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：1）分析需要使用的数据结构；2）实现基本数据结构和方法；3）实现目标数据结构和方法</p>
<h3 id="（2）实现LFU算法（最不经常使用）"><a href="#（2）实现LFU算法（最不经常使用）" class="headerlink" title="（2）实现LFU算法（最不经常使用）"></a>（2）实现LFU算法（最不经常使用）</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-56.png" alt="sf-1-56"></p>
<p><strong>说明</strong>：从实现难度上来说，LFU 算法的难度⼤于 LRU 算法，LFU 算法相当于是把数据按照访问频次进⾏排序，这个需求恐怕没有那么简单，⽽且还有⼀种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插⼊的那个数据。也就是说 <strong>LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据</strong>。  </p>
<p>可以看到LFU 算法是要复杂很多的，⽽且经常出现在⾯试中，因为 LFU 缓存淘汰算法在⼯程实践中经常使⽤，<br>也有可能是应该 LRU 算法太简单了。不过话说回来，<strong><strong>这种著名的算法的套路都是固定的，关键是由于逻辑较</strong><br>复杂，不容易写出漂亮且没有 bug 的代码。</strong>  </p>
<p><strong>思路</strong>：</p>
<p><u>首先</u>，有几点我们需要注意：1）调⽤ get(key) ⽅法时，要返回该 key 对应的 val  ；2）只要⽤ get 或者 put ⽅法访问⼀次某个 key，该 key 的 freq 就要加⼀ ；3）如果在容量满了的时候进⾏插⼊，则需要将 freq 最⼩的 key 删除，如果最⼩的 freq 对应多个 key，则删除其中最旧的那⼀个。  </p>
<p><u>接着</u>，我们的目标是在O(1)的时间复杂度完成这些需求，我们可以使用下面的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使⽤⼀个 HashMap 存储 key 到 val 的映射，就可以快速计算 get(key)。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、使⽤⼀个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq。</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure>

<p><u>接着</u>，有一个核心需求，我们来看看步骤：</p>
<p>1）我们需要 freq 到 key 的映射，⽤来找到 freq 最⼩的 key；</p>
<p>2）将 freq 最⼩的 key 删除，那你就得快速得到当前所有 key 最⼩的 freq 是多少。想要时间复杂度O(1) 的话，肯定不能遍历⼀遍去找，那就⽤⼀个变量 minFreq 来记录当前最⼩的 freq 吧；</p>
<p>3）可能有多个 key 拥有相同的 freq，所以 freq 对 key 是<strong>⼀对多</strong>的关系，即⼀个 freq 对应⼀个 key 的列表；</p>
<p>4）希望 freq 对应的 key 的列表是<strong>存在时序的</strong>，便于快速查找并删除最旧的 key；</p>
<p>5）希望能够快速删除 key 列表中的任何⼀个 key，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 freq+1，就应该从 freq 对应的 key 列表中删除，加到 freq+1 对应的 key 的列表中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkedHashSet，它满⾜我们 3.3，3.4，3.5 这⼏个要求。你会发现普通的链表LinkedList 能够满⾜ 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某⼀个节点，所以⽆法满⾜ 3.5 的要求。</span></span><br><span class="line"><span class="comment">//LinkedHashSet 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插⼊元素具有时序；哈希集合中的元素⽆序，但是可以对元素进⾏快速的访问和删除。</span></span><br><span class="line"><span class="comment">//那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，⼜可以保持插⼊的时序，⾼效实现 3.5 这个需求。</span></span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="keyword">int</span> minFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>最后，LFU算法的基本数据结构就浮现出来啦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line">    <span class="comment">//key到val的映射，简称KV表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">//key到freq的映射，简称KF表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFre;</span><br><span class="line">    <span class="comment">//freq到key的映射，简称FK表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">//记录当前的最小频次数量</span></span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="comment">//记录LFU缓存的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyToFre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码框架</strong>：</p>
<p>A，指导思想</p>
<p><strong>1、</strong>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。<strong>2、</strong>搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。<strong>3、</strong>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p>
<p>B，get方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!keyToVal.containsKey(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加key对应的val</span></span><br><span class="line">    increaseFreq(key);<span class="comment">//这是一个核心方法，抽象为函数看起来比较简介</span></span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C，put方法</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-57.png" alt="sf-1-57" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//若key已经存在，则修改对应的val值</span></span><br><span class="line">    <span class="keyword">if</span>(keyToVal.containsKey(key))&#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若key不存在，则需要插入，首先判断容量是不是满了，满了就淘汰一个Freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cap &lt;= keyToVal.size())&#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入key和val，手相放到KV表里去</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">//插入KF表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//插入FK表</span></span><br><span class="line">    freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">//freq更新为最小，就是1</span></span><br><span class="line">    <span class="keyword">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D，两个核心函数</p>
<p>可以从上面看出，最核心的两个函数就是removeMinFreqKey()和increaseFreq()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除某个键key肯定是要同时修改三个映射表的，借助minFreq参数可以从FK表中找到freq最小的keyList，根据时序，其中第一个元素就是要被淘汰的deletedKey，操作三个映射表删除这个key即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里有个问题，如果keyList中只有一个元素，那么删除之后minFreq对应的key列表就为空了，也就是minFreq变量需要被更新。如何计算当前的minFreq是多少呢？（其实只能遍历更新），我们这里不考虑这个情况，因为该方法只有put方法中插入新key时可能调用。而你回头看put的代码，插入新key时一定会把minFreq更新成 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="keyword">this</span>.minFreq);</span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="keyword">int</span> deletedKey = keyList.iterator().next();</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    keyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="keyword">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和之前类似，当FK表中freq对应的列表被删空后，需要删除FK表中freq这个映射。如果这个freq恰好是minFreq，说明minFreq变量需要更新。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//能不能快速找到当前的minFreq呢？这里是可以的，因为我们刚才把key的freq加了 1 嘛，所以minFreq也加 1 就行了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = keyToFreq.get(key);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="keyword">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）常数时间查找-x2F-删除数组中任意元素"><a href="#（3）常数时间查找-x2F-删除数组中任意元素" class="headerlink" title="（3）常数时间查找&#x2F;删除数组中任意元素"></a>（3）常数时间查找&#x2F;删除数组中任意元素</h3><p><strong>（力扣380——常数时间插入，删除和获取随机元素）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-58.png" alt="sf-1-58" style="zoom: 67%;" />

<p><strong>思路</strong>：</p>
<p>本题的难点有两个：1）插入，删除，获取随机元素这三个操作的时间复杂度必须为o(1)；2）getRadom方法必须以等概率返回元素。</p>
<p>对于第一个要求，我们熟悉的数据结构中，想到了HashSet，哈希集合的底层原理就是⼀个⼤数组，我们把元素通过哈希函数映射到⼀个索引上；如果⽤拉链法解决哈希冲突，那么这个索引可能连着⼀个链表或者红⿊树。  它能满足常数时间插入，删除。然而问题是，元素是被哈希函数「分散」到整个数组⾥⾯的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素  </p>
<p>那么哈希链表 LinkedHashSet呢？，我们前⽂讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中 ，然而这依然⽆法按要求实现我们的 getRandom 函数，因为底层⽤链表结构存储元素的话，是⽆法在 O(1) 的时间内访问某⼀个元素的。  </p>
<p>所以我们必须用数组，数组最困难的要实现插入和删除的时间复杂度是O(1)，我们只能在尾部进行插入和删除。删除数组中的某⼀个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉。交换两个元素必须通过索引进⾏交换对吧，那么我们需要⼀个哈希表 valToIndex 来记录每个元素值对应的索引。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; dict;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dict = <span class="keyword">new</span> HashMap();</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list.size(),val);<span class="comment">//这里ArrayList.put(index,val)表示在index位置放入val</span></span><br><span class="line">        dict.put(val, list.size() - <span class="number">1</span>);<span class="comment">//val作为key，这样好查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dict.containsKey(val)) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//</span></span><br><span class="line">        <span class="comment">//将最后一个元素覆盖到val的位置，表示val已经去除，然后就在list和dict删除多余的元素即可</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> last = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lastIdx = dict.get(val);</span><br><span class="line">        list.set(lastIdx, last);</span><br><span class="line">        dict.put(last,lastIdx);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        dict.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣710——黑名单中的随机数）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-59.png" alt="sf-1-59"></p>
<p><strong>思路</strong>：我们不能简单的不断去random直到获得一个不是黑名单的数字，那样调用次数非常多。我们发现，题中数组的数字范围和数组大小相同，那么我们是不是可以把黑名单数字全部移到最后，然后把后面的合法数字移到前面来。</p>
<p>当然，移动数字的话是一种思路，我们下面是将黑名单数字映射到合法数字，比如长度为6的数组，遇到了3是一个黑名单数，它的下标是2，如果下标为5的数字6不是黑名单数，那么我们就用map存储&lt;2,6&gt;，表示2这个下标对应的是6，不是黑名单数3啦。之后再随机取的话就好办了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] blacklist)</span> </span>&#123;</span><br><span class="line">        mapping = <span class="keyword">new</span> HashMap();</span><br><span class="line">        sz = n - blacklist.length;</span><br><span class="line">        <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : blacklist)&#123;</span><br><span class="line">            mapping.put(a,<span class="number">9527</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1，我们的目标是将黑名单的数映射到一个正确的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : blacklist)&#123;</span><br><span class="line">            <span class="comment">//2,如果temp本身就在这个区间里面，就别设置它了</span></span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= sz) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3,如果last指向的位置已经在map中，那么这个last不行</span></span><br><span class="line">            <span class="keyword">while</span>(mapping.containsKey(last))&#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping.put(temp,last);</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = rand.nextInt(sz);</span><br><span class="line">        <span class="keyword">if</span>(mapping.containsKey(k)) <span class="keyword">return</span> mapping.get(k);</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）中位数"><a href="#（4）中位数" class="headerlink" title="（4）中位数"></a>（4）中位数</h3><p><strong>（力扣295——数据流的中位数）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-60.png" alt="sf-1-60" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>首先，我们需要回顾一下以往的手段，以及它们的是否能使用：1）普通数组，查找很快，但是插入不行，log（n）的时间复杂度；2）普通链表，也不行，查找慢；3）java的TreeSet，是一种平衡二叉树的实现，底层是红黑树，但是它是一个set不能输入重复元素，其次它并没有实现一个通过排名快速计算元素的 API。假设我想找到<code>TreeSet</code>中第 5 大的元素，并没有一个现成可用的方法实现这个需求；4）优先级队列（二叉堆），也不太行，它是一种受限的数据结构，只能从堆顶添加&#x2F;删除元素，我们的<code>addNum</code>方法可以从堆顶插入元素，但是<code>findMedian</code>函数需要从数据中间取，这个功能优先级队列是没办法提供的。</p>
<p>我们必须要使用有序数据结构，本题核心是，使用两个优先级队列，优先级队列前面用过，能够使插入的元素按顺序排列，看看下面这个图，我们就知道原理了</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-61.png" alt="sf-1-61"  />

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; large;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这个优先级队列默认从小到大排列，所以small使用lamda表达式调整对从大到小</span></span><br><span class="line">        large = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> b - a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small.size() &gt;= large.size())&#123;</span><br><span class="line">            small.offer(num);</span><br><span class="line">            large.offer(small.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            large.offer(num);</span><br><span class="line">            small.offer(large.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span></span><br><span class="line">        <span class="keyword">if</span> (large.size() &lt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.peek();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large.size() &gt; small.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> large.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span></span><br><span class="line">        <span class="keyword">return</span> (large.peek() + small.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四，进阶数据结构"><a href="#四，进阶数据结构" class="headerlink" title="四，进阶数据结构"></a>四，进阶数据结构</h1><h2 id="1，二叉树"><a href="#1，二叉树" class="headerlink" title="1，二叉树"></a>1，二叉树</h2><p><strong>二叉树非常重要，</strong>这是因为二叉树的思想在很多算法题中都有出现，何以见得？看看快速排序和归并排序。</p>
<p>快速排序其实就是一个前序遍历的思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">	<span class="comment">/************************/</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lo;</span><br><span class="line">    <span class="keyword">int</span> index = p + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[p])&#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, p, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序则是一个后序遍历的思想（先对左右子数组排序，再进行合并）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：排序 nums[lo..hi]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">	sort(nums, lo, mid);</span><br><span class="line">	<span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">	sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">	<span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">	<span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">	merge(nums, lo, mid, hi);</span><br><span class="line">	<span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>树中的递归算法</strong>，</p>
<p>写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节。  </p>
<p>⽐如说让你计算⼀棵⼆叉树共有⼏个节点：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：count(root) 返回以 root 为根的树有多少节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// ⾃⼰加上⼦树的节点数就是整棵树的节点数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + count(root.left) + count(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个问题⾮常简单，⼤家应该都会写这段代码，root 本身就是⼀个节点，加上左右⼦树的节点数就是以</span><br><span class="line">root 为根的树的节点总数。</span><br><span class="line">左右⼦树的节点数怎么算？其实就是计算根为 root.left 和 root.right 两棵树的节点数呗，按照定义，</span><br><span class="line">递归调⽤ count 函数即可算出来</span><br></pre></td></tr></table></figure>

<p>简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调⽤⼦节点，递归调⽤会让孩⼦节点做相同的事情。  </p>
<h3 id="（1）二叉树——1"><a href="#（1）二叉树——1" class="headerlink" title="（1）二叉树——1"></a>（1）二叉树——1</h3><p><strong>（力扣226——翻转二叉树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-62.png" alt="sf-1-62" style="zoom:67%;" />

<p><strong>思路</strong>：本题代码简单，但是要想清楚，到底用哪种遍历呢？其实前序和后序都可以，但是中序不行，中序遍历换节点 根据左根右的遍历顺序 相当于左侧节点交换了两次 右侧节点没换  因为遍历根的时候交换了左右节点 遍历右侧的时候还是之前那个左节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode left = root.left, right = root.right;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        invertTree(left);</span><br><span class="line">        invertTree(right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣116——填充每个节点的下一个右侧节点指针）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-63.png" alt="sf-1-63" style="zoom: 80%;" />

<p><strong>思路</strong>：这里需要高度抽象，别想太多，对于一个节点的左子树和右子树，应该先递归连接它们的孩子，然后把左子树的右指针，连到右子树的左指针。还是看代码吧（一看就会，一作就废）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        connectTwoNode(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键就是这里，我们要同时递归操作两个节点（或者是两个子树），所以需要这个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node node1, Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line">        connectTwoNode(node1.left, node1.right);</span><br><span class="line">        connectTwoNode(node2.left, node2.right);</span><br><span class="line">        <span class="comment">//这里就是将两个分开的字数连在一起的操作，别去想为什么</span></span><br><span class="line">        connectTwoNode(node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣114——将二叉树展开为链表)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-64.png" alt="sf-1-64"></p>
<p><strong>说明</strong>：左子树和右子树操作完应该按照链来处理，不再是树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root ==  <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">		<span class="comment">//经过上面的递归，左子树和右子树都变为链，此时进行连接操作。</span></span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line"></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span>(p.right != <span class="keyword">null</span>)&#123;   </span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉树——2"><a href="#（2）二叉树——2" class="headerlink" title="（2）二叉树——2"></a>（2）二叉树——2</h3><p><strong>（力扣654——最大二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-65.png" alt="sf-1-65"></p>
<p><strong>思路</strong>：这道题就是，找到最大值作为根节点，然后构建左子树，构建右子树，然后根节点接上左子树和右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CreateTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">CreateTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>,maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">        root.left = CreateTree(nums, begin, maxIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = CreateTree(nums, maxIndex + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣105——通过前序和中序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-66.png" alt="sf-1-66"></p>
<p><strong>思路</strong>：这是经典问题了，关键是每次都要传入两个数组，并且限定好两个数组的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span> <span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal) index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize = index - inStart; </span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftsize,</span><br><span class="line">            inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, preStart + leftsize + <span class="number">1</span>, preEnd,</span><br><span class="line">            inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣106——利用中序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-67.png" alt="sf-1-67"></p>
<p><strong>思路</strong>：类似于上一题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postStart &gt; postEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSize = rootIndex - inStart;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        root.left = build(inorder, inStart, rootIndex - <span class="number">1</span>, postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        root.right = build(inorder, rootIndex + <span class="number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣889——根据前序和后序遍历构造二叉树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-68.png" alt="sf-1-68"></p>
<p><strong>思路</strong>：这里是无法确一颗二叉树的，只需要返回一种可能的情况就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//！！！这里其实对应的是特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="keyword">int</span> nextRIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = postStart; i &lt;= postEnd; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] == preorder[preStart + <span class="number">1</span>])&#123;</span><br><span class="line">                nextRIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = nextRIdx - postStart;</span><br><span class="line">		<span class="comment">//!!!这里的nextRIdx不要换成leftsize</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize + <span class="number">1</span>, postorder, postStart, nextRIdx);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">2</span>, preEnd, postorder, nextRIdx + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉树——3"><a href="#（3）二叉树——3" class="headerlink" title="（3）二叉树——3"></a>（3）二叉树——3</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-69.png" alt="sf-1-69" style="zoom:80%;" />

<p><strong>思路</strong>：这题在判断子树的结构时，需要将子树序列化成一个String，这样方便比较，然后再把子树的String进行存储和比较，具体看代码比较清晰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; subTree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String left = traverse(root.left);</span><br><span class="line">        String right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        String sub = left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time = subTree.getOrDefault(sub, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">1</span>) res.add(root);</span><br><span class="line">        subTree.put(sub, time + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）二叉树序列化，多种框架"><a href="#（4）二叉树序列化，多种框架" class="headerlink" title="（4）二叉树序列化，多种框架"></a>（4）二叉树序列化，多种框架</h3><p><strong>（力扣297——二叉树序列化和反序列化）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-70.png" alt="sf-1-70"  />

<p><strong>思路</strong>：本题可以用前序遍历，后序遍历，中序遍历，层次遍历解决，这里按顺序来展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 前序遍历 将二叉树转换为字符串，比如例子会转换为[1,2,#,#,3,4,#,#,5,#,#]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于上面的字符串中有空指针信息，那么便可以根据前序遍历结构，前序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果字符是#表示空指针，返回空指针</span></span><br><span class="line">        String first = nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(first.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(first));</span><br><span class="line"></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        traverse(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : data.split(spe))&#123;</span><br><span class="line">            nodes.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法按 后序遍历 将二叉树转换为字符串，比如例子会转换为[2,#,#,4,#,#,5,#,#,3,1]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果是null值，存储为null，并且加上分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left,sb);</span><br><span class="line">        traverse(root.right,sb);</span><br><span class="line">        <span class="comment">//加分隔符</span></span><br><span class="line">        sb.append(root.val).append(spe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以[2,#,#,4,#,#,5,#,#,3,1]为基础后序遍历恢复</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//nodes空了就返回null</span></span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String last = nodes.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(last.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(last));</span><br><span class="line">        <span class="comment">//从后往前在 nodes 列表中取元素，一定要先构造 root.right 子树，后构造 root.left 子树</span></span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历实现不了</span></span><br><span class="line">想实现反序列方法，首先要构造 root 节点。前序遍历得到的 nodes 列表中，第一个元素是 root 节点的值；后序遍历得到的 nodes 列表中，最后一个元素是 root 节点的值。</span><br><span class="line"></span><br><span class="line">你看上面这段中序遍历的代码，root 的值被夹在两棵子树的中间，也就是在 nodes 列表的中间，我们不知道确切的索引位置，所以无法找到 root 节点，也就无法进行反序列化。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">//1,标准的层次遍历框架（重要）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1，初始化队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        <span class="comment">//---层次遍历操作位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,实现序列化实现，题中的序列化结果为[1,2,3,#,#,4,5,#,#,#,#]</span></span><br><span class="line">String spe = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">String NULL = <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(spe);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val).append(spe);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，这里并不会判断是不是NULL，因为就算是，也需要加入到String的信息中去</span></span><br><span class="line">        q.offer(cur.left);</span><br><span class="line">        q.offer(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,实现反序列化,将[1,2,3,#,#,4,5,#,#,#,#]变为数，可以看到，1对应2和3,2对应#和#，3对应4和5，以此类推</span></span><br><span class="line"><span class="comment">//下面代码中的结构和层次遍历的逻辑非常相似，都是将节点存入队列，然后左孩子进队列，右孩子进队列</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] nodes = data.split(spe);</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.length; i++)&#123;</span><br><span class="line">        TreeNode parent = q.poll;</span><br><span class="line">        </span><br><span class="line">        String left = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!left.equals(NULL))&#123;</span><br><span class="line">            parent.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(left));</span><br><span class="line">            q.offer(parent.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String right = nodes[i++];</span><br><span class="line">        <span class="keyword">if</span>(!right.equals(NULL))&#123;</span><br><span class="line">            parent = right = <span class="keyword">new</span> TreeNode(Integer.parseInt(right));</span><br><span class="line">            q.offer(parent.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）后序遍历"><a href="#（5）后序遍历" class="headerlink" title="（5）后序遍历"></a>（5）后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-71.png" alt="sf-1-71"></p>
<p><strong>思路</strong>：</p>
<p>不管是什么遍历，最关键的就是梳理思路，明确要记录的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-72.png" alt="sf-1-72"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] traverse(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = traverse(root.right);</span><br><span class="line">		<span class="comment">//res[0]代表这个子树是不是二叉搜索树,res[1]树的最大值,res[2]树的最小值 ,res[3]整个树的和</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>])&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = Math.min(root.val, left[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>] = Math.max(root.val, right[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><h2 id="2，二叉搜索树"><a href="#2，二叉搜索树" class="headerlink" title="2，二叉搜索树"></a>2，二叉搜索树</h2><h3 id="（1）二叉搜索树——1"><a href="#（1）二叉搜索树——1" class="headerlink" title="（1）二叉搜索树——1"></a>（1）二叉搜索树——1</h3><p><strong>(力扣230——二叉搜索树中第K小的元素)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-73.png" alt="sf-1-73" style="zoom: 80%;" />

<p><strong>思路</strong>：二叉搜索树的中序遍历就是从小到大排序的，所以这里进行一个简单的中序遍历就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,简单的遍历方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       preTraverse(root,k);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            res =  root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+++++++++++++++++++++++++++++++++++++++分割线++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2，如果说TreeNode中，每个节点包含自己的排序信息，那么这里的时间复杂度可以降低到O(logN),</span></span><br><span class="line"><span class="comment">//如果节点中有以自己为根的子树的节点数信息，那么排名 = root.val - root.left.val</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么中序遍历的算法中,就可以直接计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        preTraverse(root.left, k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val - root.left.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == k) res = root.val;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preTraverse(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣538——把二叉搜索树转化为累加树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-74.png" alt="sf-1-74"></p>
<p><strong>思路</strong>：原本的二叉搜索树，中序遍历是按照从左往右，升序打印。如果这里我们能从右往左，降序打印，便可解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）二叉搜索树——2-检查，搜索，插入，删除"><a href="#（2）二叉搜索树——2-检查，搜索，插入，删除" class="headerlink" title="（2）二叉搜索树——2   (检查，搜索，插入，删除)"></a>（2）二叉搜索树——2   (检查，搜索，插入，删除)</h3><p><strong>（判断搜索二叉树的合法性）</strong></p>
<p><strong>思路</strong>：给了你一个二叉树，如何判断是不是搜索二叉树？可以尝试在前序遍历的时候，对于一个节点，它&gt;左孩子的值并且&lt;右孩子的值，如果有不满足这个条件的，那不是二叉搜索树。</p>
<p>但是上面的方法并不能完全满足（比如10,5,15,#,#,6,20），因为规则有漏洞，对于一个节点，我们应该比较它与左子树的最大值，和右子树的最小值，以此来判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//相等也是不行的</span></span><br><span class="line">    <span class="keyword">if</span>(min != <span class="keyword">null</span> &amp;&amp; root.val &gt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max != <span class="keyword">null</span> &amp;&amp; root.val &lt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isValid(root.left, min, root) &amp;&amp; isValid(root.right, root, max);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣700——二叉搜索树中搜索）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-%2076.png" alt="sf-1- 76" style="zoom:80%;" />

<p><strong>思路</strong>：这个简单，但是还是时间复杂度的问题，我们可以采取剪枝的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        preTraverse(root, val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            preTraverse(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            preTraverse(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（在BST中插入一个数）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        return insertBST(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode insertBST(TreeNode root, int val)&#123;</span><br><span class="line">        if(root == null) return new TreeNode(val);</span><br><span class="line"></span><br><span class="line">        if(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertBST(root.left, val);</span><br><span class="line">        &#125;else if(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣450——删除二叉搜索树中的节点）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-75.png" alt="sf-1-75"></p>
<p><strong>思路</strong>：整体上的思路是，前序遍历，如果该节点需要删除，则删除，如果不是的话，那么该节点链接删除了的左子树，链接删除了的右子树。也就是上面这个框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，简单框架</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，加入删除操作，删除节点有三种情况，每种的解决方式不一样</span></span><br><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">        <span class="comment">//这里包含了root节点没有左右孩子，or有左无右，or有右无左的三种情况</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">//最麻烦的是root节点左右孩子都有的情况，此时只能将右子树接在左子树最大的节点，或者将左子树接在右子树最小的节点来进行处理，这里我们采用第二种</span></span><br><span class="line">        TreeNode midNode = getMin(root.right);</span><br><span class="line">        root.right = deleteNode(root.right, midNode.val);</span><br><span class="line">        minNode.left = root.left;</span><br><span class="line">        minNode.right = root.right;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// BST 最左边的就是最⼩的</span></span><br><span class="line">	<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（3）二叉搜索树——3"><a href="#（3）二叉搜索树——3" class="headerlink" title="（3）二叉搜索树——3"></a>（3）二叉搜索树——3</h3><p><strong>（力扣96——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-77.png" alt="sf-1-77"></p>
<p><strong>思路</strong>：对于一个数字N，由于二叉搜索树的性质是进行中序遍历后是一个有序的数组，那么假设遍历后为一个大小为N的数组[1,2,3….,N]，对于中间的某个数字x，它所构成的树的形状应该是：（左边1<del>x-1个节点树的形状数）* （右边x+ 1</del>n个节点树的形状数），当左右两边的树的数量为0和1的时候，应该返回1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,下面这种方式时间复杂度非常高，为什么呢？假设我们已经计算出了数量为区间1~3的树的结构数量，我们不应该再计算类似于区间2~4，但是下面的算法会不断计算。所以我们应该将已经计算的存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++分割线+++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,那么我们加入一个memo去记录某个数量能形成的不同子树就行啦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> getNum(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res[end - start + <span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> res[end - start + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = getNum(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right  = getNum(i + <span class="number">1</span>, end);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        res[end - start + <span class="number">1</span>] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣95——不同的二叉搜索树）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-78.png" alt="sf-1-78"></p>
<p><strong>思路</strong>：此题总体上的思路和上一题类似，但是注意，这里要存储树的结构，我们需要在获得左子树和右子树的情况后，遍历所有的情况并接在根节点上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> getTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">getTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>); </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = getTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = getTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftNode : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightNode : right)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = leftNode;</span><br><span class="line">                    root.right = rightNode;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="3，图论"><a href="#3，图论" class="headerlink" title="3，图论"></a>3，图论</h2><blockquote>
<p>图论在实际笔试中考的不多，但它的经典算法⽐较多，⽐如什么最⼩⽣成树，最短路径，拓扑排序，⼆分图<br>判定之类的。<br>        所以本章围绕图论的经典算法展开，太难的图论算法我觉得咱是没多⼤必要掌握的。  </p>
</blockquote>
<h3 id="（1）图论基础"><a href="#（1）图论基础" class="headerlink" title="（1）图论基础"></a>（1）图论基础</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-79.png" alt="sf-1-79" style="zoom:50%;" />

<p><strong>(图的逻辑结构)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图结点的逻辑结构，存储值id，以及连接的节点存在neighbors中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（图的常用存储方式）</strong></p>
<p>在实际应用中，我们很少用上面的节点的方式来对图进行操作，我们更常用的是邻接表和邻接矩阵</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-80.png" alt="sf-1-80" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="comment">//graph[x]存储x的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="comment">//matrix[x][y]记录x是否有一条指向y的边</span></span><br><span class="line"><span class="keyword">boolean</span>[][] matrix;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">邻接表：</span><br><span class="line">    优势：占用空间少</span><br><span class="line">    劣势：⽆法快速判断两个节点是否相邻，需要遍历该节点连接的所有节点才能判断</span><br><span class="line">邻接矩阵：</span><br><span class="line">    优势：占用空间多</span><br><span class="line">    劣势：能快速判断，比如<span class="number">3</span>和<span class="number">1</span>是否相连，我们只需判断[<span class="number">3</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>(度的概念)</strong></p>
<p>在无向图中，一个节点的度就是该节点的相连的边的数量。</p>
<p>在有向图中，一个节点的度分为出度（该节点指向别的节点）和入度（别的节点指向该节点）。</p>
<p>在此基础上，还有权值的概念。</p>
<p><strong>（图的遍历）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root)&#123;</span><br><span class="line">        traverse(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图遍历框架,采用的是邻接表的遍历框架</span></span><br><span class="line"><span class="comment">//注意visited和onPath的功能是不一样的，visited用来防止重复遍历，onPath是在当前遍历是否在目前这个路径中</span></span><br><span class="line"><span class="keyword">boolean</span>[] visited;</span><br><span class="line"><span class="keyword">boolean</span>[] onPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graphTraverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//前序遍历位置，这里将s标记为已读，并将s加入路径中</span></span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : gragh.neighbors(s))&#123;</span><br><span class="line">        traverse(gragh, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历代码位置，退出路径</span></span><br><span class="line">    onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣797——所有可能的路径）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-81.png" alt="sf-1-81" style="zoom:80%;" />

<p><strong>思路</strong>：使用深度遍历该图时，如果当前的点为n-1，则要在结果中添加当前的path，然后递归遍历每个相邻节点，在递归后要移除加入的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS深度遍历解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        traverse(graph, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在路径中添加该节点值，添加到最后</span></span><br><span class="line">        path.addLast(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">if</span>(s == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果已经到了最后一个节点，那么此时path中已经存在一个从0到n-1的路径，复制并存储到res中去</span></span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[s])&#123;</span><br><span class="line">            traverse(graph, v, path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS广度搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//存结果</span></span><br><span class="line">        <span class="keyword">int</span> n=graph.length;</span><br><span class="line">        Queue&lt;List&lt;Integer&gt;&gt; myque=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();<span class="comment">//广度优先搜索队列</span></span><br><span class="line"></span><br><span class="line">        myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        myque.peek().add(<span class="number">0</span>);<span class="comment">//队列中的第一个路径添加起始节点</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp;<span class="comment">//在bfs过程中接收临时路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为是有向无环图所以不需要记录是否已经访问过当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(myque.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=myque.remove();<span class="comment">//取出队头元素</span></span><br><span class="line">            Integer temp_int=temp.get(temp.size()-<span class="number">1</span>);<span class="comment">//拿到当前路径的最后一站</span></span><br><span class="line">            <span class="keyword">if</span>(temp_int==n-<span class="number">1</span>)</span><br><span class="line">            &#123;<span class="comment">//是否到达指定终点，到达终点则将当前路径加入ret</span></span><br><span class="line">                ret.add(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Integer i:graph[temp_int])</span><br><span class="line">            &#123;<span class="comment">//从当前路径向后走，因为是有向无环图，所以不用担心重复访问，不用担心走不到终点。</span></span><br><span class="line">                temp.add(i);</span><br><span class="line">                myque.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));<span class="comment">//一定是深拷贝</span></span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//回溯一下</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：huann-jun</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/all-paths-from-source-to-target/solution/bfs10mssi-lu-qing-xi-xie-zhu-shi-de-du-s-hfdc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h3 id="（2）拓扑排序"><a href="#（2）拓扑排序" class="headerlink" title="（2）拓扑排序"></a>（2）拓扑排序</h3><p><strong>（力扣207——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-82.png" alt="sf-1-82"></p>
<p><strong>思路</strong>：首先我们要建立一个有向图，这里采用邻接表的方式，然后我们可以用深度优先算法来遍历，并想办法判断是否是成环的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,构建邻接表，我们注意返回的是数组，数组的索引对应了元素的值，数组中存储了一个list，表示元素指向的元素</span></span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//这里用有向图表示完成from才能进行to</span></span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//2，主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">		<span class="comment">//要遍历所有的课程，保证每个课程完成都没有环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !hasCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3，遍历函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这个onPath加深了我们对路径的理解，它之所以和isVisited不一样，是应为它表示了当前节点是不是在当前路径中，退出了这个路径就会设置为false，而isVisited只是表示当前节点遍历过没有，设置为true就变不回来</span></span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是满足任一条件就要退出来</span></span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣210——课程表）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-83.png" alt="sf-1-83"></p>
<p><strong>思路</strong>：</p>
<p>首先，这个题就是需要找出拓扑排序，拓扑排序的顺序就是本题的答案。拓扑排序构造方式是：1）从有向图中选择一个没有前驱（即入度为0）的顶点并且输出它；2）从图中删去该顶点，并且删去从该顶点发出的所有边；3）重复上述步骤1）和2），直到当前有向图中不存在没有前驱结点的顶点为止，或者当前有向图中的所有结点均已输出为止。</p>
<p>其次，拓扑排序的前提是没有环，有换无法形成拓扑结果，所以，我们应该先判断这个里面有没有环。</p>
<p>最后，本题如何得到拓扑排序？本题就是将后序遍历的结果进行反转（当然也可以不反转，但是我们这里构建图的时候，和题中的顺序是不一样的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt;[] creatGraph(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = <span class="keyword">new</span> LinkedList[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            gragh[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gragh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] onPath;</span><br><span class="line">    <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">    List&lt;Integer&gt; postOrder = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt;[] gragh = creatGraph(numCourses, prerequisites);</span><br><span class="line">        onPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            traverse(gragh, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasCycle)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(postOrder);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            res[i] = postOrder.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] gragh, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(onPath[s])&#123;</span><br><span class="line">            hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isVisited[s] || hasCycle) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        onPath[s] = <span class="keyword">true</span>;</span><br><span class="line">        isVisited[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : gragh[s])&#123;</span><br><span class="line">            traverse(gragh, t);</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder.add(s);</span><br><span class="line">        onPath[s] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（BFS算法解答）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS算法判断是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment">//BFS算法判断是否能输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1，建图，这里不再写这个函数</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = createGraph(numCourses,prerequisites);</span><br><span class="line">    <span class="comment">//某个节点的入度记录数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        indgree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用队列去存储入度为0的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="comment">//找到一个进入队列进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(indgree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q.offer(indgree[i]);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录拓扑排序结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="comment">//记录已经操作的入度为0的节点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//广度遍历的过程</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="comment">//对于队列中出队的元素，我们计数加一，表明遍历了这个节点</span></span><br><span class="line">        <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[cur])&#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count不等于numCourses，那应该就是有环导致节点被重复计算了。或者是根本遍历不了节点了</span></span><br><span class="line">   <span class="keyword">if</span>(count == numCourses)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）二分图判定"><a href="#（3）二分图判定" class="headerlink" title="（3）二分图判定"></a>（3）二分图判定</h3><p><strong>（二分图简介）</strong></p>
<p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且两个⼦集内的顶点不相邻。  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-84.png" alt="sf-1-84" style="zoom: 50%;" />

<p><strong>例子：</strong>其实就是一个图的双色问题，给你⼀幅「图」，请你⽤两种颜⾊将图中的所有顶点着⾊，且使得任意⼀条边的两个端点的颜⾊都不相同，你能做到吗？  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-85.png" alt="sf-1-85" style="zoom:50%;" />

<p><strong>框架：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//遍历节点v的所有相邻节点neighbor</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.neighbors(v))&#123;</span><br><span class="line">        <span class="comment">//这里把判断是否visited的逻辑放到了这里，和之前的框架有些许不同，但是我们只要保证没被访问过再进行访问就行</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[neighbor])&#123;</span><br><span class="line">            <span class="comment">//相邻节点neighbor没有被访问过</span></span><br><span class="line">            <span class="comment">//那么应该给节点neighbor和v涂上不同的颜色</span></span><br><span class="line">            traverse(graph, visited, neighbor);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果相邻节点neighbor已经被访问过了</span></span><br><span class="line">            <span class="comment">//那么应该比较neighbor和节点v的颜色</span></span><br><span class="line">            <span class="comment">//若相同，则不是二分图</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣785——判断二分图）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-86.png" alt="sf-1-86"></p>
<p><strong>思路</strong>：按照上面的思路就行，但是这里注意，题中说了这可能不是一个连通图，那么在13行那里，我们要判断当前节点是不是新的图的开头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一维数组paint，paint[0]= 0表示0还未着色，paint[0] = -1表示0黑，paint[0] = 1表示0白</span></span><br><span class="line">    <span class="comment">//初试化visited数组</span></span><br><span class="line">    <span class="keyword">int</span>[] paint;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        paint[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.length; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = <span class="number">1</span>;</span><br><span class="line">                canDivide(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">canDivide</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k : graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[k] != <span class="number">1</span>)&#123;</span><br><span class="line">                paint[k] = -paint[v];</span><br><span class="line">                canDivide(graph, k);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[k] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[k] == paint[v])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上面的canDivide方法，我们也可以采用BFS的方式来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Gragh[][] graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	visited[start] = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; !flag)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = q.poll();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v ; graph[k])&#123;</span><br><span class="line">        	<span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                paint[v] = -paint[k];</span><br><span class="line">                visited[v] == <span class="number">1</span>;</span><br><span class="line">                q.offer(v);</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag == <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣886——可能的二分法)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-87.png" alt="sf-1-87"></p>
<p><strong>思路</strong>：dislikes就是一个图的数组，但是这里还没有建好图，需要先自己建图，然后进行遍历和判断，如果可以的话，输出数组，否则输出false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt;[] graph;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] paint; </span><br><span class="line">    <span class="keyword">boolean</span>[] visited; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1注意，这里没有节点0，所以初始化和赋值都别加</span></span><br><span class="line">        graph = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dislike : dislikes)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = dislike[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = dislike[<span class="number">1</span>];</span><br><span class="line">            graph[from].add(to);</span><br><span class="line">            graph[to].add(from);</span><br><span class="line">        &#125;</span><br><span class="line">        paint = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//2不是联通图的情况还是要判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LinkedList&lt;Integer&gt;[] graph, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        visited[k] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[k])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                paint[v] = !paint[k];</span><br><span class="line">                traverse(graph, v);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(paint[v] == paint[k])&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）并查集算法详解"><a href="#（4）并查集算法详解" class="headerlink" title="（4）并查集算法详解"></a>（4）并查集算法详解</h3><p><strong>（认识Union-Find算法——并查集算法）</strong></p>
<p><strong>简介</strong>：所谓的Union-Find算法，目标是将节点进行连接，并且能判断当前的连通分量的情况，以及两个节点是否连通，API如下，可以看出，该算法需要提高union 和 connected 函数的效率。⽤什么模型来表示这幅图的连通状态呢？⽤什么数据结构来实现代码呢 ？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这里的连通有三个需要注意的点：1）自反性：节点p和q是连通的；2）对称性：如果p和q是连通的，q和p也是连通的；3）传递性：如果p和q连通，q和r连通，则p和r是连通的。</span></span><br><span class="line"><span class="comment">//对于一个图（1,2,3,4,5,6,7,8,9,10），调用union(1,2),则变为（1&lt;-&gt;2,3,4,5,6,7,8,9,10）,连通分量为9个</span></span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：我们使⽤森林（若⼲棵树）来表示图的动态连通性，⽤数组来具体实现这个森林。  具体见下面代码</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-88.png" alt="sf-1-88" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong>：find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的⾼度。我们可能习惯性地认为树的⾼度就是 logN，但这并不⼀定。logN 的⾼度只存在于平衡⼆叉树，对于⼀般的树可能出现极端不平衡的情况，使得「树」⼏乎退化成「链表」，树的⾼度最坏情况下可能变成 N。  </p>
<p>具体是在哪一步当中出现了树往坏的方向发展呢？答案是在Union当中，将p 所在的树接到 q 所在的树的根节点下⾯，那么这⾥就可能出现「头重脚轻」的不平衡状况，⽐如下⾯这种局⾯：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-89.png" alt="sf-1-89" style="zoom:67%;" />

<p>在之前的操作中，树可能⽣⻓得很不平衡。我们其实是希望，⼩⼀些的树接到⼤⼀些的树下⾯，这样就能避免头重脚轻，更平衡⼀些。解决⽅法是额外使⽤⼀个 size 数组，记录每棵树包含的节点数，也可以称之为树的「重量」  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//小树接到大树下面，会比较平衡一些</span></span><br><span class="line">    <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">    count--;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>路径压缩</strong>：我们能不能进⼀步压缩每棵树的⾼度，使树⾼始终保持为常数 ？可以，在find方法中顺便将路径进行压缩就可以了.调⽤ find 函数每次向树根遍历的同时，顺⼿将树⾼缩短了，最终所有树⾼都不会超过 3（union 的时候树⾼可能达到 3），树⾼为常数，那么所有⽅法的复杂度也就都是 O(1)。</p>
<p>如果树非常高，最终的树高不就超过3了吗？不是的，只要是正常建树，在建树的过程中就会不断压缩，不会超过3。用了路径压缩的方法，也就不用记录size了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">	<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">		parent[x] = parent[parent[x]]</span><br><span class="line">            x = parent[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最终的常用的UF类如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]]</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣323——无向连通图中连通分量的数目）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-90.png" alt="sf-1-90" style="zoom:80%;" />

<p><strong>思路</strong>：直接使用UF类即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">	UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">	<span class="comment">// 将每个节点进⾏连通</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">		uf.union(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回连通分量的个数</span></span><br><span class="line">	<span class="keyword">return</span> uf.count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣130——被围绕的区域)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-91.png" alt="sf-1-91"></p>
<p><strong>思路</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//1，对于一个二维节点，我们映射到x * n + y一维坐标(m为行,n为列)，m*n留着给dummy节点</span></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//2，这里使用了d这个方向数组，对(i,j)的上下左右进行了遍历和判断，如果也是O的话，则进行连接</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                            uf.connect(i * n + j, x * n + y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果说某个O是与dummy相连接的话，肯定不是被围起来的，反之就是，需要修改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!uf.connected(i * n + j, dummy))&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）</span></span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣990——等式方程的可满足性）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-92.png" alt="sf-1-92" style="zoom:80%;" />

<p><strong>思路</strong>：本题思路还是比较清晰的，对于两个是等式的字母，我们将其链接在一个树上，遇到不等式，我们判断他们在并查集中是不是有同一个根，如果是则返回false，遍历完后，返回true；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; letterToN = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            letterToN.put((<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                uf.connect(letterToN.get(c1),letterToN.get(c2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> c2 = s.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">char</span> equa = s.charAt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(equa == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uf.isConnected(letterToN.get(c1), letterToN.get(c2)))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootQ == rootP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = parent[parent[k]];</span><br><span class="line">            k = parent[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（5）Kruskal最小生成树算法"><a href="#（5）Kruskal最小生成树算法" class="headerlink" title="（5）Kruskal最小生成树算法"></a>（5）Kruskal最小生成树算法</h3><p><strong>（介绍）</strong>：最小生成树就是一个图中所有可能的⽣成树中，权重和最⼩的那棵⽣成树就叫「最⼩⽣成树」  PS：<u>⼀般来说，我们都是在⽆向加权图中计算最⼩⽣成树的，所以使⽤最⼩⽣成树算法的现实场景中，图的边权重⼀般代表成本、距离这样的标量。</u>  </p>
<p><strong>（加入size的并查集算法）</strong></p>
<p>为了保证在生成最小生成树的过程中没有生成环，我们需要UF算法的协助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法引入：力扣261——以图判树）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-93.png" alt="sf-1-93" style="zoom:67%;" />

<p><strong>思路</strong>：本题的判断逻辑只有一个，对于一个边的两个顶点，如果它俩在一个连通分量里面，就表明有环了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化有n个节点</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="comment">//遍历每一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//如果这条边的两条节点已经在同一个连通分量中，这条边就会导致产生环</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnect(u,v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这条边不会产生环，可能是树的一部分，也可能是一个单独的连通分量</span></span><br><span class="line">        uf.connect(u,v); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有最后连通分量为1，才表明生成了一棵树</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//same as before   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（Kruskal算法实现）</strong></p>
<p>一个图的最小生成树，必须满足：1）包含图中的所有节点；2）形成的结构是树结构；3）权重和最小</p>
<p>如何保证这个树的权重是最小的呢？我们需要用到贪心思路：<em>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和<code>mst</code>中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入<code>mst</code>集合；否则，这条边不是最小生成树的一部分，不要把它加入<code>mst</code>集合</em></p>
<p>具体实现看两道题：</p>
<p><strong>（力扣1135——最低成本连通所有城市）</strong></p>
 <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-94.png" alt="sf-1-94" style="zoom:67%;" />

<p><strong>思路</strong>：类似于上一道题，只是这里需要先将路径值进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mininumCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span></span>&#123;</span><br><span class="line">    <span class="comment">//nodes range form 1 ~ n,so we need put n+1 in UF&#x27;s constructor</span></span><br><span class="line">    Uf uf = <span class="keyword">new</span> UF(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对connections数组进行升序排序</span></span><br><span class="line">    Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">//用mst进行路径值的记录</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : connections)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//添加了这条边就会出现环，所以跳过操作</span></span><br><span class="line">        <span class="keyword">if</span>(uf.isConnected(u, v))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.connect(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里用2是因为0这个连通分量一定是单独的。</span></span><br><span class="line">    <span class="keyword">return</span> uf.count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="comment">//same as before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣1584——连接所有点的最小费用）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-95.png" alt="sf-1-95" style="zoom:80%;" />

<p><strong>思路</strong>：这里需要注意，点与点的关系要转换出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points.length;</span><br><span class="line">    <span class="comment">// 生成所有边及权重</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xi = points[i][<span class="number">0</span>], yi = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> xj = points[j][<span class="number">0</span>], yj = points[j][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 用坐标点在 points 中的索引表示坐标点</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    Collections.sort(edges, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行 Kruskal 算法</span></span><br><span class="line">    <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (uf.connected(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将p和q进行连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//将树rootP接在rootQ下面（当然反过来也可以）,注意小的接在大的上面</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootP] &gt; size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连通分量的数量-1；</span></span><br><span class="line">        count--;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断p和q是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回图中的连通分量的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回某个节点 x 的根节点 </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x)&#123;</span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">             x = parent[x];            </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（算法复杂度）</strong>：</p>
<p>最后说下 Kruskal 算法的复杂度分析：</p>
<p>假设一幅图的节点个数为<code>V</code>，边的条数为<code>E</code>，首先需要<code>O(E)</code>的空间装所有边，而且 Union-Find 算法也需要<code>O(V)</code>的空间，所以 Kruskal 算法总的空间复杂度就是<code>O(V + E)</code>。</p>
<p>时间复杂度主要耗费在排序，需要<code>O(ElogE)</code>的时间，Union-Find 算法所有操作的复杂度都是<code>O(1)</code>，套一个 for 循环也不过是<code>O(E)</code>，所以总的时间复杂度为<code>O(ElogE)</code>。</p>
<h3 id="（6）Dijistra算法"><a href="#（6）Dijistra算法" class="headerlink" title="（6）Dijistra算法"></a>（6）Dijistra算法</h3><p><strong>（所需API）</strong></p>
<p>一般情况下，我们使用邻接表来实现算法，接着对于图的问题，我们需要能一个能够找到相邻节点的API，最后我们还需要一个能够获取两个节点之间权重的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,使用邻接表存储图</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,获取某个节点的相邻节点</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> graph[s];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3,获取权重，具体的方式应该根据题意来获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>（图的BFS算法）</strong></p>
<p>从二叉树，到多叉树，到图的BFS算法大体上是一样的 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，二叉树BFS遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,多叉树的遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty)&#123;  </span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将下一层的节点按照从左到右的顺序放入到队列中</span></span><br><span class="line">			<span class="keyword">for</span>(TreeNode child : children)&#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">		depth++; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,图的BFS（广度优先搜索）框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用q来存储遍历的对象，用visited来判断是否遍历了</span></span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="comment">//记录搜索的步数（在无权图中，就是1，在有权图中，则为边的权值）</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">    	<span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">//和之前类似，但是要记录是否被遍历过了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;节点在第&quot;</span> + depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">		   <span class="keyword">for</span>(Node x : cur.adj)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!visited.contains(x))&#123;</span><br><span class="line">                   q.offer(x);</span><br><span class="line">                   visited.add(x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在上面的代码中，我们发现这些都是对无权图的遍历操作，无权图意味着每条路径的权值都可以是1，那么start到cur的最短路径就是step的数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到了有权图，最短路径可不是这简单了，在有权图中，start节点到cur的最短路径并是不是简单的step的值，而是要考虑权值。我们的目标是基于上面的算法，计算加权图中的最短路径。此时step步数并不是一个有意义的值了，路径的权重和才有意义，那么for循环中的遍历，我们便不再需要，可以去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//怎么去掉呢？这里先以二叉树为例，去掉for循环，但是还想知道depth的值，我们可以新建一个结构体，其中保存depth的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> State(root, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        State cur = q.poll();</span><br><span class="line">        TreeNode cur_node = cur.node;</span><br><span class="line">        <span class="keyword">int</span> cur_depth = cur.depth;</span><br><span class="line">        System.out.print(cur_node.val + <span class="string">&quot;节点在第&quot;</span> + cur_depth + <span class="string">&quot;层&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur_node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> State(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>(Sijkstra算法框架)</strong></p>
<p>迪杰斯特拉算法对于一个输入的图和起点start，能够返回start到其他所有节点的最短距离。根据 BFS 的逻辑和⽆权图的特点，第⼀次遇到某个节点所⾛的步数就是最短距离，所以⽤⼀个 visited 数组防⽌⾛回头路，每个节点只会经过⼀次。<br>        加权图中的 Dijkstra 算法和⽆权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第⼀次经过某个节点时的路径权重，不⻅得就是最⼩的，所以对于同⼀个节点，我们可能会经过多次，⽽且每次的 distFromStart可能都不⼀样，⽐如下图：  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-96.png" alt="sf-1-96" style="zoom:67%;" />

<p>下面是该算法的伪代码框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，记录节点数据的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="comment">//用来记录节点的id</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//从Start节点到当前节点的距离</span></span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2，获取两个节点权重的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>;</span><br><span class="line"><span class="comment">//3，获取某个节点相邻节点的方法</span></span><br><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> start, List&lt;Integer&gt;[] graph)&#123;</span><br><span class="line">    <span class="comment">//图中节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> V = graph.length;</span><br><span class="line">    <span class="comment">//起点到每个节点的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="comment">//先把distTo数组全部赋上最大值</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">//其实节点到自己的距离是1</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//4，用优先级队列来存移入的节点，其实用普通队列也可以，只是这里能保证取出来的节点就是当前最小的那个路径</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列初试化</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> State(start, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//5，担心这个while循环无法结束？放入节点的条件很苛刻啦，队列中没有元素的时候，就是值已经赋完的时候</span></span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        State curState = pd.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">        <span class="keyword">int</span> curDistFromStart = curState.distFromStart;</span><br><span class="line">        <span class="comment">//注：要求开始节点到某一个节点的最小值，则只需要在函数参数中加一个end，然后加入下面的判断语句就行</span></span><br><span class="line">        <span class="comment">//if(curNodeId == end)&#123;</span></span><br><span class="line">        <span class="comment">//	return curDistFromStart;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(curDistFromeStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于相邻节点，更新开始节点到自己的最小值，并把自己放进队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nextNodeId : adj(curNodeId))&#123;</span><br><span class="line">            <span class="keyword">int</span> distToNextNode = distTo[curNodeId] + weight(curNodeId, nextNodeId);</span><br><span class="line">            <span class="keyword">if</span>(distTo[nextNodeId] &gt; distToNextNode)&#123;</span><br><span class="line">                distTo[nextNodeId] = distToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> State(nextNodeId, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该算法的时间复杂度是O(Elogv),E是边数，V是节点个数</span></span><br></pre></td></tr></table></figure>

<p><strong>（力扣743——网络延迟时间）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-97.png" alt="sf-1-97" style="zoom: 67%;" />

<p><strong>思路</strong>：如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1，节点是从1开始的，所以我们构建的图也从1开始</span></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt;[] gragh = <span class="keyword">new</span> LinkedList[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            gragh[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : times)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">            gragh[from].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;to, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,开始使用迪杰斯特拉算法进行最短路径计算</span></span><br><span class="line">        <span class="keyword">int</span>[] distTo = Dijkstra(k, gragh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distTo.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distTo[i] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="comment">//3,有节点连接不上，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, distTo[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] Dijkstra(<span class="keyword">int</span> start, List&lt;<span class="keyword">int</span>[]&gt;[] gragh)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = gragh.length;</span><br><span class="line">        <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">        Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">        distTo[start] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State cur = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = cur.id;</span><br><span class="line">            <span class="keyword">int</span> curDistFromStart = cur.distFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curDistFromStart &gt; distTo[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : gragh[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> disToNextNode = distTo[curNodeId] + neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( distTo[nextNodeId] &gt; disToNextNode)&#123;</span><br><span class="line">                    distTo[nextNodeId] = disToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, disToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distTo;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> distFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1631——最小体力消耗路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-98.png" alt="sf-1-98"></p>
<p><strong>思路</strong>：具体都是套框架，但是这里有一点比较重要，在44~49行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; adj(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; neighbor = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span> &amp;&amp; k &lt; m &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; n)&#123;</span><br><span class="line">                neighbor.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;k, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neighbor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] effortTo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m; i++)&#123;</span><br><span class="line">            Arrays.fill(effortTo[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effortTo[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a.effortFromStart - b.effortFromStart;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curNode = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curx = curNode.x;</span><br><span class="line">            <span class="keyword">int</span> cury = curNode.y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curx == m - <span class="number">1</span> &amp;&amp; cury == n - <span class="number">1</span>) <span class="keyword">return</span> curNode.effortFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNode.effortFromStart &gt; effortTo[curx][cury])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : adj(curx, cury, heights))&#123;</span><br><span class="line">                <span class="keyword">int</span> nextx = neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> nexty = neighbor[<span class="number">1</span>];</span><br><span class="line">			   <span class="comment">//下一个node的effort，应该是当前遇到的最大值，才能反映出来这条路径的消耗</span></span><br><span class="line">                <span class="keyword">int</span> effortToNextNode = Math.max(effortTo[curx][cury], Math.abs(heights[curx][cury] - heights[nextx][nexty]));</span><br><span class="line">                <span class="comment">//但是要添加到efforTo数组中的话，就需要这条路径的最大值都比目前就记录的小，才能添加</span></span><br><span class="line">                <span class="keyword">if</span>(effortToNextNode &lt; effortTo[nextx][nexty])&#123;</span><br><span class="line">                    effortTo[nextx][nexty] = effortToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextx, nexty, effortToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> x, y;</span><br><span class="line">     <span class="keyword">int</span> effortFromStart;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> effortFromStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.effortFromStart = effortFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1514——概率最大的路径）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-99.png" alt="sf-1-99"></p>
<p><strong>思路</strong>：本题与之前的题明显有两个不同点：1）图是无向图；2）这里需要计算的不是最短路径，而是最大值。我们解决的办法也是两个点：1）无向图就是双向图，在建图的时候要添加边；2）dijkstra算法计算的是最优值，那么最大值也是可以的，只是需要进行一点小的变化。</p>
<p>最后说一下，标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？因为 Dijkstra 计算最短路径的正确性依赖⼀个前提：路径中每增加⼀条边，路径的总权重就会增加（或减少）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">double</span>[] succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">double</span>[]&gt;[] graph = <span class="keyword">new</span> LinkedList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> weight = succProb[i];</span><br><span class="line">            <span class="comment">//1,建图的时候，注意统一为double，并且这里是无向图，按照双向图来建图</span></span><br><span class="line">            graph[from].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) to, weight&#125;);</span><br><span class="line">            graph[to].add(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;(<span class="keyword">double</span>) from, weight&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dijkstra(start, end, graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;<span class="keyword">double</span>[]&gt;[] graph)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] probTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.length];</span><br><span class="line">        Arrays.fill(probTo, - <span class="number">1</span>);</span><br><span class="line">        probTo[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2,此处我们调整为probFromStart值较大的在前面</span></span><br><span class="line">        Queue&lt;State&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(b.probFromStart, a.probFromStart);</span><br><span class="line">        &#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> State(start, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            State curState = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> curNodeId = curState.id;</span><br><span class="line">            <span class="keyword">double</span> curProbFromStart = curState.probFromStart;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curNodeId == end) <span class="keyword">return</span> curProbFromStart;</span><br><span class="line">            <span class="keyword">if</span>(curProbFromStart &lt; probTo[curNodeId]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">double</span>[] neighbor : graph[curNodeId])&#123;</span><br><span class="line">                <span class="keyword">int</span> nextNodeId = (<span class="keyword">int</span>)neighbor[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">double</span> probToNextNode = probTo[curNodeId] * neighbor[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(probTo[nextNodeId] &lt; probToNextNode)&#123;</span><br><span class="line">                    probTo[nextNodeId] = probToNextNode;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> State(nextNodeId, probToNextNode));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">double</span> probFromStart;</span><br><span class="line">    State(<span class="keyword">int</span> id, <span class="keyword">double</span> probFromStart)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.probFromStart = probFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）名流问题"><a href="#（7）名流问题" class="headerlink" title="（7）名流问题"></a>（7）名流问题</h3><p><strong>（引入）</strong>：</p>
<p>名流问题，指的是给你n个人的社交关系（你知道两个人之间是否认识），尝试寻找其中的名人，名人必须满足条件：1）所有其他人都认识名人；2）名人不认识其他任何人。</p>
<p>该问题其实就是一个图结构的问题，抽象为图我们可以这么理解，对于一个有向图(有n个节点)，若a-&gt;b，则表明a认识b（如果是邻接矩阵就是，若graph[i][j] &#x3D; 1，则表明第i个人认识第j个人），那么一个节点如果是名人，则该节点没有出度，且入度为n-1。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-1-100.png" alt="sf-1-100" style="zoom:80%;" />

<p><strong>（力扣227——搜寻名人）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-1.png" alt="sf-2-1" style="zoom:80%;" />

<p><strong>思路</strong>：本题由浅入深，可以探讨3种不同的思路，对于逻辑很有帮助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，暴利解决（由于knows底层是访问邻接矩阵，所以该算法时间复杂度高达O(n^2)）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cand = <span class="number">0</span>; cand &lt; n; cand++)&#123;</span><br><span class="line">        <span class="keyword">int</span> other;</span><br><span class="line">        <span class="keyword">for</span>(other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cand == other) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果名人候选人cand认识其他人，或者其他人不认识名人，那么该cand无法继续下去</span></span><br><span class="line">            <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(other == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> cand;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,优化，由于名人不认识其他人，其他人都认识名人，那么就决定了n中至多只有一个名人。</span></span><br><span class="line"><span class="comment">//那么对于两个候选人，我一定能排除一个不是名人的人选项，因为两个人的关系只有四种</span></span><br><span class="line"><span class="comment">//（1），cand认识other，cand肯定不是名人，排除cand</span></span><br><span class="line"><span class="comment">//（2），other认识cand，other肯定不是名人，排除other</span></span><br><span class="line"><span class="comment">//（3），两人互相认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"><span class="comment">//（4），两人互相不认识，肯定都不是名人，可以随便排除一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度为O(n),但空间复杂度变为了O(n).PS：LinkedList 的作⽤只是充当⼀个容器把候选⼈装起来，每次找出两个进⾏⽐较和淘汰，但⾄于具体找出哪两个，都是⽆所谓的，也就是说候选⼈归队的顺序⽆所谓，我们⽤的是 addFirst 只是⽅便后续的优化，你完全可以⽤ addLast，结果都是⼀样的。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//放入候选队列中</span></span><br><span class="line">    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        q.addLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">int</span> other = q.removeFirst();</span><br><span class="line">        <span class="keyword">if</span>(knows(cand, other) || !knows(other, cand))&#123;</span><br><span class="line">            <span class="comment">//cand肯定不是候选人，other还有可能</span></span><br><span class="line">            q.addFirst(other);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other肯定不是候选人，cand还有可能</span></span><br><span class="line">            q.addFirst(cand);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//只剩一个了，看它是不是名副其实</span></span><br><span class="line">        <span class="keyword">int</span> cand = q.removeFirst();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3,其实不需要额外的空间，解法时间复杂度为 O(N)，空间复杂度为 O(1)。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设cand为0</span></span><br><span class="line">    <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">1</span>; other &lt; n; other++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!knows(other, cand) || knows(cand, other))&#123;</span><br><span class="line">            <span class="comment">//other有可能是候选者</span></span><br><span class="line">            cand = other;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//other不会是名人，直接进入下一次循环</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在确认一下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == cand)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!knows(other, cand || knows(cand, ohter))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五，暴力搜索算法"><a href="#五，暴力搜索算法" class="headerlink" title="五，暴力搜索算法"></a>五，暴力搜索算法</h1><h2 id="1，DFS算法-x2F-回溯算法"><a href="#1，DFS算法-x2F-回溯算法" class="headerlink" title="1，DFS算法&#x2F;回溯算法"></a>1，DFS算法&#x2F;回溯算法</h2><p>回溯算法总体框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">	<span class="keyword">if</span> 满⾜结束条件:</span><br><span class="line">		result.add(路径)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">		做选择</span><br><span class="line">		backtrack(路径, 选择列表)</span><br><span class="line">		撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="（1）回溯算法框架"><a href="#（1）回溯算法框架" class="headerlink" title="（1）回溯算法框架"></a>（1）回溯算法框架</h3><p><strong>（引入）</strong>：</p>
<p>解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。你只需要思考3 个问题：<br>            1、路径：也就是已经做出的选择。<br>            2、选择列表：也就是你当前可以做的选择。<br>            3、结束条件：也就是到达决策树底层，⽆法再做选择的条件。  </p>
<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-2.png" alt="sf-2-2" style="zoom:80%;" />

<p><strong>思路</strong>：对于这样一个全排列问题，我们可以得到下面这样一棵树，也就是在遍历的过程中，我们需要在某个节点进行路径和选择列表的更新操作，比如下图的最右边的蓝色节点，我们的路径中添加了[3]，选择列表值变为[1,2]。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-3.png" alt="sf-2-3" style="zoom:67%;" />

<p>之前算法框架中的backtrack()函数就像是一个指针，指向某个节点，在这个节点之前和之后要进行相关操作，正如树的前序和后序遍历一样。所以回溯算法的核心就是，在进入backtrack()函数之前做出正确的操作，进入之后进行操作</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-4.png" alt="sf-2-4" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，在选择列表里面做选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//4，做出选择</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            backtrack(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5，撤销选择</span></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣51——N皇后）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-5.png" alt="sf-2-5" style="zoom: 80%;" />

<p><strong>思路</strong>：皇后所在的位置，要保证上下左右线，对角线没有其他的皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c : board)&#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BackTrace(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BackTrace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res.add(charToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            BackTrace(board, row + <span class="number">1</span>);</span><br><span class="line">            board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">charToList</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] c : board) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）集合划分问题"><a href="#（2）集合划分问题" class="headerlink" title="（2）集合划分问题"></a>（2）集合划分问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-7.png" alt="sf-2-7" style="zoom:80%;" />

<p><strong>思路</strong>：本题很符合回溯的思想，需要多种结果，我们也需要进行暴利的遍历尝试来找到答案。但是使用回溯算法的每一道题都有自己的特点，比如这道题，我们在套用框架的过程中，也需要先找到规律。</p>
<p>题中是一个经典的排列组合问题，对于排列组合都可以抽象为球盒模型，本题中我们可以有两种视角：1）对于nums[]中的数字以及最终要放进k个桶，每个数字需要去选择自己应该进哪个桶，最终把每个桶都装满；2）确定要用k个桶去装nums[]数组的数字，由桶来选择要的数字；下面看看代码，注意带数字的注释，带星号的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,以数字视角</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v :nums) sum += v;</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优化，将大的数字放到前面去，这样更容易进入*所标记的剪枝语句中去</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>; i &lt; j; i++,j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//K个桶（集合），记录每个桶装的数字之和</span></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="comment">//理论上每个桶（集合）中的数字和</span></span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        <span class="comment">//穷举，看nums是否能分为k个和为target的数组</span></span><br><span class="line">        <span class="keyword">return</span> backtrace(nums, <span class="number">0</span>, bucket, target);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归穷举nums中的每个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span>[] bucket, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="comment">//1，如果index==nums的长度，表明每个数字似乎都找到了去处，要检查一下是不是合理的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucket[i] != target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于nums[index]，我们要看看他能装进哪个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++)&#123;</span><br><span class="line">            <span class="comment">//*放不进去这个桶</span></span><br><span class="line">            <span class="keyword">if</span>(bucket[i] + nums[index] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//放进i这个桶去试一下</span></span><br><span class="line">            bucket[i] += nums[index];</span><br><span class="line">            <span class="comment">//如果说已经满足所有条件了，返回</span></span><br><span class="line">            <span class="keyword">if</span>(backtrace(nums, index + <span class="number">1</span>, bucket, target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="comment">//放进i去是不行的，回溯</span></span><br><span class="line">            bucket[i] -= nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,以桶的视角，k桶在测试nums[start]这个数字是否装进去，k桶目前的装的容量为bucket，如果装了used就要标记，target是每个桶应该装的大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 排除⼀些基本情况</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : nums) sum += v;</span><br><span class="line">	<span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//使用位图技巧来记录使用过得数字</span></span><br><span class="line">	<span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> target = sum / k;</span><br><span class="line">	<span class="comment">// k 号桶初始什么都没装，从 nums[0] 开始做选择</span></span><br><span class="line">	<span class="keyword">return</span> backtrake(k, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1，创建一个备忘录，对于桶中添加数据的组合是有记录的，其实就是used中的数据的出现情况，当某个情况不满足后，新的情况桶选择数字的情况很可能和之前一样。比如[1,1,1,1,0,0]失败和[1,1,1,1,0,0]失败，可能这四个1添加的时机不同，但他们都会失败。</span></span><br><span class="line">HashMap&lt;Integer, Boolean&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">backtrake</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bucket, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> used, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在这个used非常长，就需要使用String来转换处理</span></span><br><span class="line">    <span class="comment">//String state = Arrays.toString(used);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bucket == target)&#123;</span><br><span class="line">        <span class="comment">//装满了当前桶，递归穷举下一个桶的选择，从nums[0]开始</span></span><br><span class="line">        <span class="keyword">boolean</span> res = backtrake(k - <span class="number">1</span>, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">        <span class="comment">//缓存目前的结果</span></span><br><span class="line">        memo.put(used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(used))&#123;</span><br><span class="line">        <span class="comment">//避免重复计算</span></span><br><span class="line">        <span class="keyword">return</span> memo.get(used);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i位是不是1，是的话表明nums[i]已经装到了别的桶里面去了，就不要判断这数字了</span></span><br><span class="line">        <span class="keyword">if</span>(((used &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] + bucket &gt; target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择当前的数字，并记录</span></span><br><span class="line">        used |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket += nums[i];</span><br><span class="line">        <span class="comment">//递归穷举下一个数字是不是可以被加入</span></span><br><span class="line">        <span class="keyword">if</span>(backtrake(k, bucket, nums, i + <span class="number">1</span>, used, target))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        used ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        bucket -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）排列-x2F-组合-x2F-子集问题"><a href="#（3）排列-x2F-组合-x2F-子集问题" class="headerlink" title="（3）排列&#x2F;组合&#x2F;子集问题"></a>（3）排列&#x2F;组合&#x2F;子集问题</h3><p><strong>（引入）</strong></p>
<p>这个部分主要有三种基本形式：</p>
<p>形式⼀、元素⽆重不可复选，即 nums 中的元素都是唯⼀的，每个元素最多只能被使⽤⼀次，这也是最基本<br>的形式。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该只有 [7]。<br>        形式⼆、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使⽤⼀次。以组合为例，如果输⼊ nums &#x3D; [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。<br>        形式三、元素⽆重可复选，即 nums 中的元素都是唯⼀的，每个元素可以被使⽤若⼲次。以组合为例，如果输⼊ nums &#x3D; [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]  <strong>（元素可重复可复选，其实就是元素去重的可复选）</strong></p>
<p>上⾯⽤组合问题举的例⼦，但排列、组合、⼦集问题都可以有这三种基本形式，所以共有 9 种变化。除此之外，题⽬也可以再添加各种限制条件，⽐如让你求和为 target 且元素个数为 k 的组合，那这么⼀来⼜可以衍⽣出⼀堆变体，怪不得⾯试笔试中经常考到排列组合这种基本题型。  </p>
<p>但⽆论形式怎么变化，其本质就是穷举所有解，⽽这些解呈现树形结构，所以合理使⽤回溯算法框架，稍改代码框架即可把这些问题⼀⽹打尽  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-9.png" alt="sf-2-9" style="zoom:67%;" />

<p><strong>（力扣78——子集）元素无重复不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-8.png" alt="sf-2-8" style="zoom: 80%;" />

<p>​    <strong>思路</strong>：对于这道题，我们采用树的形式来表示的话，可以得到下面这样的树结构</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-10.png" alt="sf-2-10" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		traceback(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="comment">//由于start会与nums.length比较，所以这里不用再添加额外的return条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(res));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;  nums.length; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line">            </span><br><span class="line">            traceback(nunms, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣77——组合）元素无重不可复选</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-11.png" alt="sf-2-11" style="zoom: 80%;" />

<p><strong>思路</strong>：与上一题类似，不过这里我们发现，res只需要添加trace的大小为k的时候的情况</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-12.png" alt="sf-2-12" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        traceback(n,<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(trace.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++)&#123;</span><br><span class="line">            trace.addLast(i);</span><br><span class="line"></span><br><span class="line">            traceback(n, i + <span class="number">1</span>, k);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣46——全排列）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-13.png" alt="sf-2-13" style="zoom:80%;" />

<p><strong>思路</strong>：这里的选择列表不像上一题，所以这里的选择是考used来做出的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//1，用来存储路径</span></span><br><span class="line">        LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//2，用来判断是否能加入路径</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, trace, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; trace, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(trace.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">            trace.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            backtrace(nums, trace, used);</span><br><span class="line">            </span><br><span class="line">            trace.removeLast();</span><br><span class="line">            used[i] = <span class="keyword">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣90——子集2)元素可重不可复选</strong>  </p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-14.png" alt="sf-2-14" style="zoom:80%;" />

<p><strong>思路</strong>：这道题的剪枝策略，就是避免进入到同一层中的相同元素</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-15.png" alt="sf-2-15" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrace(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(nums[i]);</span><br><span class="line">            backtrace(nums, i + <span class="number">1</span>);</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(力扣40——组合总和)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-16.png" alt="sf-2-16"></p>
<p><strong>思路</strong>：本题和上一题类似，都有重复元素，但是这里需要计算一下总和值与target的关系，并且多了一个剪枝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrace(candidates, target, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start,<span class="keyword">int</span> tracksum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracksum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tracksum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.add(candidates[i]);</span><br><span class="line">            tracksum += candidates[i];</span><br><span class="line">            backtrace(candidates, target, i + <span class="number">1</span>,tracksum);</span><br><span class="line">            tracksum -= candidates[i];</span><br><span class="line">            trace.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣39——组合总和）元素无重复可复选</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-17.png" alt="sf-2-17"></p>
<p><strong>思路</strong>：这道题不是找组合，而是找子集，并且这道题可以复选，那么我们在进行下一个元素选择的时候，范围就不能增加了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; trace = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        trackback(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackback</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> tracesum,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tracesum == target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(trace));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tracesum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tracesum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trace.addLast(candidates[i]);</span><br><span class="line">            tracesum += candidates[i];</span><br><span class="line">            <span class="comment">//这里我们不能输入i+1，而是输入i</span></span><br><span class="line">            trackback(candidates, target, tracesum,i);</span><br><span class="line"></span><br><span class="line">            trace.removeLast();</span><br><span class="line">            tracesum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元素无重复可复选的排列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-18.png" alt="sf-2-18"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteRepeat(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	backtrack(nums);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回溯算法核⼼函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// base case，到达叶⼦节点</span></span><br><span class="line">	<span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">		<span class="comment">// 收集叶⼦节点上的值</span></span><br><span class="line">		res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 回溯算法标准框架</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 做选择</span></span><br><span class="line">		track.add(nums[i]);</span><br><span class="line">		<span class="comment">// 进⼊下⼀层回溯树</span></span><br><span class="line">		backtrack(nums);</span><br><span class="line">		<span class="comment">// 取消选择</span></span><br><span class="line">		track.removeLast();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）岛屿问题"><a href="#（4）岛屿问题" class="headerlink" title="（4）岛屿问题"></a>（4）岛屿问题</h3><p>岛屿系列题⽬的核⼼考点就是⽤ DFS&#x2F;BFS 算法遍历⼆维数组。这里主要讲使用DFS解决岛屿问题。岛屿问题一般是用二维矩阵来解决，矩阵中的每个位置可以看做一个节点，其上下左右位置就是相邻节点，整个矩阵就可以以此抽象为图结构</p>
<p>岛屿问题的框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.rigth);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//二维矩阵遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="comment">//超出索引啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visited[i][j])&#123;</span><br><span class="line">        <span class="comment">//已经遍历过啦</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入节点i，j（这里也可以使用方向数组的技巧，都一样）</span></span><br><span class="line">    visited[i][j];</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, visited);<span class="comment">//上</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, visited);<span class="comment">//下</span></span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, visited);<span class="comment">//左</span></span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, visited);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣200——岛屿数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-19.png" alt="sf-2-19" style="zoom:80%;" />

<p><strong>思路</strong>：我们遍历这个grid，如果发现了陆地，那么计数器加一，并且使用DFS算法把这块地以及相邻的陆地都变成海水</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    DFS(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用DFS将传进来的索引的相连接的陆地，都变成海水</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        DFS(grid, i - <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i + <span class="number">1</span>,j);</span><br><span class="line">        DFS(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        DFS(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1254——统计封闭岛屿的数目）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-20.png" alt="sf-2-20"></p>
<p><strong>思路</strong>：如果一个岛屿靠边，那肯定是不封闭岛屿，所以可以用DFS将靠边的岛屿先淹了。那剩下的部分，和上题是一样的吗？当然是，因为靠边的部分已经变成了海水，那中间只要有陆地，如果上下左右没有相连，那至少是一个陆地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计边淹不靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">1</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1020——飞地的数量）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-21.png" alt="sf-2-21" style="zoom:80%;" />

<p><strong>思路</strong>：和上一题类似，只是统计res的时候不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//1,先把靠边的岛屿给淹了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            dfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2，然后边统计靠边的岛屿</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣695——岛屿的最大面积）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-22.png" alt="sf-2-22" style="zoom:80%;" />

<p><strong>思路</strong>：还是遇到岛屿要淹没，但是要记录此次淹没的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.max(res, dfs(grid, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dfs(grid, i + <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j) + </span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>) + </span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣1905——统计子岛屿）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-23.png" alt="sf-2-23"></p>
<p><strong>思路</strong>：如果grid2中的陆地，对应了grid1中的海洋，那grid2中该陆地所在的岛屿肯定都不是子岛。grid2中剩下的岛屿，必然是对应了grid1中的陆地（也就是grid1中的岛屿）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="keyword">int</span>[][] grid1, <span class="keyword">int</span>[][] grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid1.length, n = grid1[<span class="number">0</span>].length;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid1[i][j] == <span class="number">0</span> &amp;&amp; grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dfs(grid2, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣694——不同岛屿的数量)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-24.png" alt="sf-2-24" style="zoom:67%;" />

<p><strong>思路</strong>：为了判别形状，需要将形状转换成一个序列，然后判断序列的相似性。对于同一个起点进行的遍历，我们最后这个能得到的遍历顺序肯定是相同的，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-25.png" alt="sf-2-25" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="comment">// 记录所有岛屿的序列化结果</span></span><br><span class="line">	HashSet&lt;String&gt; islands = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 淹掉这个岛屿，同时存储岛屿的序列化结果</span></span><br><span class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">			<span class="comment">// 初始的⽅向可以随便写，不影响正确性</span></span><br><span class="line">			dfs(grid, i, j, sb, <span class="number">666</span>);</span><br><span class="line">			islands.add(sb.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不相同的岛屿数量</span></span><br><span class="line">	<span class="keyword">return</span> islands.size();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, StringBuilder sb, <span class="keyword">int</span> dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    sb.append(dir).apped(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j, sb, <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j, sb, <span class="number">2</span>);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>, sb, <span class="number">3</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>, sb, <span class="number">4</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="2，BFS算法"><a href="#2，BFS算法" class="headerlink" title="2，BFS算法"></a>2，BFS算法</h2><p>BFS 算法使用队列来实现，常⻅于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达⽬标时的代价是最⼩的。  </p>
<h3 id="（1）BFS算法框架"><a href="#（1）BFS算法框架" class="headerlink" title="（1）BFS算法框架"></a>（1）BFS算法框架</h3><p><strong>（两个点之间的最近距离——框架引入）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node Start, Node end)</span></span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    </span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//这里存储了一层的node</span></span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            <span class="keyword">for</span>(Node node : cur.adj())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node not in cur)&#123;</span><br><span class="line">                    q.offer(node);</span><br><span class="line">                    visited.add(node);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一层为一个step</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。以处理⼆叉树问题的例⼦（下一题），假设给你的这个⼆叉树是满⼆叉树，节点数为 N，对于 DFS 算法来说，空间复杂度⽆⾮就是递归堆栈，最坏情况下顶多就是树的⾼度，也就是 O(logN)。但是你想想 BFS 算法，队列中每次都会储存着⼆叉树⼀层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，⽤ Big O 表示的话也就是 O(N)。由此观之，BFS 还是有代价的，⼀般来说在找最短路径的时候使⽤ BFS，其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（力扣111——二叉树的最小深度）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-26.png" alt="sf-2-26" style="zoom:67%;" />

<p><strong>思路</strong>：套用上面的模板，在某一层的节点中，如果发现某个节点是叶节点，则返回step即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣752——打开轮盘锁）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-27.png" alt="sf-2-27"></p>
<p><strong>思路</strong>：这个题分的思路分为三个阶段：1）使用图的思想进行穷举所有密码；2）在穷举所有密码的基础上，对当前情况进行判断；3）双向BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1,如何用BFS的思想对密码进行穷举呢？对于一个初试密码0000，每一个位置都可以up和down，也就是每个位置有2中情况，4个位置就是8种情况，其实也就是0000这个节点有8个子节点</span></span><br><span class="line"><span class="function">String <span class="title">plusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	ch[j] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">minusOne</span><span class="params">(String s, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(ch[j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        ch[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ch[j] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(String target)</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        in sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            <span class="comment">//这里进行判断</span></span><br><span class="line">           	System.out.println(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                q.offer(up);</span><br><span class="line">                q.offer(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里增加步数 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,1中的代码中我们已经可以列举出所有的密码组合，接下来我们就需要结合题意来进行目标的寻找。我们需要明确三个点：1）target就是我们需要找的目标；2）0000的一个子节点为1000，但1000中又会把0000加进去，造成了死循环；3）遇到死亡代码时，我们的不对其进行操作，因为我们尝试不遇到这种情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">            String cur = q.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.equals(target))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    q.offer(up);</span><br><span class="line">                    visited.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    q.offer(down);</span><br><span class="line">                    visited.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，使用双向BFS来进行优化，也就是同时设置两个起点，当然使用这个必须知道当前情况中的起点和终点，像二叉树找最短深度就用不了。但是在这道题中，我们发现起点就是&quot;0000&quot;，终点就是target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : deadends) deads.add(s);    </span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; q2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    q1.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    q2.add(target);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String cur : q1)&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(deads.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q2.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                String up = plusOne(cur, j);</span><br><span class="line">                String down = minusOne(cur, j);</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                    temp.add(up);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                    temp.add(down);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）BFS解决智力题"><a href="#（2）BFS解决智力题" class="headerlink" title="（2）BFS解决智力题"></a>（2）BFS解决智力题</h3><p><strong>(力扣773——滑动谜题)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-28.png" alt="sf-2-28"></p>
<p><strong>思路</strong>：对于0来说，它可以走上下左右等位置，进而基于一个情况，可以衍生出子情况，这样就转化成了图的问题。但是本题的关键在于，如何去获取某种情况的子情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span>, n = <span class="number">3</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//1，目标字符串</span></span><br><span class="line">        String target = <span class="string">&quot;123450&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，获取初始的start</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                sb.append(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String start = sb.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3，这个数组能够获取某个位置相邻的位置，我们将2x3的数组抽象为长度为6的一维数组，那么下标为0的位置在原来的二位数组中对应下标为1，和3的元素</span></span><br><span class="line">        <span class="keyword">int</span>[][] neighbor = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">2</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4，BFS的核心逻辑</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.offer(start);</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz =q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)&#123;</span><br><span class="line">                String cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(target.equals(cur)) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="comment">//5，找到当前0所在的位置</span></span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(; cur.charAt(idx) != <span class="string">&#x27;0&#x27;</span>; idx++);</span><br><span class="line">                <span class="comment">//将0和周围的元素进行交换，获得新的字符串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> adj : neighbor[idx])&#123;</span><br><span class="line">                    String new_board = swap(cur.toCharArray(), adj, idx);</span><br><span class="line">                    <span class="comment">//避免走回头路</span></span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(new_board))&#123;</span><br><span class="line">                        q.offer(new_board);</span><br><span class="line">                        visited.add(new_board);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">        chars[i] = chars[j];</span><br><span class="line">        chars[j] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六，动态规划"><a href="#六，动态规划" class="headerlink" title="六，动态规划"></a>六，动态规划</h1><h2 id="1，动态规划核心原理"><a href="#1，动态规划核心原理" class="headerlink" title="1，动态规划核心原理"></a>1，动态规划核心原理</h2><h3 id="（1）动态规划解题核心框架"><a href="#（1）动态规划解题核心框架" class="headerlink" title="（1）动态规划解题核心框架"></a>（1）动态规划解题核心框架</h3><p>动态规划问题的一般形式就是求最值，它其实是运筹学的⼀种最优化⽅法，只不过在计算机问题上应⽤⽐较多，⽐如说让你求最⻓递增⼦序列呀，最⼩编辑距离等等。</p>
<p>求最值的核心一般就是穷举，但是动态规划中，存在<strong>“重叠子问题”</strong>这种特殊情况，所以需要<strong>“备忘录”</strong>或“DP table”来优化穷举过程，避免不必要的计算。此外，动态规划问题中一定具备<strong>“最优子结构”</strong>，这样才能通过子问题的最值得到原问题的最值。寻找最优子结构，就需要在穷举的过程中，获取正确的<strong>“状态转移方程”</strong>。</p>
<p>这几个步骤中，最难的就是找状态转移方程，一般我们遵循以下步骤来寻找状态转移方程：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组&#x2F;函数的含义</strong> 。照此可以得到下面的框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初试化base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base;</span><br><span class="line"><span class="comment">//对不同的状态state，进行状态的转移</span></span><br><span class="line"><span class="keyword">for</span>  state1 in state1All:</span><br><span class="line">	<span class="keyword">for</span> state2 in state2All:</span><br><span class="line">		<span class="keyword">for</span>...</span><br><span class="line">            dp[state1][state2][...] = getMaxOrMin(choice1, choice2,...)</span><br></pre></td></tr></table></figure>

<p><strong>（力扣509——斐波那契数列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-29.png" alt="sf-2-29"></p>
<p><strong>思路</strong>：</p>
<p>a，这是一道认识动态规划的入门题。该算法可以使用传统的递归方法，但是其中存在大量的重复操作，效率比较低。这里我们直接看讲义中的分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-30.png" alt="sf-2-30"> </p>
<p>b，想要对上面的递归过程进行效率上的提升，我们可以引入「备忘录」，每次算出某个⼦问题的答案后别急着返回，先记到「备忘录」⾥再返回；每次遇到⼀个⼦问题先去「备忘录」⾥查⼀查，如果发现之前已经解决过这个问题了，直接把答案拿出来⽤，不要再耗时去计算了。  </p>
<p>备忘录其实协助进行了一个剪枝操作，下面这两张图就能看出其中的原理，左边表明了剪枝的情况，右边则说明了递归是自顶向下进行的。此时算法的时间复杂度是 O(n)，⽐起上面的暴⼒算法，是降维打击  。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-31.png" alt="sf-2-31" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-32.png" alt="sf-2-32" style="zoom:67%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="comment">//设定备忘录</span></span><br><span class="line">    <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里是base case</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">//如果备忘录中已经有值，就别再计算啦</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    </span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>c，DP数组迭代（递推）解法</p>
<p>这里我们可以把这个「备忘录」独⽴出来成为⼀张表，通常叫做 DP table，在这张表上完成「⾃底向上」的推算 （左图）；这⾥，引出「状态转移⽅程」这个名词，实际上就是描述问题结构的数学形式（右图）；</p>
<p>f(n) 的函数参数会不断变化，所以你把参数 n 想做⼀个状态，这个状态 n 是由状态 n - 1 和状态 n - 2转移（相加）⽽来，这就叫状态转移，仅此⽽已。你会发现，上⾯的⼏种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] &#x3D; dp[i -1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个⽅程式的不同表现形式。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-33.png" alt="sf-2-33" style="zoom: 50%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-34.png" alt="sf-2-34" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据斐波那契数列的状态转移⽅程，当前状态只和之前的两个状态有关，其实并不需要那么⻓的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就⾏了.</span></span><br><span class="line"><span class="comment">//这⼀般是动态规划问题的最后⼀步优化，如果我们发现每次状态转移只需要 DP table 中的⼀部分，那么可以尝试缩⼩ DP table 的⼤⼩，只记录必要的数据，从⽽降低空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// base case</span></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分别代表 dp[i - 1] 和 dp[i - 2]</span></span><br><span class="line">	<span class="keyword">int</span> dp_i_1 = <span class="number">1</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">// dp[i] = dp[i - 1] + dp[i - 2];</span></span><br><span class="line">		<span class="keyword">int</span> dp_i = dp_i_1 + dp_i_2;</span><br><span class="line">		<span class="comment">// 滚动更新</span></span><br><span class="line">		dp_i_2 = dp_i_1;</span><br><span class="line">		dp_i_1 = dp_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣322——零钱兑换)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-35.png" alt="sf-2-35" style="zoom:80%;" />

<p><strong>思路</strong>：首先明确，该问题具有<strong>最优子结构</strong>（也就是硬币用的数量之间不能有互相的影响，而是每个面额都可以随便用），具体来看就是<strong>原问题</strong>为amount &#x3D; 11时的最小子硬币数，<strong>子问题</strong>为amount &#x3D; 10时的最小子硬币数，那么原问题 &#x3D; 子问题 + 1个硬币即可。确定了最优子结构以后，我们按照三个步骤来完成本题：</p>
<p>A，<u>明确dp数组的含义</u>：当目标金额为i时，至少要dp[i]个硬币才能凑出来</p>
<p>B，<u>状态转移方程</u>：dp[i] &#x3D; dp[i - coin] + 1，由于是要找最小且coin的情况有三种，所以这里应该是min{dp[i] &#x3D; dp[i - coin] + 1, dp[i]}</p>
<p>C,<u>确定初始值</u>：dp[0] &#x3D; 0;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - coin &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）base-case和备忘录的初试值怎么定"><a href="#（2）base-case和备忘录的初试值怎么定" class="headerlink" title="（2）base case和备忘录的初试值怎么定"></a>（2）base case和备忘录的初试值怎么定</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-36.png" alt="sf-2-36"></p>
<p><strong>思路</strong>：</p>
<p><u>A，首先是定义DP数组的含义</u>：int dp(int[][] matrix, int i, int j);  这里其实是个一个特殊的dp数组，表示从第一行的任意位置落下，到i和j位置所需要的最小路径。</p>
<p><u>B，明确状态转移方程</u>；对于matrix[i][j]，它的值的状态是由matrix[i-1][j]，matrix[i-1][j-1]，matrix[i-1][j+1]这三个值来确定的，也就是其中的最小值+matrix[i][j]本身的值。</p>
<p><u>C，确定初始值</u>：第一个行的每个值都是其本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，下面是没有进行剪枝的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(res, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//进行某个点的计算</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i，j位置的值有三个状态确定</span></span><br><span class="line">    <span class="keyword">return</span> matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,可以加上备忘录来减少运算</span></span><br><span class="line"><span class="keyword">int</span> memo[][];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        Arrays.fill(memo[j], <span class="number">66666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res = Math.min(matrix, dp(res, n - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n || j &gt;=n || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != <span class="number">66666</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[i][j] = matrix[i][j] + min(dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line">本题中的base <span class="keyword">case</span>比较隐蔽，但是只要抓住题中描述，第一行到最后一行的最小值，我们就可以发现，如果只有第一行，那就是当前位置的值，所以base <span class="keyword">case</span>就是<span class="number">0</span>行时的情况</span><br><span class="line">对于备忘录，我们设置了<span class="number">66666</span>的特殊值，这个只要比题意中要求的最大路径还要大就行，那样就不影响结果啦</span><br></pre></td></tr></table></figure>



<h3 id="（3）最优子结构和dp数组的遍历方向怎么定"><a href="#（3）最优子结构和dp数组的遍历方向怎么定" class="headerlink" title="（3）最优子结构和dp数组的遍历方向怎么定"></a>（3）最优子结构和dp数组的遍历方向怎么定</h3><p><strong>最优子结构</strong>：动态规划基于最优子结构，最优子结构意味着题目中的情况有重复子问题。（没有重复子问题不就是递归吗？），在重复子问题的基础上，要求一个最值！（其实有动态子结构就可以写暴力解，然后能优化重复子问题再优化，就是动态规划的一般形式了）</p>
<p>越是困难的动态规划题，最优子结构往往越是隐蔽，这里很好理解，如果一个学校有十个班，每个班的最高分我们可以计算，那么要求全校的最高分我们也能够通过每个班的最高分这个子问题来计算；但是，如果知道每个班的最大分差（最高分 - 最低分），我们并不一定能够知晓全校的最大分差。</p>
<p>那怎么办呢？只能<strong>改造问题</strong>，比如假设最低分基数为0，这样就知道了每个班最高分是多少，然后就可以把问题转换为求最高分。</p>
<p><strong>重叠子问题</strong>：最简单的方式就是把递归树画出来看有没有重叠的子问题（前面的斐波那契数列已经讲过了）</p>
<p>另外就是对于递归部分的代码进行检查，观察从一个状态到另一个状态到底有几种可能，如果有多种可能，那就说明有重复子问题，比如上一节中的matrix[i][j]的转移情况</p>
<p><strong>数组的遍历方向</strong>：有时数组从上往下遍历，有时从下往上，甚至斜着遍历，把握两点，1）遍历的过程中，所需的状态必须是已经计算出来的 ；2）遍历结束后，存储结果的那个位置必须已经被计算出来 </p>
<h3 id="（4）提高刷题幸福感的小技巧"><a href="#（4）提高刷题幸福感的小技巧" class="headerlink" title="（4）提高刷题幸福感的小技巧"></a>（4）提高刷题幸福感的小技巧</h3><h2 id="2，经典动态规划"><a href="#2，经典动态规划" class="headerlink" title="2，经典动态规划"></a>2，经典动态规划</h2><h3 id="（1）最长递增子序列问题"><a href="#（1）最长递增子序列问题" class="headerlink" title="（1）最长递增子序列问题"></a>（1）最长递增子序列问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-37.png" alt="sf-2-37"></p>
<p><strong>思路</strong>：</p>
<p>第一种：数学归纳法</p>
<p><u>A，DP数组的定义</u>：dp[i] 表示以 nums[i] 这个数结尾的最⻓递增⼦序列的⻓度。  （最终的结果就是dp数组中的最大值）</p>
<p><u>B，确定初试值</u>：dp[i]最开始是1，因为子序列肯定有一个自己</p>
<p><u>C，状态转移方程</u>：如果我知道了dp[0~4]的值，我如何计算dp[5]的值？？？</p>
<p>比如下图，我们nums[5]的值为3，那么我们需要找到前⾯那些结尾⽐ 3 ⼩的⼦序列，然后把 3 接到最后，就可以形成⼀个新的递增⼦序列，⽽且这个新的⼦序列⻓度加⼀。  </p>
<p>当然，可能形成很多种新的⼦序列，但是我们只选择最⻓的那⼀个，把最⻓⼦序列的⻓度作为 dp[5] 的值即可。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-38.png" alt="sf-2-38" style="zoom: 33%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-39.png" alt="sf-2-39" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//时间复杂度为O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）最大子数组和问题"><a href="#（2）最大子数组和问题" class="headerlink" title="（2）最大子数组和问题"></a>（2）最大子数组和问题</h3><p><strong>（力扣53——最大子数组和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-40.png" alt="sf-2-40"></p>
<p><strong>思路</strong>：此题无法使用滑动窗口，因为有负数，窗口中值的变化不利于判断窗口如何改变</p>
<p>A，<u>明确dp数组的含义</u>：以 nums[i] 为结尾的「最⼤⼦数组和」为 dp[i]。</p>
<p>B，<u>确定初始值</u>：dp[i] &#x3D; nums[i]</p>
<p>C，<u>确定状态转移方程</u>：假设已经算出了 dp[i-1]，那么dp[i]有两种选择，dp[i-1] + nums[i]或者就是dp[i - 1]，看谁打就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">                res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）最长公共子序列问题"><a href="#（3）最长公共子序列问题" class="headerlink" title="（3）最长公共子序列问题"></a>（3）最长公共子序列问题</h3><p><strong>（力扣1143——最长公共子序列）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-41.png" alt="sf-2-41"></p>
<p><strong>思路</strong>：两种思路，一种是自顶向下（递归），一种所以自底向上（迭代），下面是按顺序来说明</p>
<p>A，<u>明确dp函数</u>：dp(s1,i,s2,j)计算<code>s1[i..]</code>和<code>s2[j..]</code>的最长公共子序列长度。那么最后的答案就是i和j为0的时候</p>
<p>B，<u>初始状态</u>：也即是i为s1的长度，j为s2的长度，此时计算的是两个空串的公共子序列长度，那此时dp的值就是0</p>
<p>C，<u>转移方程</u>：如果s1[i]与s2[j]是相等的，那么这两个字符一定在LCS当中（左图）；<code>s1[i] != s2[j]</code>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中（右图），此时需要把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度（这里还有一个优化，情况3中的结果肯定比情况1和2短，所以可以不算，一定程度上就是被包含了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-42.png" alt="sf-2-42" style="zoom:67%;" /> <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-43.png" alt="sf-2-43" style="zoom:50%;" /> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(text1, <span class="number">0</span>, text2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length() || j == s2.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">            memo[i][j] = <span class="number">1</span> + dp(s1, i + <span class="number">1</span>, s2, j + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] =  Math.max(dp(s1, i + <span class="number">1</span>, s2, j), dp(s1, i, s2, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[i][j]表示s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度，我们的目标是求dp[m][n]的lcs的值</p>
<p>B，<u>确定初始状态</u>：dp[0][0]的值为0</p>
<p>C，确定状态转移方程：这里直接看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣583——两个字符串的删除操作）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-44.png" alt="sf-2-44" style="zoom:80%;" />

<p><strong>思路</strong>：计算出最长子序列即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借助上一题的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="comment">// 复用前文计算 lcs 长度的函数</span></span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> m - lcs + n - lcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣712——两个字符串的最小ASCII删除和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-45.png" alt="sf-2-45" style="zoom:80%;" />

<p><strong>思路</strong>：采用自顶向下的方式（递归）</p>
<p>A，<u>定义dp函数</u>：dp(s1, i, s2, j)表示将串删除为s1[i…]和s2[j…]这样时所需要的最小ASCII和。我们的目标是得到dp(s1,0,s2,0)</p>
<p>B，<u>确定初始值</u>：如果i的值为s1.length(),那么结果中是删除s2剩下元素的总和，反之亦然。</p>
<p>C，<u>确定状态转移方程</u>：如果i和j位置的字符相同，那么从当前状态来看，就不要删除。如果不同，则需要从其他的状态中找最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] mm : memo)&#123;</span><br><span class="line">            Arrays.fill(mm, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(s1, <span class="number">0</span>, s2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1, <span class="keyword">int</span> i, String s2, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; s2.length(); j++)&#123;</span><br><span class="line">                res += s2.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == s2.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; s1.length(); i++)&#123;</span><br><span class="line">                res += s1.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;</span><br><span class="line">                memo[i][j] = dp(s1, i + <span class="number">1</span>, s2, j +<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这里的意思是，继续去找s1.i和s2.j+1对比 以及 s1.i+1和s2.j对比所需要的删除的最小值。所以其实不存在示例2中出错的情况</span></span><br><span class="line">                memo[i][j] = Math.min(dp(s1, i, s2, j +<span class="number">1</span>) + s2.charAt(j), dp(s1, i + <span class="number">1</span>, s2, j) + s1.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代，base case需要设置好</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case，</span></span><br><span class="line">        <span class="comment">//如果s2为空，那么s1对应每个位置的需要删除的值就是自己字符串中的值相加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + s1.charAt(i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + s2.charAt(j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>), dp[i - <span class="number">1</span>][j] + s1.charAt(i - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）编辑距离问题"><a href="#（4）编辑距离问题" class="headerlink" title="（4）编辑距离问题"></a>（4）编辑距离问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-46.png" alt="sf-2-46" style="zoom:80%;" />

<p><strong>思路</strong>：还是分为递归和迭代</p>
<p>A，<u>定义DP函数</u>：对于两个字符串，我们可以从字符串尾开始，如下图，尝试将是b变为s2，我们发现对于i和j指针所指向的字符，包含了三种操作：插入，删除，替换（图中的流程是上帝视角），在这个位置我们到底选择哪种操作，其实是不知道的，必须去找其中最小的那个值；还有一个操作，就是相同的时候啥也别做，减少操作次数。   所以我们可以定义一个DP(s1, i, s2, j)，该函数返回 s1[0..i] 和 s2[0..j] 的最⼩编辑距离 。当i或j为0的时候，就返回另一个字符剩下的长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.gif" alt="sf-2-47" style="zoom: 50%;" />  <img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-47.png" alt="sf-2-47" style="zoom:50%;" /></p>
<p>B，<u>明确初始值</u>：DP函数中的Base，当任意一个字符创到结尾时，返回另一个字符串剩下的长度即可。</p>
<p>C，<u>状态转移方程</u>：DP(s1, i, s2, j) 的值取决于i和j位置处的字符是不是相等的，如果不相等，那就是看插入，删除，还是替换哪种值最小，min(DP(s1, i, s2, j - 1) + 1, DP(s1, i - 1, s2, j) + 1, DP(s1, i - 1 , s2, j - 1) + 1)这三种情况是根据图中以s2位基础修改s1得来的；如果相等，则DP(s1, i, s2, j) &#x3D; DP(s1, i - 1, s2, j - 1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP(word1, m - <span class="number">1</span>, word2, n - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(String s1, <span class="keyword">int</span> m, String s2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[m][n] != -<span class="number">1</span>) <span class="keyword">return</span> memo[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(m) == s2.charAt(n))&#123;</span><br><span class="line">            memo[m][n] = DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[m][n] = Math.min(DP(s1, m, s2, n - <span class="number">1</span>) + <span class="number">1</span>, Math.min(DP(s1, m - <span class="number">1</span>, s2, n) + <span class="number">1</span>,DP(s1, m - <span class="number">1</span>, s2, n - <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A，<u>明确dp含义</u>：s1[0..i] 和 s2[0..j] 的最⼩编辑距离是 dp[i-1][j-1]  </p>
<p>B，<u>明确初始值</u>：DP[i][0] &#x3D; i ,DP[0][j] &#x3D; j  </p>
<p>C，<u>状态转移方程</u>：如果说i - 1和j - 1处的字符相同，那么DP[i][j] &#x3D; DP[i - 1][j - 1]。如果不同，则也是分三种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] DP = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) DP[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) DP[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    DP[i][j] = DP[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    DP[i][j] = Math.min(DP[i - <span class="number">1</span>][j] + <span class="number">1</span>, Math.min(DP[i][j - <span class="number">1</span>] +<span class="number">1</span>, DP[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong>：</p>
<p>A，字符创比较类问题都可以抽象为下面的图，并且可以看到只有三个状态可以降低空间复杂度</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-48.png" alt="sf-2-48" style="zoom:67%;" /> 

<img src="C:\Users\zhao\Desktop\sf-2-49.png" alt="sf-2-49" style="zoom: 80%;" />

<p>B，可以输出路径</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-50.png" alt="sf-2-50" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-51.png" alt="sf-2-51" style="zoom:80%;" />

<h3 id="（5）正则表达式问题"><a href="#（5）正则表达式问题" class="headerlink" title="（5）正则表达式问题"></a>（5）正则表达式问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-52.png" alt="sf-2-52"></p>
<p><strong>思路</strong>：这个匹配的过程要想清楚，我们用两个指针来指向s和p字符串，如果字符串中没有*号的话，那么对于两个指针指向的字符，只要相同或者p中一个 . 我们就认为匹配。比如abbbc和a…c是匹配的</p>
<p>加入了*号后，稍微有点复杂，p中的某个字符是* ,那么p之前的那个字符，到底匹配了几次呢？或者说，它能够消耗s中的字符吗？消耗1次？n次？还是0次？</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-53.png" alt="sf-2-53" style="zoom:67%;" />

<p>所以本题中的状态就是i和j中指针的位置，选择就是p[j]选择匹配几个字符</p>
<p>A，<u>定义的dp函数</u>：bool dp(String s, int i, String p, int j)，该函数返回<code>s[i..]</code>是否可以匹配<code>p[j..]</code>，我们的目标就是找到i和j为0的结果</p>
<p>B，<u>确定初始值</u>：一个 base case 是<code>j == p.size()</code>时，按照<code>dp</code>函数的定义，这意味着模式串<code>p</code>已经被匹配完了，那么应该看看文本串<code>s</code>匹配到哪里了，如果<code>s</code>也恰好被匹配完，则说明匹配成功：另一个比较特殊，下图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-54.png" alt="sf-2-54" style="zoom:67%;" />

<p>C，<u>状态转移</u>：其实就是上面的情况中的翻译，先看代码再看解释</p>
<p><strong>TNND做了三四个小时了，受不了了，就是跑不对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j == p.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length())  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>((p.length() - j) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; p.length(); j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j + <span class="number">1</span>)  != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">            memo[i][j] = Math.max(dp(s, i, p, j + <span class="number">2</span>) ,dp(s, i + <span class="number">1</span>, p, j));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>)  == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            memo[i][j] = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>妥协了，cv大法好</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-55.png" alt="sf-2-55" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//&quot;&quot; 和p的匹配关系初始化，a*a*a*a*a*这种能够匹配空串，其他的是都是false。</span></span><br><span class="line">        <span class="comment">//  奇数位不管什么字符都是false，偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i+= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> sc = s.charAt(i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> pc = p.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sc == pc || pc == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j - <span class="number">2</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3，背包问题"><a href="#3，背包问题" class="headerlink" title="3，背包问题"></a>3，背包问题</h2><p>背包问题本质上还是动态规划问题，接下来是一些应用于该问题的标准套路和规则</p>
<p>首先，问题中的状态和选择，状态有两个，就是「背包的容量」和「可选择的物品」。  对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」  </p>
<p>接着，dp数组的含义，由于状态有两个，那么dp数组也是二维的。dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最⼤价值是 dp[i][w]。  如果 dp[3][5] &#x3D; 6，其含义为：对于给定的⼀系列物品中，若只对前 3 个物品进⾏选择，当背包<br>容量为 5 时，最多可以装下的价值为 6。  (base case 就是 dp[0][..] &#x3D; dp[..][0] &#x3D; 0，因为没有物品或者背包没有空间的时候，能装的最⼤价值就是 0 )</p>
<p>最后，就是根据选择来进行状态转移</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-56.png" alt="sf-2-56" style="zoom:67%;" /> 

<p>代码框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] wt, <span class="keyword">int</span>[] val)</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(itn w = <span class="number">1</span>; w &lt;= W; w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w - wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//第i个物品的重量是wt[i - 1]，这里发现，放不进去啦，就和前面一样就行</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//第i个物品的价值是val[i - 1],占用的空间是wt[i - 1],所以试着装进去看一下</span></span><br><span class="line">                <span class="comment">//dp[i - 1][w - wt[i - 1]]表示的是，前i - 1个物品，容量预留了w - wt[i - 1]，此时的最大价值，这样才能将i个物品放进去咯</span></span><br><span class="line">                dp[i][w] = Math.max(dp[i - <span class="number">1</span>][w - wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（1）0-1背包问题"><a href="#（1）0-1背包问题" class="headerlink" title="（1）0-1背包问题"></a>（1）0-1背包问题</h3><p>同上</p>
<h3 id="（2）完全背包问题"><a href="#（2）完全背包问题" class="headerlink" title="（2）完全背包问题"></a>（2）完全背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-57.png" alt="sf-2-57" style="zoom: 80%;" /> 

<p><strong>思路</strong>：有⼀个背包，最⼤容量为 amount，有⼀系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量<br>⽆限。请问有多少种⽅法，能够把背包恰好装满  （要装满就是完全背包问题）</p>
<p>A，<u>明确状态和选择</u>：状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」</p>
<p>B，<u>明确dp数组的定义</u>：dp[i][j]表示使用前i个硬币，凑出总额为j的情况，有多少种凑法，这里不同于0-1背包</p>
<p>C，<u>明确初始值</u>：dp[0][..] &#x3D; 0， dp[..][0] &#x3D; 1  </p>
<p>D，<u>状态转移（怎么做选择？）</u>：如果你不把这第 i 个物品装⼊背包，也就是说你不使⽤ coins[i] 这个⾯值的硬币，那么凑出⾯额 j 的⽅法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。  如果你把这第 i 个物品装⼊了背包，也就是说你使⽤ coins[i] 这个⾯值的硬币，那么 dp[i][j] 应该等于dp[i][j-coins[i-1]] <strong>(这里很离谱，似乎是表现了只能放一个coins[i]硬币，但是嗷，很快嗷，很离谱嗷，这里第一个下标是i，根据定义来说，这个下标已经包含了使用coins[i]的其他情况)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - coins[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以压缩状态，进⼀步降低算法的空间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> = coins.length;</span><br><span class="line">    <span class="comment">//dp数组表示在使用i个硬币的情况下，j金额需要多少硬币才能凑成</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0表示金额0，不管几枚硬币都是一种情况</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - coins[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//这里的状态转移就是包含了第i个硬币加进来，和没加进来的情况</span></span><br><span class="line">                dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）子集背包问题"><a href="#（3）子集背包问题" class="headerlink" title="（3）子集背包问题"></a>（3）子集背包问题</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-58.png" alt="sf-2-58" style="zoom:80%;" />

<p><strong>思路</strong>：转化一下，给⼀个可装载重量为 sum &#x2F; 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在⼀种装法，能够恰好将背包装满？  </p>
<p>A，<u>dp[][]数组的定义</u>：dp[i][j] &#x3D; x 表示，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明有一种组合可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满 。如果 dp[4][9] &#x3D; true，其含义为：对于容量为 9 的背包，若只是⽤前 4 个物品，可以有⼀种⽅法把背包恰好装满 （也就是对于sum为9，前4个数字中有一种组合可以得到sum为9）</p>
<p>B，<u>确定初始值</u>：想求的最终答案就是 dp[N][sum&#x2F;2]，base case 就是 dp[..][0] &#x3D; true 和 dp[0][..] &#x3D; false，因为背包没有空间的时候，就相当于装满了，⽽当没有物品可选择的时候，肯定没办法装满背包 。</p>
<p>C，<u>状态转移</u>：如果不把 nums[i] 算⼊⼦集，或者说你不把这第 i 个物品装⼊背包，那么是否能够恰好装满背包，取决于上⼀个状态 dp[i-1][j]，继承之前的结果。如果把 nums[i] 算⼊⼦集，或者说你把这第 i 个物品装⼊了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4，用动态规划解决游戏类问题"><a href="#4，用动态规划解决游戏类问题" class="headerlink" title="4，用动态规划解决游戏类问题"></a>4，用动态规划解决游戏类问题</h2><h3 id="（1）股票买卖类问题"><a href="#（1）股票买卖类问题" class="headerlink" title="（1）股票买卖类问题"></a>（1）股票买卖类问题</h3><p><strong>(力扣118——买卖股票的最佳时机4)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-59.png" alt="sf-2-59"></p>
<p><strong>思路</strong>：首先明确状态和选择，本题中的<strong>选择</strong>有三个：买⼊、卖出、⽆操作，我们⽤ buy, sell, rest 表示这三种选<br>择 ，但是不是每天可以任意选择，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，⼀种是 buy 之后的 rest（持有了股票），⼀种是 sell 之后的rest（没有持有股票）。⽽且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。  <strong>状态</strong>有三个，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨⽤ 1 表示持有，0 表示没有持有）。然后我们⽤⼀个三维数组就可以装下这⼏种状态的全部组合 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> or <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n - <span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，⼤ K 为交易数的上限，<span class="number">0</span> 和 <span class="number">1</span> 代表是否持有股票。</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">			<span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">				dp[i][k][s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure>

<p>A，<u>定义dp数组</u>：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。再⽐如 dp[2][3][0] 的含义：今天是第⼆天，我现在⼿上没有持有股票，⾄今最多进⾏ 3 次交易 。\\\我们的目标是求dp[n - 1][K][0]，即最后⼀天，最多允许 K 次交易，最多获得多少利润 (注意最后为0肯定比最后为1获得的利润多)</p>
<p>B，<u>状态转移</u>：</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-60.png" alt="sf-2-60" style="zoom: 33%;" />    

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 sell )</span><br><span class="line"><span class="comment">//解释：今天我没有持有股票，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就没有持有，且截⾄昨天最⼤交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最⼤交易次数限制依然为 k。</span></span><br><span class="line"><span class="comment">//2、我昨天持有股票，且截⾄昨天最⼤交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最⼤交易次数限制依然为 k。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max( 今天选择 rest, 今天选择 buy )</span><br><span class="line"><span class="comment">//解释：今天我持有着股票，最⼤交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最⼤利润：</span></span><br><span class="line"><span class="comment">//1、我昨天就持有着股票，且截⾄昨天最⼤交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最⼤交易次数限制依然为 k  </span></span><br><span class="line"><span class="comment">//2、我昨天本没有持有，且截⾄昨天最⼤交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最⼤交易次数限制为 k。(今天我要买股票了，消耗一次交易次数，所以昨天最大次数限制为k-1，今天我才能买股票)</span></span><br></pre></td></tr></table></figure>

<p>C，<u>明确初始值</u>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：还没开始的时候，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment">//解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。</span></span><br><span class="line">dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"><span class="comment">//解释：不允许交易的情况下，是不可能持有股票的。</span></span><br><span class="line"><span class="comment">//因为我们的算法要求⼀个最⼤值，所以初始值设为⼀个最⼩值，⽅便取最⼤值</span></span><br></pre></td></tr></table></figure>

<p>总体上的框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">base <span class="keyword">case</span>：<span class="comment">//这还有-1，当然实际做题的时候会有应对</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">0</span>] = dp[...][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][...][<span class="number">1</span>] = dp[...][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移⽅程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p><strong>（力扣121——买卖股票的最佳时机）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-61.png" alt="sf-2-61"></p>
<p><strong>思路</strong>：根据前面定定义的情况套就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">            = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -price[i])<span class="comment">//这里我们发现dp[i - 1][0][0] = 0</span></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line">         = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + -price[i]);</span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> = -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 空间复杂度优化版本</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = prices.length;</span><br><span class="line">		<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">			dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">			dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp_i_0;</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣309——股票买卖最佳时机含冷冻期)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-62.png" alt="sf-2-62" style="zoom:80%;" />

<p><strong>思路</strong>：交易次数是无线的；包含冷冻期，在购买股票的时候状态转移的位置要注意</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，dp数组定义：dp[3][2][1] 的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交易。这样情况下的最高利润</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2,状态转移方程</span></span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>] - price[i]);<span class="comment">//这里i天购买股票，应该是i-2的参照</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2状态转移方程简化，把k位置简化了                </span></span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + price[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">0</span>] - price[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3,base case以及特殊性情况处理</span></span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[i][0] = max(dp[-1][0] + dp[-1][1] + price[i]) = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -price;</span><br><span class="line">    <span class="comment">//dp[i][1] = max(dp[-1][1] + dp[-1][0] - price[i]) = max(-infinity, 0 - prices[i])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">2</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间复杂度优化版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = prices.length;</span><br><span class="line">	<span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">		dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">		dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">		dp_pre_0 = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(力扣714——买卖股票的最佳时机含手续费)</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-63.png" alt="sf-2-63" style="zoom:80%;" />

<p><strong>思路</strong>：k还是无限的，每次买的把手续费减了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i] - fee;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣123——买卖股票的最佳时机交易次数为2）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-64.png" alt="sf-2-64" style="zoom:80%;" />

<p><strong>思路</strong>：这里注意，根据框架来说，这里的k初始值为2，我们在进行状态选择的时候，要将k加进去遍历，k的初试值为2，最小值为1，是递减的情况，和i是反着来的，这是一种符合语义的方式（递增也可以得到正确答案），因为递减表示交易的机会在减少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣188——买卖股票的最佳时机4）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-65.png" alt="sf-2-65" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>如果直接是将上一题的2换成输入的值，是通不过不了的哦，因为测试用例k会故意给你一个很大的值，这样new数组的时候就超出内存限制了。</p>
<p>但是我们可以发现，如果k的值超过了n&#x2F;2，那就是交易次数没有限制的情况啦。</p>
<p>反之就是要限制的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.length / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_inf(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfit_k(prices, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_k</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> k_max = max;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k_max + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算k为0的时候的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = k_max; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理 base case</span></span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k_max][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> == -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）打家劫舍类问题"><a href="#（2）打家劫舍类问题" class="headerlink" title="（2）打家劫舍类问题"></a>（2）打家劫舍类问题</h3><p><strong>（力扣198——打家劫舍）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-66.png" alt="sf-2-66" style="zoom:80%;" />

<p><strong>思路</strong>：明确状态和选择，对于一排房子，<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p>
<p>A，<u>明确dp函数的含义</u>：dp(int[] nums, int start)，表示从start位置抢，能获得的最大值</p>
<p>B，<u>明确初始值</u>：这里就是函数中的base case，当start为nums的长度的时候，dp函数应该返回0</p>
<p>C，<u>状态转移过程</u>：对于一个房子nums[i]，可以选择不抢（不抢就光顾下一家nums[i + 1]），也可以选择抢（那下一家就只能是nums[i + 2]，因为要隔着抢），从这两个里面选最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>), nums[start] + dp(nums, start + <span class="number">2</span>));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//1，dp[i]表示抢劫第i家房屋的时候，最大收益</span></span><br><span class="line">        <span class="comment">//2,base case就是抢劫第n + 1家房屋的时候，收益是0，没得抢了已经</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//3，对于第i个房屋的最大收益，取决于前一个状况的收益，和目前抢了这家，前两个情况的收益</span></span><br><span class="line">            dp[i] = Math.max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣213——打家劫舍2）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-67.png" alt="sf-2-67"></p>
<p><strong>思路</strong>：这里再多加一个判断就行了，因为收尾两个位置不能同时选，所以演化出了下面的三种情况，也就是数组的长度被限制住了。这里显然，情况2和情况3比情况1要更好。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-68.png" alt="sf-2-68" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = dp(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res2 = dp(nums, <span class="number">1</span>, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res =  Math.max(dp(nums,start + <span class="number">1</span>, end), nums[start] + dp(nums, start + <span class="number">2</span>, end));</span><br><span class="line">        memo[start] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span>, n - <span class="number">2</span>), robRange(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_1 = <span class="number">0</span>, dp_i_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">        dp_i_2 = dp_i_1;</span><br><span class="line">        dp_i_1 = dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣337——打家劫舍3）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-69.png" alt="sf-2-69" style="zoom:67%;" />

<p><strong>思路</strong>：父节点处的值，应该和两个子节点有关，也就是在状态转移的时候，应该看当前节点的左右子节点的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> do_it = root.val  + </span><br><span class="line">            (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">            + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="keyword">int</span> not_do = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="keyword">int</span> res = Math.max(do_it, not_do);</span><br><span class="line"></span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（3）博弈问题"><a href="#（3）博弈问题" class="headerlink" title="（3）博弈问题"></a>（3）博弈问题</h3><p><strong>（力扣877——石子游戏）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-70.png" alt="sf-2-70"></p>
<p><strong>思路</strong>：先手必胜，因为可以控制自己选基数堆还是偶数堆，这里我们尝试用动态规划来解决</p>
<p>A，<u>定义DP数组</u></p>
<p>dp[i][j].fir &#x3D; x 表示，对于 piles[i…j] 这部分⽯头堆，先⼿能获得的最⾼分数为 x。<br>       dp[i][j].sec &#x3D; y 表示，对于 piles[i…j] 这部分⽯头堆，后⼿能获得的最⾼分数为 y。  </p>
<p>举例理解⼀下，假设 piles &#x3D; [2, 8, 3, 5]，索引从 0 开始，那么：<br>        dp[0][1].fir &#x3D; 8 意味着：⾯对⽯头堆 [2, 8]，先⼿最多能够获得 8 分；dp[1][3].sec &#x3D; 5 意味着：⾯对⽯头堆 [8, 3, 5]，后⼿最多能够获得 5 分。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-71.png" alt="sf-2-71" style="zoom:50%;" />

<p>我们想求的答案是先⼿和后⼿最终分数之差，按照这个定义也就是 dp[0][n-1].fir - dp[0][n- 1].sec，即⾯对整个 piles，先⼿的最优得分和后⼿的最优得分之差。  </p>
<p>B,<u>明确初试值</u></p>
<p>就是对角线的值，dp[i][i].fir &#x3D; piles[i],  dp[i][i].sec&#x3D; 0。因为只有一堆的时候，当然是先手大</p>
<p>C，<u>状态转移</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1，状态：状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的⼈。</span></span><br><span class="line">dp[i][j][fir or sec]</span><br><span class="line">其中：</span><br><span class="line"><span class="number">0</span> &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，选择：选择有两个：选择最左边的那堆⽯头，或者选择最右边的那堆⽯头</span></span><br><span class="line">n = piles.length</span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">	<span class="keyword">for</span> j &lt;= i &lt; n:</span><br><span class="line">		<span class="keyword">for</span> who in &#123;fir, sec&#125;:</span><br><span class="line">			dp[i][j][who] = max(left, right)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，状态转移方程</span></span><br><span class="line">dp[i][j].fir = max(piles[i] + dp[i+<span class="number">1</span>][j].sec, piles[j] + dp[i][j-<span class="number">1</span>].sec)</span><br><span class="line">dp[i][j].fir = max( 选择最左边的⽯头堆 , 选择最右边的⽯头堆 )</span><br><span class="line"># 解释：我作为先⼿，⾯对 piles[i...j] 时，有两种选择：</span><br><span class="line"># 要么我选择最左边的那⼀堆⽯头，然后⾯对 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿；</span><br><span class="line"># 要么我选择最右边的那⼀堆⽯头，然后⾯对 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 但是此时轮到对⽅，相当于我变成了后⼿。</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">if</span> 先⼿选择左边:</span><br><span class="line">dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir</span><br><span class="line"><span class="keyword">if</span> 先⼿选择右边:</span><br><span class="line">dp[i][j].sec = dp[i][j-<span class="number">1</span>].fir</span><br><span class="line"># 解释：我作为后⼿，要等先⼿先选择，有两种情况：</span><br><span class="line"># 如果先⼿选择了最左边那堆，给我剩下了 piles[i+<span class="number">1.</span>..j]</span><br><span class="line"># 此时轮到我，我变成了先⼿；</span><br><span class="line"># 如果先⼿选择了最右边那堆，给我剩下了 piles[i...j-<span class="number">1</span>]</span><br><span class="line"># 此时轮到我，我变成了先⼿。</span><br><span class="line"></span><br><span class="line"><span class="comment">//4，base case</span></span><br><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = <span class="number">0</span></span><br><span class="line">其中 <span class="number">0</span> &lt;= i == j &lt; n</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-72.png" alt="sf-2-72" style="zoom:67%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.length;</span><br><span class="line">        Pair[][] dp = <span class="keyword">new</span> Pair[n][n];</span><br><span class="line">        <span class="comment">//1,先进行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2,设置base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][i].fir = piles[i];</span><br><span class="line">            dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历的顺序是根据上图来的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = piles[i] + dp[i + <span class="number">1</span>][j].sec;</span><br><span class="line">                <span class="keyword">int</span> right = piles[j] + dp[i][j - <span class="number">1</span>].sec;</span><br><span class="line">                <span class="comment">//4,fir先进行选择，选完之后sec的状态也随之修改</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    dp[i][j].fir = left;</span><br><span class="line">                    dp[i][j].sec = dp[i + <span class="number">1</span>][j].fir;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].fir = right;</span><br><span class="line">                    dp[i][j].sec = dp[i][j - <span class="number">1</span>].fir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Pair res = dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res.fir - res.sec &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个类中存放了先手和后手的最大值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fir, sec;</span><br><span class="line">    Pair(<span class="keyword">int</span> fir, <span class="keyword">int</span> sec) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fir = fir;</span><br><span class="line">        <span class="keyword">this</span>.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（4）最小路径和"><a href="#（4）最小路径和" class="headerlink" title="（4）最小路径和"></a>（4）最小路径和</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-73.png" alt="sf-2-73" style="zoom:67%;" />

<p><strong>思路</strong>：</p>
<p>A，<u>定义dp函数</u>：dp(int[][] grid, int i, int j)表示从(0, 0)到(i, j)需要的最小路径值</p>
<p>B，<u>明确初始值</u>：起点本身到自己的值就是0</p>
<p>C，<u>状态转移</u>：由于只能向右或向下，grid[i][j]取决于dp(grid,  i - 1,j)和dp(grid, i , int j - 1)中的小的那个加上自己</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(grid, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">        memo[i][j] = Math.min(dp(grid, i - <span class="number">1</span>, j), dp(grid, i, j -<span class="number">1</span>)) + grid[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.length;</span><br><span class="line">	<span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">	<span class="comment">/**** base case ****/</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">	<span class="comment">/*******************/</span></span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）高楼扔鸡蛋"><a href="#（5）高楼扔鸡蛋" class="headerlink" title="（5）高楼扔鸡蛋"></a>（5）高楼扔鸡蛋</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-74.png" alt="sf-2-74"></p>
<p><strong>思路</strong>：状态就是当前拥有的鸡蛋数量和需要测试的楼层N，选择就是选择那层去扔鸡蛋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少实验的次数</span></span><br><span class="line">        <span class="comment">// 注意：</span></span><br><span class="line">        <span class="comment">// 1、i 表示的是楼层的大小，不是第几层的意思，例如楼层区间 [8, 9, 10] 的大小为 3，这一点是在状态转移的过程中调整的定义</span></span><br><span class="line">        <span class="comment">// 2、j 表示可以使用的鸡蛋的个数，它是约束条件，我个人习惯放在后面的维度，表示消除后效性的意思</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 个楼层和 0 个鸡蛋的情况都需要算上去，虽然没有实际的意义，但是作为递推的起点，被其它状态值所参考</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于求的是最小值，因此初始化的时候赋值为一个较大的数，9999 或者 i 都可以</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：填写下标为 0、1 的行和下标为 0、1 的列</span></span><br><span class="line">        <span class="comment">// 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 0</span></span><br><span class="line">        <span class="comment">// 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度（想想复杂度的定义）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第 2 行，第 2 列开始填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; k++) &#123;</span><br><span class="line">                    <span class="comment">// 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1</span></span><br><span class="line">                    <span class="comment">// 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少</span></span><br><span class="line">                    <span class="comment">// 两种情况都做了一次尝试，所以加 1</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - k][j]) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][K];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（6）魔塔"><a href="#（6）魔塔" class="headerlink" title="（6）魔塔"></a>（6）魔塔</h3><p>困难</p>
<h3 id="（7）辐射"><a href="#（7）辐射" class="headerlink" title="（7）辐射"></a>（7）辐射</h3><p>困难</p>
<h3 id="（8）加权最短路径"><a href="#（8）加权最短路径" class="headerlink" title="（8）加权最短路径"></a>（8）加权最短路径</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-75.png" alt="sf-2-75"></p>
<p><strong>思路</strong>：对于无权图，可以用BFS来获得最短路径；有权图，可以用Dijkstra来获取最短路径，这里用动态规划</p>
<p>A，<u>定义dp函数</u>：int dp(int s, int k)，这个函数指的是，从起点src出发，k步之内到节点s的最小花费</p>
<p>B，<u>明确base case</u>：如果s &#x3D;&#x3D; src，那么返回0；如果k &#x3D;&#x3D; 0，那么就无解啦，返回-1</p>
<p>C，<u>状态转移</u>：对于重点o，我只需要知道和它相连的节点和权重a（weight 1），b（weight 2）……，这样就可以算出到o的最小花费,，算法是min(dp(a, k - 1) + weight1,  dp(b, k - 1) + weight2)，这里注意需要是k - 1步，留一步到o</p>
<p>注：这样进行状态转移，我们就得知道指向某个节点的全部节点，以及权重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1,用来存储到某个节点的入度</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; indegree;</span><br><span class="line">    <span class="keyword">int</span> src,dst;</span><br><span class="line">    <span class="keyword">int</span> memo[][];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        indegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.dst = dst;</span><br><span class="line">        <span class="comment">//k表示节点数，步数应该+1</span></span><br><span class="line">        k++;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">888</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] flight : flights)&#123;</span><br><span class="line">            <span class="keyword">int</span> to = flight[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> from = flight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> cost = flight[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//保存某个节点的入度</span></span><br><span class="line">            indegree.putIfAbsent(to, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            indegree.get(to).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;from, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(dst, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(s == src) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[s][k] != -<span class="number">888</span>) <span class="keyword">return</span> memo[s][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(indegree.containsKey(s))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] v : indegree.get(s))&#123;</span><br><span class="line">                <span class="keyword">int</span> from = v[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> cost = v[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//看看相邻的节点的花费怎么样</span></span><br><span class="line">                <span class="keyword">int</span> subProblem = dp(from, k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(subProblem != -<span class="number">1</span>)&#123;</span><br><span class="line">                    res = Math.min(res, subProblem + cost);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">            memo[s][k] = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memo[s][k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[s][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七，其他经典算法"><a href="#七，其他经典算法" class="headerlink" title="七，其他经典算法"></a>七，其他经典算法</h1><h2 id="1，数学算法"><a href="#1，数学算法" class="headerlink" title="1，数学算法"></a>1，数学算法</h2><h3 id="（1）如何高效寻找素数"><a href="#（1）如何高效寻找素数" class="headerlink" title="（1）如何高效寻找素数"></a>（1）如何高效寻找素数</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-76.png" alt="sf-2-76" style="zoom: 80%;" />

<p><strong>思路</strong>：普通做法当然是遍历啦，判断范围内每个数到底是不是素数。再进阶一点就是对于每个数，判断2~sqrt（这个数）这个范围就行。但是还不够高效</p>
<p>A，<u>反着来</u>：从2开始，我们知道2是素数，那么2的倍数肯定不是素数；3是素数，3的倍数肯定不是素数。这个方法也叫筛选法。</p>
<p>那么对于一个范围内的数，可以先假设都是素数，然后把它们的倍数都设置为非素数，漏下来的就都是素数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1,这里只需要遍历到sqrt(n)就行了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//避免重复标记</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; n; j += i)&#123;</span><br><span class="line">                    isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrim[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）两道常考的阶乘算法题"><a href="#（2）两道常考的阶乘算法题" class="headerlink" title="（2）两道常考的阶乘算法题"></a>（2）两道常考的阶乘算法题</h3><p><strong>（力扣172——阶乘后的零）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-77.png" alt="sf-2-77"></p>
<p><strong>思路</strong>：第一种思路就是统计每个数中5的个数，但是要遍历一遍；第二种思路就是统计特殊值的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span>(temp % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp = temp / <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣793——阶乘后k个零）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-78.png" alt="sf-2-78" style="zoom: 80%;" />

<p><strong>思路</strong>：转换一下，就是求有多少个x 满⾜ trailingZeroes(x) &#x3D;&#x3D; k，那么我们可以求满⾜条件的 x 最⼩是多少，最⼤是多少，最⼤值和最⼩值⼀减就是满足的个数。</p>
<p>上面就是一个二分法的思路，下边界是0（也就是0个满足），上边界呢？题目中给出的限制是x &lt;&#x3D; 10^9,Integer.MAX_VALUE不够，我们用Long.MAX_VALUE</p>
<p>所以，最后的问题就是在区间 [0, LONG_MAX] 中寻找满⾜ trailingZeroes(n) &#x3D;&#x3D; K 的左侧边界和右侧边界  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没通过，后面复习了二分查找可以再看看</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (<span class="keyword">int</span>)(rightBound(k) - leftBound(k) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">leftBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= Long.MAX_VALUE || trailingZeroes(lo) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">rightBound</span><span class="params">(<span class="keyword">long</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = Long.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(trailingZeroes(mid) &lt; target)&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(trailingZeroes(mid) &gt; target)&#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hi = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt; <span class="number">0</span> || trailingZeroes(hi) != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> divisor = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//能被5整除的数统计一遍，能被5*5整除的数统计一遍,以此类推</span></span><br><span class="line">        <span class="keyword">while</span>(divisor &lt;= n)&#123;</span><br><span class="line">            res += n / divisor;</span><br><span class="line">            divisor *= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="（3）如何在无限序列中随机抽取元素"><a href="#（3）如何在无限序列中随机抽取元素" class="headerlink" title="（3）如何在无限序列中随机抽取元素"></a>（3）如何在无限序列中随机抽取元素</h3><p>如果让你只能遍历对象（特备是链表这种）一遍，并且同等概率的取出其中的一个或者k个元素，应该怎么办？</p>
<p>先说一个元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的一个随机节点，核心是：当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">//这里在遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//生成一个[0,i)之间的随机整数，这个整数等于0的概率就是1/i,从而判断是否更新这个值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-79.png" alt="sf-2-79"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的K个随机节点，核心是：当如果要随机选择 k 个数，只要在第 i 个元素处以 k/i 的概率选择该元素，以 1 - k/i 的概率保持原有选择即可（数学证明看图）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前k个元素默认选上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; p != <span class="keyword">null</span>; j++)&#123;</span><br><span class="line">        res[j] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//第一次生成一个[0,i)之间的整数</span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i);</span><br><span class="line">        <span class="comment">//这个整数⼩于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k)&#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-80.png" alt="sf-2-80"></p>
<p><strong>（力扣382——链表随机节点）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-81.png" alt="sf-2-81" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Random r;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        r = <span class="keyword">new</span> Random();</span><br><span class="line">        ListNode p = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(i))&#123;</span><br><span class="line">                res = p.val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣398——随机数索引）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-82.png" alt="sf-2-82" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意这里的k要从0开始，不然从1开始会出错，我也不知道为啥出错</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == r.nextInt(k))&#123;</span><br><span class="line">                    res = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣528——权重随机选择）</strong></p>
<h3 id="（4）吃葡萄"><a href="#（4）吃葡萄" class="headerlink" title="（4）吃葡萄"></a>（4）吃葡萄</h3><p><strong><a href="https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada">（牛客——吃葡萄）</a></strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-83.png" alt="sf-2-83" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>吃的最多的人要吃的最少—&gt;也就是尽量要平分这些葡萄。假设没有吃的种类的限制，那么（总数&#x2F;3）向上去整就能得到想要的结果。（<u>注：如果你想计算 M 除以 N，M &#x2F; N 会向下取整，你想向上取整的话，可以改成 (M+(N-1)) &#x2F; N</u>  ）</p>
<p>但是因为有了条件限制，那么三种葡萄构成了三条边a,b,c，这三条边可以对应三角形的组成的两种情况：</p>
<p>第一种：a + b &gt; c，此时可以组成三角形（&#x3D;的情况虽然不是三角形，但也是平均分最合理），此时可以通过(a + b + c + 2) &#x2F; 3来获取平均分配后的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-84.png" alt="sf-2-84" style="zoom:67%;" />

<p>第二种：a + b &lt;&#x3D; c &amp;&amp; c &lt;&#x3D;  2*(a+b) </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-86.png" alt="sf-2-86"></p>
<p>第二种：c &gt; 2*(a+b)  ，此时不能是三角形，尽量要平分的话，就是一个人吃完a + b两种葡萄，剩下两人平分c</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-85.png" alt="sf-2-85" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        <span class="keyword">long</span>[][] purples = <span class="keyword">new</span> <span class="keyword">long</span>[k][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            purples[i][<span class="number">0</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">1</span>] = sc.nextLong();</span><br><span class="line">            purples[i][<span class="number">2</span>] = sc.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            System.out.println(solution(purples[i]));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span>[] nums)</span></span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">long</span> sum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] + nums[<span class="number">1</span>] &gt;= nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + <span class="number">2</span>) / <span class="number">3</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*(nums[<span class="number">0</span>] + nums[<span class="number">1</span>]) &lt; nums[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[<span class="number">2</span>] + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（5）同时寻找缺失和重复的元素"><a href="#（5）同时寻找缺失和重复的元素" class="headerlink" title="（5）同时寻找缺失和重复的元素"></a>（5）同时寻找缺失和重复的元素</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-87.png" alt="sf-2-87" style="zoom: 80%;" />

<p><strong>思路</strong>：对于遍历的一个数值，我们将对应的下标元素变为负数，如果遍历到的数值对应下标的值已经是负数，那么这个值就是重复的，下标就是缺失的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1，遍历数组，将遍历到的值对应下标的值变为负数，表示这个索引有对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> dup = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lost = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，在循环中把数字对应下标的值标记为负数，此时若发现对应下标已经被标记过，则这个数重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nums[a - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                dup = a;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[a - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,遍历数据，如果发现还有没有标记的数，则对应下标就是确实的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                lost = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dup, lost&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2，面试必知必会"><a href="#2，面试必知必会" class="headerlink" title="2，面试必知必会"></a>2，面试必知必会</h2><h3 id="（1）nSum问题"><a href="#（1）nSum问题" class="headerlink" title="（1）nSum问题"></a>（1）nSum问题</h3><p><strong>（两数之和）</strong></p>
<p><strong>引入</strong>：就是一个数组中的两个元素的和是不是等于特定值，可以用哈希表的方式来解决；或者将数组排序使用双指针</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-89.png" alt="sf-2-89" style="zoom:80%;" />

<p><strong>思路</strong>：我们排序后使用双指针，由于有重复,那么当指针当前指向的两个元素能够组成目标值时，两个指针应该跳过所有相同的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] toRes = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] temp : res)&#123;</span><br><span class="line">        toRes[i] = temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>（力扣15——三数之和）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-90.png" alt="sf-2-90" style="zoom:80%;" />

<p><strong>思路</strong>：同样还是对数组进行排序，然后遍历数组，对于某个位置上的数x，假设它在结果中，那我们就需要找两个数，满足target - x，问题得以转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; towSum = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            towSum = twoSumTarget(nums, i + <span class="number">1</span>, <span class="number">0</span> -(nums[i]));</span><br><span class="line">            <span class="keyword">if</span>(towSum.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt;  two : towSum)&#123;</span><br><span class="line">                    two.add(nums[i]);</span><br><span class="line">                    res.add(two);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; twoSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(left);</span><br><span class="line">                list.add(right);</span><br><span class="line">                res.add(list);</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                <span class="keyword">while</span>(hi &gt; lo &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（力扣18——四数之和）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-91.png" alt="sf-2-91"></p>
<p><strong>思路</strong>：到这里应该直接写一个nsum的通用算法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nSumTarget(nums, <span class="number">4</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1,输入数组，求几个数的和，开始坐标，以及目标值</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; nSumTarget(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = nums.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,这是一个base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span> || sz &lt; n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，2个数其实也是一个base case算法</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> lo = start, hi = sz - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">                <span class="keyword">int</span> left = nums[lo],right = nums[hi];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(left);</span><br><span class="line">                    list.add(right);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//这里递归计算n - 1个数的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; sz; i++)&#123;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; temp_res = nSumTarget(nums, n - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">                <span class="comment">//如果temp_res不为空，这里能加入进去</span></span><br><span class="line">                <span class="keyword">for</span>(List&lt;Integer&gt; temp : temp_res)&#123;</span><br><span class="line">                    temp.add(nums[i]);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）区间问题"><a href="#（2）区间问题" class="headerlink" title="（2）区间问题"></a>（2）区间问题</h3><p>（力扣1288——删除被覆盖的区间）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-92.png" alt="sf-2-92"></p>
<p><strong>思路</strong>：对于这些区间，我们先排序，按照起点升序排序，终点降序排序（这样能确保起点相同的区间，是长的那个在上面）；排序结束后，便可遍历，会有三种情况，对于每种情况进行不同的处理。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-93.png" alt="sf-2-93" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,这里按照起点升序，起点相同时终点降序排列。</span></span><br><span class="line">        Arrays.sort(intervals, (a, b)-&gt;&#123;<span class="comment">//返回值大于0，就是a大，返回值小于0，就是b大。sort默认从小到大排序</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2,设置第一个值为起点</span></span><br><span class="line">        <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3，开始遍历判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="comment">//第一种情况，包含第二个区间</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= left &amp;&amp; intervals[i][<span class="number">1</span>] &lt;= right)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第二种情况，两个区间部分相交，需要扩大右边界</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right &amp;&amp; intervals[i][<span class="number">1</span>] &gt;= right)&#123;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三种情况，完全不相交</span></span><br><span class="line">            <span class="keyword">if</span>(right &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（）还有两道题，后面再来写</p>
<h3 id="（3）快速选择算法"><a href="#（3）快速选择算法" class="headerlink" title="（3）快速选择算法"></a>（3）快速选择算法</h3><p><strong>（力扣215——数组中第K个最大的元素）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-94.png" alt="sf-2-94"></p>
<p><strong>思路</strong>：两种方法，一个是二叉堆，一个是快速选择算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1），使用二叉堆的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,使用优先级队列，这里默认是小根堆，如果是大根堆，还需要处理一下</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2，对于每个元素，先加进去，如果此时pq大小超过k，则要去除堆顶元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : nums)&#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3，剩下的就是我们要的第k大的元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2），使用快速选择算法，它的时间复杂度更低，是快速排序的简化版（参考3）</span></span><br><span class="line"><span class="comment">//:我们要找第K大的元素，partition 函数会返回p，那么我们可以把 p 和 k 进⾏⽐较，如果 p &lt; k 说明第 k ⼤的元素在 nums[p+1..hi] 中，如果 p &gt; k 说明第 k ⼤的元素在 nums[lo..p-1] 中。</span></span><br><span class="line"><span class="comment">//:题⽬要求的是「第 k 个最⼤元素」，这个元素其实就是 nums 升序排序后「索引」为 len(nums) - k 的这个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="comment">//这个p就是一个数字最终的位置</span></span><br><span class="line">        <span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(p &lt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[p + 1] ~ nums[hi]之间</span></span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p &gt; k)&#123;</span><br><span class="line">            <span class="comment">//这表示第k大的元素在nuns[lo] ~ nums[p - 1]之间</span></span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）快速排序回顾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo , <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 通过交换元素构建分界点索引 p</span></span><br><span class="line">	<span class="keyword">int</span> p = partition(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line">	<span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line">	sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">	sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo == hi) <span class="keyword">return</span> lo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1，将lo位置的元素作为基准比较元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里j要+1，因为后面要先自减</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//找一个比pivot大的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[++i] &lt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找一个比pivot小的元素，定位在这里</span></span><br><span class="line">        <span class="keyword">while</span>(nums[--j] &gt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果走到这里，说明这两个元素需要换位置，确保lo~i的范围比pivot小，lo~j的范围比pivot大</span></span><br><span class="line">        swap(nums, i, j); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将pivot放到中间那个划分的位置</span></span><br><span class="line">    swap(nums, j , lo);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）分治法"><a href="#（4）分治法" class="headerlink" title="（4）分治法"></a>（4）分治法</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-95.png" alt="sf-2-95" style="zoom:67%;" />

<p><strong>思路</strong>：对于一个复杂问题的，但是可以划分为子问题（分），最后右子问题获取到总的结果（治），我们可以尝试使用分治法，这是递归的一个思想，对于本题我们可以从下面的思路中进行思考：</p>
<p>A，对于一个expression，我们可以获得一个运算符，并把它分为运算符左边的字符串和右边的字符串。</p>
<p>B，分别计算左边和右边字符串的结果，可能会返回很多值（前两步就是分）</p>
<p>C，那么A中这个运算符的结果就是由B中返回的值组合而成（治）</p>
<p>D，需要考虑Base Case</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = expression.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> )&#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; rigth = diffWaysToCompute(expression.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a : left)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b : rigth)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a + b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a - b);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                            res.add(a * b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Integer.parseInt(expression));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="（5）扫描线（安排会议室）"><a href="#（5）扫描线（安排会议室）" class="headerlink" title="（5）扫描线（安排会议室）"></a>（5）扫描线（安排会议室）</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-96.png" alt="sf-2-96" style="zoom: 67%;" />

<p><strong>思路</strong>：如下图，将会议区间投影到时间线上，用一个蓝色的线去进行扫描，如果遇到红色的点，则计数+1，遇到蓝色的点，则计数-1，进而count的最大值就是我们要的到的结果</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-97.png" alt="sf-2-97" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetignRooms</span><span class="params">(<span class="keyword">int</span>[][] meetings)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = meetings.length;</span><br><span class="line">    <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//1,这里用start来保存起点，end来保存重点，并排序，模拟出上图中的点的排序情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        start[i] = meetings[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = meetings[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(start);</span><br><span class="line">    Arrays.sort(end);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，这里我们开始模拟扫描，过程中我们去记录当前重叠的会议，并将最大的情况赋给res</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i] &lt; end[j])&#123;</span><br><span class="line">            <span class="comment">//同一时间又有一个会议，所以count++</span></span><br><span class="line">            conut++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//同一时间有个会议结束了，count--</span></span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（6）贪心算法1"><a href="#（6）贪心算法1" class="headerlink" title="（6）贪心算法1"></a>（6）贪心算法1</h3><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-98.png" alt="sf-2-98" style="zoom: 67%;" />

<p><strong>思路</strong>：两种算法，第一种是根据数据分析的做法（数学做法）；第二种是贪心思想</p>
<p>第一种：数据分析</p>
<p>这里有两个数组，我们可以将其归并为一个数组（油箱结余），然后画出变化图，我们发现，要找的起点是最低点（当然如果从最低点开始油箱中都会出现负数，那就是不行）</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-99.png" alt="sf-2-99" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,min记录此时的邮箱结余最小值，start记录起点，sum记录油量和花费的总差值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2，遍历数组，更新上面的这些值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; min)&#123;</span><br><span class="line">                min = sum;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3,注意这里是环形数组</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start == gas.length ? <span class="number">0</span> : start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：如果从i到j恰好出现了油箱中的油为负数的情况，那么i ~ j中间的节点k都不会是起点。因为此时i ~ j-1油箱中的油肯定都是正数，j-1 ~ j的消耗太大。所以如果在遍历的过程中，sum值变为负数，那么就将起点设置为j</p>
<p>贪心的关键在于，如果找不到重复计算，那就通过问题中⼀些隐藏较深的规律，来减少冗余计算  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, n = gas.length;</span><br><span class="line">        <span class="comment">//1,先把不好弄的情况给排除了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2,开始贪心，注意这里start取新的起点应该是i + 1</span></span><br><span class="line">        <span class="keyword">int</span> tank = <span class="number">0</span>,start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            tank += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start == n ? <span class="number">0</span> : start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（7）贪心算法2"><a href="#（7）贪心算法2" class="headerlink" title="（7）贪心算法2"></a>（7）贪心算法2</h3><p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/sf-2-100.png" alt="sf-2-100"></p>
<p><strong>思路</strong>：这里和之前的区间问题类似，先将区间排序，然后采用下面的策略</p>
<p> 1、要⽤若⼲短视频凑出完成视频 [0, T]，⾄少得有⼀个短视频的起点是 0。<br>        2、如果有⼏个短视频的起点都相同，那么⼀定应该选择那个最⻓（终点最⼤）的视频。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(clips,(a, b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clips[<span class="number">0</span>][<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, curEnd = <span class="number">0</span>, nextEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; clips.length &amp;&amp; clips[i][<span class="number">0</span>] &lt;= curEnd)&#123;</span><br><span class="line">                nextEnd = Math.max(nextEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">            <span class="keyword">if</span>(curEnd &gt;= time)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>（8）</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
  <entry>
    <title>尚融宝项目背景</title>
    <url>/2022/02/05/%E4%B8%8D%E5%81%9A%E4%BA%86/xm-1-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<p>**简介：尚融宝是尚硅谷培训机构的一个中等规模的项目，实现了一个网络借贷信息中介服务平台，为个人投资者、个人融资用户和小微企业提供专业的线上信贷及出借撮合服务。是学习微服务一个不错的项目。</p>
<span id="more"></span>

<h1 id="一，项目简介"><a href="#一，项目简介" class="headerlink" title="一，项目简介"></a>一，项目简介</h1><h2 id="1，项目的业务流程"><a href="#1，项目的业务流程" class="headerlink" title="1，项目的业务流程"></a>1，项目的业务流程</h2><p>业务流程如下图，从业务流程图可以看出，每个步骤必须有一个开始和结束，中间没有特别复杂的分支，设计业务的时候就应该像这样清晰简洁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-1.png" alt="xm-1-1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-2.png" alt="xm-1-2"></p>
<h2 id="2，项目的架构图"><a href="#2，项目的架构图" class="headerlink" title="2，项目的架构图"></a>2，项目的架构图</h2><p>从架构图可以看出，不同服务之间的前端，网关，配置，数据库都可能会不一样，并且在发布时使用了Doker技术</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-3.png" alt="xm-1-3"></p>
<h1 id="二，技术栈（注意版本）"><a href="#二，技术栈（注意版本）" class="headerlink" title="二，技术栈（注意版本）"></a>二，技术栈（注意版本）</h1><p>首先基础的部分需要掌握：java基础、HTML、CSS、JavaScript、Spring、SpringMVC、MyBatis、SpringBoot、SpringCloud Alibaba，MySQL（5.7及以上）、Redis、RabbitMQ、nginx、idea、maven、VMWare 虚拟机、CentOS 操作系统</p>
<h2 id="1，后端"><a href="#1，后端" class="headerlink" title="1，后端"></a>1，后端</h2><p><strong>SpringBoot 2.3.4.RELEASE</strong></p>
<p><strong>SpringCloud Hoxton.SR8：</strong>微服务基础设施 - 服务注册、服务发现、服务熔断、微服务网关、配置中心等</p>
<p>SpringCloud Alibaba 2.2.2.RELEASE</p>
<p><strong>MyBatis Plus：持久层框架和代码生成器</strong></p>
<p>Lombok：简化实体类开发</p>
<p>Swagger2：Api接口文档生成工具</p>
<p>Logback：日志系统</p>
<p>alibaba-easyexcel：Excel读写</p>
<p><strong>Spring Data Redis：Spring项目中访问Redis缓存</strong></p>
<p>HTTPClient: 基于Http协议的客户端，用来实现远程调用</p>
<p>Spring Task：定时任务</p>
<h2 id="2，数据库和中间件"><a href="#2，数据库和中间件" class="headerlink" title="2，数据库和中间件"></a>2，数据库和中间件</h2><p><strong>MySQL 5.7：关系型数据库   管理工具：Navicat</strong></p>
<p><strong>Redis 5.0：缓存技术   管理工具：RedisDesktopManager</strong></p>
<p><strong>RabbitMQ 3.8：消息中间件</strong></p>
<h2 id="3，三方接口"><a href="#3，三方接口" class="headerlink" title="3，三方接口"></a>3，三方接口</h2><p>阿里云短信：短信网关</p>
<p>阿里云OSS：分布式文件存储</p>
<p>资金托管平台API对接：汇付宝</p>
<h2 id="4，了解即可"><a href="#4，了解即可" class="headerlink" title="4，了解即可"></a>4，了解即可</h2><p>Node.js： JavaScript 运行环境</p>
<p>ES6：JavaScript的模块化版本</p>
<p>axios：一个发送Ajax请求的工具</p>
<p>Vue.js：web 界面的渐进式框架</p>
<p>Element-UI：前端组件库</p>
<p>模块化开发：解决javascript变量全局空间污染的问题</p>
<p>NPM：模块资源管理器</p>
<p>vue-element-admin：基于Vue.js的后台管理系统UI集成方案</p>
<p>NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架</p>
<h1 id="三，开发环境"><a href="#三，开发环境" class="headerlink" title="三，开发环境"></a>三，开发环境</h1><h2 id="1，开发环境检测"><a href="#1，开发环境检测" class="headerlink" title="1，开发环境检测"></a>1，开发环境检测</h2><p>在开始开发之前，需要确定基本的环境是否和开发要求的一致，在本项目中，要检查以下几个方面：</p>
<ul>
<li><p>jdk 1.8 配置：JAVA_HOME，path</p>
</li>
<li><p>maven 3.6 配置：MAVEN_HOME，本地仓库</p>
</li>
<li><p>ideaIU-2020.2.3，尽量在欢迎页面进行设置，这样对所有项目都是普遍有效的，当然给特定项目设置也是可以的，这里注意通过File–&gt;close project来到欢迎界面，如果不想每次打开idea都进入已有的项目（特别是大的项目，加载就得好一会），可以通过在Setting-&gt;System Settings取消勾选Reopen last project on open（如下图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-4.png" alt="xm-1-4"></p>
<p><em>注意：在idea的欢迎页面选择Configure &gt; settings</em>（比较新的版本似乎取消了右下角的Configure，比如我的idea 2021，要设置的话可以参考下图）。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-5.png" alt="xm-1-5"></p>
</li>
</ul>
<p>接着就是在开始一个项目时，一些基础的配置，<em>包括配置：Java Compiler、File Encodings、Maven、Auto Import、Code Completion &gt; Match case（取消）</em>  <em>插件：lombok、MyBatisX</em></p>
<p>1，Java Compiler。需要在Setting中（搜索Java Compiler），设置编译器为javac，版本为自己安装的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-6.png" alt="xm-1-6"></p>
<p>2，File Encodings。同上，如图，需要设置三个地方的编码方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-7.png" alt="xm-1-7"></p>
<p>3，maven</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-8.png" alt="xm-1-8"></p>
<p>4，Auto Import、Code Completion &gt; Match case（取消) 插件：lombok、MyBatisX</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-9.png" alt="xm-1-9"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-1-10.png" alt="xm-1-10"></p>
<p>5，插件：lombok、MyBatisX</p>
<p>插件安装这里不再赘述</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>xm-3-项目基本功能</title>
    <url>/2022/03/29/%E4%B8%8D%E5%81%9A%E4%BA%86/xm-3-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p><strong>简介：</strong>该文章目标是：xxx，这里主要有x部分内容：1，xxx；2，xxx；3，xxx。</p>
<span id="more"></span>

<h1 id="一，后端接口工程"><a href="#一，后端接口工程" class="headerlink" title="一，后端接口工程"></a>一，后端接口工程</h1><h2 id="1，创建接口工程的架构"><a href="#1，创建接口工程的架构" class="headerlink" title="1，创建接口工程的架构"></a>1，创建接口工程的架构</h2><h3 id="（1）模块和依赖的设置"><a href="#（1）模块和依赖的设置" class="headerlink" title="（1）模块和依赖的设置"></a>（1）模块和依赖的设置</h3><p>这部分直接看Part04-01就可以，注意新建项目的时候有几点需要注意，可以看视频</p>
<p><strong>考点</strong>：maven的使用</p>
<h3 id="（2）代码生成器"><a href="#（2）代码生成器" class="headerlink" title="（2）代码生成器"></a>（2）代码生成器</h3><p>看Part04-01</p>
<p>2.1  在Navicat中新建数据库和表，这里有线程的脚本</p>
<p>2.2  使用Mybits-Plus来配置代码生成器，这部分代码不用掌握，<a href="https://baomidou.com/pages/d357af/#%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">官网</a>有。项目中使用代码生成器生成的代码不需要放在最终的项目中，所以我们是在service-core的test目录下创建一个包来运行代码生成器的代码。代码中一些参数的含义自行百度，这里不再啰嗦。这里补充一些关键的</p>
<p>首先关于Swagger的配置时打开的，那么我们要先引入Swagger的依赖，然后最后生成的bean中会有Swagger相关的注解（后面用）</p>
<p>然后是代码最后使用了策略控制的代码</p>
<p><strong>注意</strong>：本人在测试的时候出现了问题，提示数据库无法解析，因为数据库名写错了（db200921_srb_core）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: java.sql.SQLSyntaxErrorException: Unknown database &#x27;db_200921_srb_core&#x27;</span><br><span class="line"></span><br><span class="line">	at com.baomidou.mybatisplus.generator.config.DataSourceConfig.getConn(DataSourceConfig.java:170)</span><br><span class="line">	at com.baomidou.mybatisplus.generator.config.builder.ConfigBuilder.&lt;init&gt;(ConfigBuilder.java:110)</span><br><span class="line">	at com.baomidou.mybatisplus.generator.AutoGenerator.execute(AutoGenerator.java:96)</span><br><span class="line">	at com.atguigu.srb.core.CodeGenerator.genCode(CodeGenerator.java:58)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p><strong>考点</strong>：MyBatis-plus的使用，Mysql数据库链接的知识</p>
<h3 id="（3）配置及启动项目"><a href="#（3）配置及启动项目" class="headerlink" title="（3）配置及启动项目"></a>（3）配置及启动项目</h3><p>看Part04-01</p>
<p>3.1  创建配置文件D:\MyCodingRoom\IdeaWorkSpace\srb\service-core\src\main\resources\application.yml ，其中应该怎么填是Spring-boot中的知识</p>
<p>3.2  在service-core中创建config包，创建MybatisPlusConfig类</p>
<p>3.3 在service-core的com.atguigu.srb.core下创建springboot的主类（启动类），启动成功可以看到我们配置的端口号</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-3-1.png" alt="xm-3-1"></p>
<p><strong>知识点</strong>：SpringBoot的主类，MyBatis-plus的配置和配置类应该怎么设置（配置类中实现了分页）</p>
<p><strong>考点</strong>：SpringBoot启动流程</p>
<h3 id="（4）实现积分等级的CRUD"><a href="#（4）实现积分等级的CRUD" class="headerlink" title="（4）实现积分等级的CRUD"></a>（4）实现积分等级的CRUD</h3><p>看Part04-02</p>
<p>这里对应的integral_grade这张表</p>
<p>4.1  实现查询：在controller中添加admin包，添加AdminIntegralGradeController类,admin包存放用来进行后台管理的接口</p>
<p>​       在上面那个类中添加list查询方法，然后重启服务，访问： <a href="http://localhost:8110/admin/core/integralGrade/list">http://localhost:8110/admin/core/integralGrade/list</a> 查看结果json数据</p>
<p>4.2  实现删除：AdminIntegralGradeController添加removeById方法</p>
<p>​      使用postman测试删除， <a href="http://localhost:8110/admin/core/integralGrade/remove/1">http://localhost:8110/admin/core/integralGrade/remove/1</a></p>
<p><strong>注意</strong>：下面这到底是不是报错？？？似乎是不是？因为效果是实现了，id为1的数据is_delete字段变为了1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1066f0e9] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@513875093 wrapping com.mysql.cj.jdbc.ConnectionImpl@20b52534] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: UPDATE integral_grade SET is_deleted=1 WHERE id=? AND is_deleted=0</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">&lt;==    Updates: 0</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1066f0e9]</span><br></pre></td></tr></table></figure>

<p><strong>知识点</strong>：SpringMVC的注解</p>
<p><strong>考点</strong>：@CrossOrigin @RestController @Resource都是啥意思呀？</p>
<h3 id="（5）Swagger的引入"><a href="#（5）Swagger的引入" class="headerlink" title="（5）Swagger的引入"></a>（5）Swagger的引入</h3><p>postman做一些简单的接口测试还行，但是在大型项目中，你的方法的mapping要是修改了，postman里面就得一个个自己修改？这能接受吗？太累啦</p>
<p>所以我们用Swagger，能够帮助你根据接口自动生成测试用例哦。</p>
<p>配置看4.2（必须先由Swagger的依赖，自动生成代码的时候才会添加@ApiModel()这样的swagger注解）</p>
<p><strong>知识点</strong>：（1）Swagger的使用配置方式；（2）<strong>常用注解</strong>（看4.2，自行百度了解）；（3）Swagger前后端的Api怎么分组管理（110）；（4）文档描述信息的配置？（ApiInfoBuilder的使用）</p>
<p><strong>考点</strong>：Restful风格的通信方式，特点？与微服务结合？</p>
<h3 id="（6）同一返回结果的定义和使用"><a href="#（6）同一返回结果的定义和使用" class="headerlink" title="（6）同一返回结果的定义和使用"></a>（6）同一返回结果的定义和使用</h3><p><strong>引入</strong>：我们在接口测试的时候，有时候返回的结果自己不太懂怎么办？当然是标准化最好啦，对返回结果定义好使用</p>
<p>配置看4.3</p>
<p><strong>注意</strong>：就因为多了一个逗号，就报错一个Json字符串转换的错误，shit，还好发现了。</p>
<img src="https://cdn.jsdelivr.net/gh/zhao-xxxx/Picture/img/xm-3-2.png" alt="xm-3-2" style="zoom:67%;" /> 

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character (&#x27;&#125;&#x27; (code 125)): was expecting double-quote to start field name</span><br></pre></td></tr></table></figure>

<p><strong>知识点</strong>：（1）设计返回的信息格式；（2）使用枚举类和结果类来辅助返回结果；（3）将接口的返回值直接修改为结果类</p>
<p><strong>考点</strong>：R类的设计中，使用了静态方法，重载方法，Lombok注解。restful风格的传输中对象转换（@RequestBody 注解修饰的参数接受了Json字符串就自动转换咯，然后报错了就尴尬），</p>
<h3 id="（7）统一异常处理"><a href="#（7）统一异常处理" class="headerlink" title="（7）统一异常处理"></a>（7）统一异常处理</h3><p><strong>引入</strong>：如果在调用接口的时候出现异常，返回的json可读性不高，并且情况多样，我们需要一个标准的格式和信息</p>
<p>配置看4.4</p>
<p><strong>知识点</strong>：（1）使用了@RestControllerAdvice，这是一个切面编程中的通知哦，这样就能在controller层添加通知；（2）添加特定异常是需要对应的包哦（比如sql异常需要jdbc包）；（3）使用一个或较少的异常类，可以捕获和显示所有的异常信息。因此，我们可以创建一个自定义异常类<strong>（必须是运行时异常）</strong>，在程序中抛出这个自定义异常对象，并在统一异常处理器中捕获自定义异常对象（所以遇到新的异常，我们是放在业务的代码中进行处理了）；（4）Assert校验业务的异常，避免写if else；（5）4中说的是controller中的异常，那么如果进入Controller之前发生的异常呢？我们最好分开一下</p>
<p><strong>考点</strong>：切面编程；java中的异常处理和异常类；无参构造器注解（为什么必须要有呢？）；Assert怎么使用呢？；抽象类的用法</p>
<h3 id="（8）统一日志处理"><a href="#（8）统一日志处理" class="headerlink" title="（8）统一日志处理"></a>（8）统一日志处理</h3><p><strong>引入</strong>：我们在编程的时候会发现控制台有日志的输出，我们想控制什么样的日志输出，什么样的日志不输出，需要进行统一的管理。日志有等级（观察控制台便可以看出来），分为TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF。默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别(低级别就不打印咯)，我们可以在SpringBoot的配置文件application.yml中进行设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure>

<p> 配置看4.5</p>
<p><strong>知识点</strong>：</p>
<p>A，在core中添加Logback-spring.xml配置文件，这是一个可以被自动加载的名称，注意其中的内容，了解即可</p>
<p><strong>考点</strong>：Spring加载这个配置文件的过程</p>
<h1 id="二，管理平台前端搭建"><a href="#二，管理平台前端搭建" class="headerlink" title="二，管理平台前端搭建"></a>二，管理平台前端搭建</h1><p>前端这里没记笔记，主要是看培训的记录点</p>
]]></content>
      <categories>
        <category>xxx</category>
      </categories>
      <tags>
        <tag>xxx</tag>
      </tags>
  </entry>
</search>
